{"version":3,"file":"slimdom.umd.cjs","sources":["../src/mutation-observer/RegisteredObserver.ts","../src/mutation-observer/RegisteredObservers.ts","../src/mutation-observer/NotifyList.ts","../src/context/WeakRef.ts","../src/context/Context.ts","../src/util/NodeType.ts","../src/util/treeHelpers.ts","../src/util/cloneNode.ts","../src/util/errorHelpers.ts","../src/mutation-observer/MutationRecord.ts","../src/mutation-observer/queueMutationRecord.ts","../src/mixins.ts","../src/util/treeMutations.ts","../src/util/mutationAlgorithms.ts","../src/util/typeHelpers.ts","../src/Node.ts","../src/util/attrMutations.ts","../src/Attr.ts","../src/CharacterData.ts","../src/Text.ts","../src/CDATASection.ts","../src/Comment.ts","../src/DocumentType.ts","../src/unsafe.ts","../src/util/namespaceHelpers.ts","../src/dom-parsing/EntityExpansionGuard.ts","../node_modules/prsc/src/parser-combinators.ts","../src/dom-parsing/ParserStateMachine.ts","../src/dom-parsing/grammar.ts","../src/dom-parsing/parsingAlgorithms.ts","../src/dom-parsing/NamespacePrefixMap.ts","../src/dom-parsing/serializationAlgorithms.ts","../src/Element.ts","../src/util/createElementNS.ts","../src/DOMImplementation.ts","../src/Document.ts","../src/DocumentFragment.ts","../src/ProcessingInstruction.ts","../src/Range.ts","../src/XMLDocument.ts","../src/index.ts","../src/dom-parsing/DOMParser.ts","../src/mutation-observer/MutationObserver.ts","../src/dom-parsing/XMLSerializer.ts"],"sourcesContent":["import { MutationObserverInit, default as MutationObserver } from './MutationObserver';\nimport { MutationRecordInit, default as MutationRecord } from './MutationRecord';\nimport Node from '../Node';\n\n/**\n * A registered observer consists of an observer (a MutationObserver object) and options (a\n * MutationObserverInit dictionary).\n *\n * A transient registered observer is a registered observer that also consists of a source (a\n * registered observer).\n *\n * Transient registered observers are used to track mutations within a given node’s descendants\n * after node has been removed so they do not get lost when subtree is set to true on node’s parent.\n */\nexport default class RegisteredObserver {\n\t/**\n\t * The observer that is registered.\n\t */\n\tpublic observer: MutationObserver;\n\n\t/**\n\t * The Node that is being observed by the given observer.\n\t */\n\tpublic node: Node;\n\n\t/**\n\t * The options for the registered observer.\n\t */\n\tpublic options: MutationObserverInit;\n\n\t/**\n\t * A transient observer is an observer that has a source which is an observer.\n\t */\n\tpublic source: RegisteredObserver | null = null;\n\n\t/**\n\t * @param observer - The observer being registered\n\t * @param node     - The node being observed\n\t * @param options  - Options for the registration\n\t * @param source   - If non-null, creates a transient registered observer for the given\n\t *                   registered observer\n\t */\n\tconstructor(\n\t\tobserver: MutationObserver,\n\t\tnode: Node,\n\t\toptions: MutationObserverInit,\n\t\tsource?: RegisteredObserver\n\t) {\n\t\tthis.observer = observer;\n\t\tthis.node = node;\n\t\tthis.options = options;\n\t\tthis.source = source || null;\n\t\tif (source) {\n\t\t\tobserver._transients.push(this);\n\t\t}\n\t}\n\n\t/**\n\t * Adds the given mutationRecord to the NotifyList of the registered MutationObserver. It only\n\t * adds the record when it's type isn't blocked by one of the flags of this registered\n\t * MutationObserver options (formally the MutationObserverInit object).\n\t *\n\t * @param type                - The type of mutation record to queue\n\t * @param target              - The target node\n\t * @param data                - The data for the mutation record\n\t * @param interestedObservers - Array of mutation observer objects to append to\n\t * @param pairedStrings       - Paired strings for the mutation observer objects\n\t */\n\tpublic collectInterestedObservers(\n\t\ttype: string,\n\t\ttarget: Node,\n\t\tdata: MutationRecordInit,\n\t\tinterestedObservers: MutationObserver[],\n\t\tpairedStrings: (string | null | undefined)[]\n\t) {\n\t\t// (continued from RegisteredObservers#queueMutationRecord)\n\n\t\t// 3.1. Let options be registered's options.\n\t\t// 3.2. If none of the following are true\n\t\t// node is not target and options[\"subtree\"] is false\n\t\tif (this.node !== target && !this.options.subtree) {\n\t\t\treturn;\n\t\t}\n\n\t\t// type is \"attributes\" and options[\"attributes\"] is not true\n\t\tif (type === 'attributes' && !this.options.attributes) {\n\t\t\treturn;\n\t\t}\n\n\t\t// type is \"attributes\", options[\"attributeFilter\"] exists, and options[\"attributeFilter\"]\n\t\t// does not contain name or namespace is non-null\n\t\t// (attributeFilter not implemented)\n\n\t\t// type is \"characterData\" and options[\"characterData\"] is not true\n\t\tif (type === 'characterData' && !this.options.characterData) {\n\t\t\treturn;\n\t\t}\n\n\t\t// type is \"childList\" and options[\"childList\"] is false\n\t\tif (type === 'childList' && !this.options.childList) {\n\t\t\treturn;\n\t\t}\n\n\t\t// then:\n\n\t\t// 3.2.1. Let mo be registered's observer.\n\t\t// 3.2.2. If interestedObservers[mo] does not exist, then set interestedObservers[mo] to\n\t\t// null\n\t\tlet index = interestedObservers.indexOf(this.observer);\n\t\tif (index < 0) {\n\t\t\tindex = interestedObservers.length;\n\t\t\tinterestedObservers.push(this.observer);\n\t\t\tpairedStrings.push(undefined);\n\t\t}\n\n\t\t// 3.2.3. If either type is \"attributes\" and options[\"attributeOldValue\"] is true, or type\n\t\t// is \"characterData\" and options[\"characterDataOldValue\"] is true, then set\n\t\t// interestedObservers[mo] to oldValue.\n\t\tif (\n\t\t\t(type === 'attributes' && this.options.attributeOldValue) ||\n\t\t\t(type === 'characterData' && this.options.characterDataOldValue)\n\t\t) {\n\t\t\tpairedStrings[index] = data.oldValue;\n\t\t}\n\t}\n}\n","import { MutationObserverInit, default as MutationObserver } from './MutationObserver';\nimport { MutationRecordInit } from './MutationRecord';\nimport RegisteredObserver from './RegisteredObserver';\nimport Node from '../Node';\n\n/**\n * Each node has an associated list of registered observers.\n */\nexport default class RegisteredObservers {\n\t/**\n\t * The node for which this RegisteredObservers lists registered MutationObserver objects.\n\t */\n\tprivate _node: Node;\n\n\tprivate _registeredObservers: RegisteredObserver[] = [];\n\n\t/**\n\t * @param node - Node for which this instance holds RegisteredObserver instances.\n\t */\n\tconstructor(node: Node) {\n\t\tthis._node = node;\n\t}\n\n\t/**\n\t * Registers a given MutationObserver with the given options.\n\t *\n\t * @param observer - Observer to create a registration for\n\t * @param options  - Options for the registration\n\t */\n\tpublic register(observer: MutationObserver, options: MutationObserverInit) {\n\t\t// (continuing from MutationObserver#observe)\n\t\t// 7. For each registered registered of target’s registered observer list, if registered's\n\t\t// observer is this:\n\t\tconst registeredObservers = this._registeredObservers;\n\t\tlet hasRegisteredObserverForObserver = false;\n\t\tregisteredObservers.forEach((registered) => {\n\t\t\tif (registered.observer !== observer) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\thasRegisteredObserverForObserver = true;\n\n\t\t\t// 7.1. For each node of this's node list, remove all transient registered\n\t\t\t// observers whose source is registered from node's registered observer list.\n\t\t\tremoveTransientRegisteredObserversForSource(registered);\n\n\t\t\t// 7.2. Set registered’s options to options.\n\t\t\tregistered.options = options;\n\t\t});\n\n\t\t// 8. Otherwise:\n\t\tif (!hasRegisteredObserverForObserver) {\n\t\t\t// 8.1. Append a new registered observer whose observer is this and\n\t\t\t// options is options to target's registered observer list.\n\t\t\tthis._registeredObservers.push(new RegisteredObserver(observer, this._node, options));\n\t\t\t// 8.2. Append target to this's node list.\n\t\t\tobserver._nodes.push(this._node);\n\t\t}\n\t}\n\n\t/**\n\t * Removes the given transient registered observer.\n\t *\n\t * Transient registered observers never have a corresponding entry in the observer's list of\n\t * nodes. They are guaranteed to be present in the array, as MutationObserver#_transients and\n\t * RegisteredObservers#_registeredObservers are kept in sync.\n\t *\n\t * @param transientRegisteredObserver - The registered observer to remove\n\t */\n\tpublic removeTransientRegisteredObserver(\n\t\ttransientRegisteredObserver: RegisteredObserver\n\t): void {\n\t\tthis._registeredObservers.splice(\n\t\t\tthis._registeredObservers.indexOf(transientRegisteredObserver),\n\t\t\t1\n\t\t);\n\t}\n\n\t/**\n\t * Remove any registered observer on the associated node for which observer is the observer.\n\t *\n\t * As this only occurs for all nodes at once, it is the caller's responsibility to remove the\n\t * associated node from the observer's list of nodes.\n\t *\n\t * @param observer - Observer for which to remove the registration\n\t */\n\tpublic removeForObserver(observer: MutationObserver): void {\n\t\t// Filter the array in-place\n\t\tlet write = 0;\n\t\tfor (let read = 0, l = this._registeredObservers.length; read < l; ++read) {\n\t\t\tconst registered = this._registeredObservers[read];\n\t\t\tif (registered.observer === observer) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (read !== write) {\n\t\t\t\tthis._registeredObservers[write] = registered;\n\t\t\t}\n\t\t\t++write;\n\t\t}\n\t\tthis._registeredObservers.length = write;\n\t}\n\n\t/**\n\t * Determines interested observers for the given record.\n\t *\n\t * @param type                - The type of mutation record to queue\n\t * @param target              - The target node\n\t * @param data                - The data for the mutation record\n\t * @param interestedObservers - Array of mutation observer objects to append to\n\t * @param pairedStrings       - Paired strings for the mutation observer objects\n\t */\n\tpublic collectInterestedObservers(\n\t\ttype: string,\n\t\ttarget: Node,\n\t\tdata: MutationRecordInit,\n\t\tinterestedObservers: MutationObserver[],\n\t\tpairedStrings: (string | null | undefined)[]\n\t) {\n\t\t// (continuing from queueMutationRecord)\n\t\t// 3. ...and then for each registered of node's registered observer list:\n\t\tthis._registeredObservers.forEach((registeredObserver) => {\n\t\t\tregisteredObserver.collectInterestedObservers(\n\t\t\t\ttype,\n\t\t\t\ttarget,\n\t\t\t\tdata,\n\t\t\t\tinterestedObservers,\n\t\t\t\tpairedStrings\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * Append transient registered observers for any registered observers whose options' subtree is\n\t * true.\n\t *\n\t * @param node - Node to append the transient registered observers to\n\t */\n\tpublic appendTransientRegisteredObservers(node: Node): void {\n\t\tthis._registeredObservers.forEach((registeredObserver) => {\n\t\t\tif (registeredObserver.options.subtree) {\n\t\t\t\tnode._registeredObservers.registerTransient(registeredObserver);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Appends a transient registered observer for the given registered observer.\n\t *\n\t * @param source - The source registered observer\n\t */\n\tpublic registerTransient(source: RegisteredObserver): void {\n\t\tthis._registeredObservers.push(\n\t\t\tnew RegisteredObserver(source.observer, this._node, source.options, source)\n\t\t);\n\t\t// Note that node is not added to the transient observer's observer's list of nodes.\n\t}\n}\n\n/**\n * Removes all transient registered observers whose observer is observer.\n *\n * @param observer - The mutation observer object to remove transient registered observers for\n */\nexport function removeTransientRegisteredObserversForObserver(observer: MutationObserver): void {\n\tobserver._transients.forEach((transientRegisteredObserver) => {\n\t\ttransientRegisteredObserver.node._registeredObservers.removeTransientRegisteredObserver(\n\t\t\ttransientRegisteredObserver\n\t\t);\n\t});\n\tobserver._transients.length = 0;\n}\n\n/**\n * Removes all transient registered observer whose source is source.\n *\n * @param source - The registered observer to remove transient registered observers for\n */\nexport function removeTransientRegisteredObserversForSource(source: RegisteredObserver): void {\n\tfor (let i = source.observer._transients.length - 1; i >= 0; --i) {\n\t\tconst transientRegisteredObserver = source.observer._transients[i];\n\t\tif (transientRegisteredObserver.source !== source) {\n\t\t\treturn;\n\t\t}\n\n\t\ttransientRegisteredObserver.node._registeredObservers.removeTransientRegisteredObserver(\n\t\t\ttransientRegisteredObserver\n\t\t);\n\t\tsource.observer._transients.splice(i, 1);\n\t}\n}\n","import { default as MutationObserver } from './MutationObserver';\nimport MutationRecord from './MutationRecord';\nimport { removeTransientRegisteredObserversForObserver } from './RegisteredObservers';\n\ntype AnyCallback = (...args: any[]) => void;\ndeclare const queueMicrotask: undefined | ((callback: AnyCallback) => void);\n\n/* istanbul ignore next */\nfunction queueMicrotaskWithAppropriateApi(\n\tcallback: AnyCallback,\n\tthisArg: NotifySet,\n\t...args: any[]\n): void {\n\tif (typeof queueMicrotask === 'function') {\n\t\tqueueMicrotask(() => callback.apply(thisArg, args));\n\t\treturn;\n\t}\n\n\t// Fall back to Promise.then callbacks - these run as microtasks, but handle errors differently\n\tPromise.resolve().then(() => callback.apply(thisArg, args));\n}\n\n/**\n * Tracks MutationObserver instances which have a non-empty record queue and schedules their\n * callbacks to be called.\n */\nexport default class NotifySet {\n\tprivate _notifySet: Set<MutationObserver> = new Set();\n\tprivate _mutationObserverMicrotaskQueued: boolean = false;\n\n\t/**\n\t * Appends a given MutationRecord to the recordQueue of the given MutationObserver and schedules\n\t * it for reporting.\n\t *\n\t * @param observer - The observer for which to enqueue the record\n\t * @param record   - The record to enqueue\n\t */\n\tappendRecord(observer: MutationObserver, record: MutationRecord) {\n\t\tobserver._recordQueue.push(record);\n\t\tthis._notifySet.add(observer);\n\t}\n\n\t/**\n\t * To queue a mutation observer microtask, run these steps:\n\t */\n\tpublic queueMutationObserverMicrotask() {\n\t\t// 1. If the surrounding agent's mutation observer microtask queued is true, then return.\n\t\tif (this._mutationObserverMicrotaskQueued) {\n\t\t\treturn;\n\t\t}\n\n\t\t// 2. Set the surrounding agent's mutation observer microtask queued to true.\n\t\tthis._mutationObserverMicrotaskQueued = true;\n\n\t\t// 3. Queue a microtask to notify mutation observers.\n\t\tqueueMicrotaskWithAppropriateApi(() => {\n\t\t\tthis._notifyMutationObservers();\n\t\t}, this);\n\t}\n\n\t/**\n\t * To notify mutation observers, run these steps:\n\t */\n\tprivate _notifyMutationObservers() {\n\t\t// 1. Set the surrounding agent's mutation observer microtask queued to false.\n\t\tthis._mutationObserverMicrotaskQueued = false;\n\n\t\t// 2. Let notifySet be a clone of the surrounding agent's mutation observers\n\t\tconst notifySet = Array.from(this._notifySet);\n\t\t// Clear the notify set - for efficiency this set only tracks observers that have a\n\t\t// non-empty queue\n\t\tthis._notifySet.clear();\n\n\t\t// 3. Let signalSet be a clone of the surrounding agent's signal slots.\n\t\t// 4. Empty the surrounding agent's signal slots.\n\t\t// (shadow dom not implemented)\n\n\t\t// 5. For each mo of notifySet:\n\t\t// [HTML]\n\t\tnotifySet.forEach((mo) => {\n\t\t\tqueueMicrotaskWithAppropriateApi(\n\t\t\t\t(mo: MutationObserver) => {\n\t\t\t\t\t// 5.1. Let records be a clone of mo’s record queue.\n\t\t\t\t\t// 5.2. Empty mo’s record queue.\n\t\t\t\t\tconst records = mo.takeRecords();\n\n\t\t\t\t\t// 5.3. For each node of mo's node list, remove all transient registered\n\t\t\t\t\t// observers whose observer is mo from node's registered observer list.\n\t\t\t\t\tremoveTransientRegisteredObserversForObserver(mo);\n\n\t\t\t\t\t// 5.4. If records is not empty, then invoke mo’s callback with « records, mo »,\n\t\t\t\t\t// and mo. If this throws an exception, catch it, and report the exception.\n\t\t\t\t\t// (A try/catch is not necessary here, as this microtask does nothing else and\n\t\t\t\t\t// letting the exception through will likely cause the environment to report it)\n\t\t\t\t\tif (records.length > 0) {\n\t\t\t\t\t\tmo._callback(records, mo);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tthis,\n\t\t\t\tmo\n\t\t\t);\n\t\t});\n\n\t\t// 6. For each slot of signalSet, fire an event named slotchange, with its bubbles attribute\n\t\t// set to true, at slot.\n\t\t// (shadow dom not implemented)\n\t}\n}\n","// TODO: remove when interface is included in dom.d.ts typings\nexport interface WeakRef<T> {\n\tderef(): T | undefined;\n}\ninterface WeakRefConstructor<T> {\n\tnew (target: T): WeakRef<T>;\n}\ndeclare var WeakRef: WeakRefConstructor<any>;\n\nclass FakeWeakRef<T> implements WeakRef<T> {\n\tprivate _target: T;\n\n\tconstructor(target: T) {\n\t\tthis._target = target;\n\t}\n\n\tpublic deref(): T {\n\t\treturn this._target;\n\t}\n}\n\nexport function createWeakRef<T>(target: T): WeakRef<T> {\n\tif (typeof WeakRef === 'function') {\n\t\treturn new WeakRef(target);\n\t}\n\n\treturn new FakeWeakRef(target);\n}\n","import Attr from '../Attr';\nimport CDATASection from '../CDATASection';\nimport Comment from '../Comment';\nimport Document from '../Document';\nimport DocumentFragment from '../DocumentFragment';\nimport DocumentType from '../DocumentType';\nimport DOMImplementation from '../DOMImplementation';\nimport Element from '../Element';\nimport Node from '../Node';\nimport ProcessingInstruction from '../ProcessingInstruction';\nimport Range from '../Range';\nimport Text from '../Text';\nimport XMLDocument from '../XMLDocument';\n\nimport NotifySet from '../mutation-observer/NotifyList';\n\nimport { createWeakRef, WeakRef } from './WeakRef';\n\nexport type AttrConstructor = new (\n\tnamespace: string | null,\n\tprefix: string | null,\n\tlocalName: string,\n\tvalue: string,\n\telement: Element | null\n) => Attr;\nexport type CDATASectionConstructor = new (data: string) => CDATASection;\nexport type CommentConstructor = new (data: string) => Comment;\nexport type DocumentConstructor = new () => Document;\nexport type DocumentFragmentConstructor = new () => DocumentFragment;\nexport type DocumentTypeConstructor = new (\n\tname: string,\n\tpublicId?: string,\n\tsystemId?: string\n) => DocumentType;\nexport type DOMImplementationConstructor = new (document: Document) => DOMImplementation;\nexport type ElementConstructor = new (\n\tnamespace: string | null,\n\tprefix: string | null,\n\tlocalName: string\n) => Element;\nexport type ProcessingInstructionConstructor = new (\n\ttarget: string,\n\tdata: string\n) => ProcessingInstruction;\nexport type RangeConstructor = new () => Range;\nexport type TextConstructor = new (data: string) => Text;\nexport type XMLDocumentConstructor = new () => XMLDocument;\n\nexport interface Context {\n\tdocument: Document;\n\n\t_notifySet: NotifySet;\n\n\tAttr: AttrConstructor;\n\tCDATASection: CDATASectionConstructor;\n\tComment: CommentConstructor;\n\tDocument: DocumentConstructor;\n\tDocumentFragment: DocumentFragmentConstructor;\n\tDocumentType: DocumentTypeConstructor;\n\tDOMImplementation: DOMImplementationConstructor;\n\tElement: ElementConstructor;\n\tProcessingInstruction: ProcessingInstructionConstructor;\n\tRange: RangeConstructor;\n\tText: TextConstructor;\n\tXMLDocument: XMLDocumentConstructor;\n\n\tforEachRange(cb: (range: Range) => void): void;\n\taddRange(range: Range): void;\n\tremoveRange(range: Range): void;\n}\n\n/**\n * The DefaultContext is comparable to the global object in that it tracks its associated document.\n * It also serves as a way to inject the constructors for the constructable types, avoiding cyclic\n * dependencies.\n */\nexport class DefaultContext implements Context {\n\tpublic document!: Document;\n\n\t/**\n\t * The NotifyList instance is shared between all MutationObserver objects. It holds references\n\t * to all MutationObserver instances that have collected records, and is responsible for\n\t * invoking their callbacks when control returns to the event loop.\n\t */\n\tpublic _notifySet: NotifySet = new NotifySet();\n\n\tpublic Attr!: AttrConstructor;\n\tpublic CDATASection!: CDATASectionConstructor;\n\tpublic Comment!: CommentConstructor;\n\tpublic Document!: DocumentConstructor;\n\tpublic DocumentFragment!: DocumentFragmentConstructor;\n\tpublic DocumentType!: DocumentTypeConstructor;\n\tpublic DOMImplementation!: DOMImplementationConstructor;\n\tpublic Element!: ElementConstructor;\n\tpublic ProcessingInstruction!: ProcessingInstructionConstructor;\n\tpublic Range!: RangeConstructor;\n\tpublic Text!: TextConstructor;\n\tpublic XMLDocument!: XMLDocumentConstructor;\n\n\tprivate _ranges: WeakRef<Range>[] = [];\n\tprivate _weakRangeSet: WeakSet<Range> = new WeakSet();\n\n\tpublic forEachRange(cb: (range: Range) => void): void {\n\t\tlet numRanges = this._ranges.length;\n\t\tfor (let i = numRanges - 1; i >= 0; --i) {\n\t\t\tconst weakref = this._ranges[i];\n\t\t\tconst r = weakref.deref();\n\t\t\t// Safari / webkit has a bug where deref can return null instead of undefined\n\t\t\tconst isLost = r === undefined || r === null;\n\t\t\tconst isManuallyRemoved = !isLost && !this._weakRangeSet.has(r);\n\t\t\tif (isLost || isManuallyRemoved) {\n\t\t\t\t// Weak ref lost, remove\n\t\t\t\tthis._ranges[i] = this._ranges[numRanges - 1];\n\t\t\t\tthis._ranges.pop();\n\t\t\t\tnumRanges -= 1;\n\t\t\t} else {\n\t\t\t\tcb(r);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic addRange(range: Range): void {\n\t\tconst weakref = createWeakRef(range);\n\t\tthis._ranges.push(weakref);\n\t\tthis._weakRangeSet.add(range);\n\t}\n\n\tpublic removeRange(range: Range): void {\n\t\tthis._weakRangeSet.delete(range);\n\t}\n}\n\n// TODO: make it possible to create multiple contexts by binding constructors to each instance\nexport const defaultContext = new DefaultContext();\n\nexport function getContext(_instance: Node | Range): Context {\n\treturn defaultContext;\n}\n","import Attr from '../Attr';\nimport CharacterData from '../CharacterData';\nimport Document from '../Document';\nimport DocumentFragment from '../DocumentFragment';\nimport DocumentType from '../DocumentType';\nimport Element from '../Element';\nimport Node from '../Node';\nimport Text from '../Text';\n\nexport const enum NodeType {\n\tELEMENT_NODE = 1,\n\tATTRIBUTE_NODE = 2,\n\tTEXT_NODE = 3,\n\tCDATA_SECTION_NODE = 4,\n\tENTITY_REFERENCE_NODE = 5, // legacy\n\tENTITY_NODE = 6, // legacy\n\tPROCESSING_INSTRUCTION_NODE = 7,\n\tCOMMENT_NODE = 8,\n\tDOCUMENT_NODE = 9,\n\tDOCUMENT_TYPE_NODE = 10,\n\tDOCUMENT_FRAGMENT_NODE = 11,\n\tNOTATION_NODE = 12, // legacy\n}\n\n/**\n * Checks whether the given node's nodeType is one of the specified values\n *\n * @param node  - The node to test\n * @param types - Possible nodeTypes for node\n *\n * @returns Whether node.nodeType is one of the specified values\n */\nexport function isNodeOfType(node: Node, ...types: NodeType[]): boolean {\n\treturn types.some((t) => node.nodeType === t);\n}\n\n/**\n * Checks whether node implements Attr\n *\n * @param node - The node to test\n *\n * @returns Whether node is an Attr\n */\nexport function isAttrNode(node: Node): node is Attr {\n\treturn node.nodeType === NodeType.ATTRIBUTE_NODE;\n}\n\n/**\n * Checks whether node implements CharacterData\n *\n * @param node - The node to test\n *\n * @returns Whether node is a CharacterData node\n */\nexport function isCharacterDataNode(node: Node): node is CharacterData {\n\treturn (\n\t\tnode.nodeType === NodeType.TEXT_NODE ||\n\t\tnode.nodeType === NodeType.CDATA_SECTION_NODE ||\n\t\tnode.nodeType === NodeType.COMMENT_NODE ||\n\t\tnode.nodeType === NodeType.PROCESSING_INSTRUCTION_NODE\n\t);\n}\n\n/**\n * Checks whether node implements Text\n *\n * @param node - The node to test\n *\n * @returns Whether node is a Text (or CDataSection) node\n */\nexport function isTextNode(node: Node): node is Text {\n\treturn node.nodeType === NodeType.TEXT_NODE || node.nodeType === NodeType.CDATA_SECTION_NODE;\n}\n\n/**\n * Checks whether node implements Element\n *\n * @param node - The node to test\n *\n * @returns Whether node is an Element node\n */\nexport function isElement(node: Node): node is Element {\n\treturn node.nodeType === NodeType.ELEMENT_NODE;\n}\n\n/**\n * Checks whether node implements Document\n *\n * @param node - The node to test\n *\n * @returns Whether node is a Document node\n */\nexport function isDocument(node: Node): node is Document {\n\treturn node.nodeType === NodeType.DOCUMENT_NODE;\n}\n\n/**\n * Checks whether node implements DocumentFragment\n *\n * @param node - The node to test\n *\n * @returns Whether node is a DocumentFragment node\n */\nexport function isDocumentFragment(node: Node): node is DocumentFragment {\n\treturn node.nodeType === NodeType.DOCUMENT_FRAGMENT_NODE;\n}\n\n/**\n * Checks whether node implements DocumentType\n *\n * @param node - The node to test\n *\n * @returns Whether node is a DocumentType node\n */\nexport function isDocumentType(node: Node): node is DocumentType {\n\treturn node.nodeType === NodeType.DOCUMENT_TYPE_NODE;\n}\n","import CharacterData from '../CharacterData';\nimport Document from '../Document';\nimport Element from '../Element';\nimport Node from '../Node';\nimport { NodeType, isNodeOfType } from './NodeType';\n\n/**\n * 3.2. Node Tree: to determine the length of a node, switch on node:\n *\n * @param node - The node to determine the length of\n *\n * @returns The length of the node\n */\nexport function determineLengthOfNode(node: Node): number {\n\tswitch (node.nodeType) {\n\t\t// DocumentType: Zero.\n\t\t// (not necessary, as doctypes never have children)\n\n\t\t// Text, ProcessingInstruction, Comment: The number of code units in its data.\n\t\tcase NodeType.TEXT_NODE:\n\t\tcase NodeType.PROCESSING_INSTRUCTION_NODE:\n\t\tcase NodeType.COMMENT_NODE:\n\t\t\treturn (node as CharacterData).data.length;\n\n\t\t// Any other node: Its number of children.\n\t\tdefault:\n\t\t\treturn node.childNodes.length;\n\t}\n}\n\n/**\n * Get inclusive ancestors of the given node.\n *\n * @param node - Node to get inclusive ancestors of\n *\n * @returns Node's inclusive ancestors, in tree order\n */\nexport function getInclusiveAncestors(node: Node): Node[] {\n\tlet ancestor: Node | null = node;\n\tlet ancestors: Node[] = [];\n\twhile (ancestor) {\n\t\tancestors.unshift(ancestor);\n\t\tancestor = ancestor.parentNode;\n\t}\n\n\treturn ancestors;\n}\n\n/**\n * Get the node document associated with the given node.\n *\n * @param node - The node to get the node document for\n *\n * @returns The node document for node\n */\nexport function getNodeDocument(node: Node): Document {\n\tif (isNodeOfType(node, NodeType.DOCUMENT_NODE)) {\n\t\treturn node as Document;\n\t}\n\n\treturn node.ownerDocument!;\n}\n\n/**\n * Determine the index of the given node among its siblings.\n *\n * @param node - Node to determine the index of\n *\n * @returns The index of node in its parent's children\n */\nexport function getNodeIndex(node: Node): number {\n\treturn node.parentNode!.childNodes.indexOf(node);\n}\n\n/**\n * The root of an object is itself, if its parent is null, or else it is the root of its parent.\n *\n * @param node - Node to get the root of\n *\n * @returns The root of node\n */\nexport function getRootOfNode(node: Node): Node {\n\twhile (node.parentNode) {\n\t\tnode = node.parentNode;\n\t}\n\n\treturn node;\n}\n\n/**\n * Invokes callback on each inclusive descendant of node, in tree order\n *\n * @param node     - Root of the subtree to process\n * @param callback - Callback to invoke for each descendant, should not modify node's position in\n *                   the tree\n */\nexport function forEachInclusiveDescendant(node: Node, callback: (node: Node) => void): void {\n\tcallback(node);\n\tfor (let child = node.firstChild; child; child = child.nextSibling) {\n\t\tforEachInclusiveDescendant(child, callback);\n\t}\n}\n\n/**\n * The list of elements with qualified name qualifiedName for a node root is the HTMLCollection\n * returned by the following algorithm:\n *\n * (this implementation returns a non-live array instead)\n *\n * @param qualifiedName - The qualifiedName of elements to return, or '*' to return all elements\n * @param root          - The root of the subtree from which to collect matching descendants\n */\nexport function getListOfElementsWithQualifiedName(qualifiedName: string, root: Node): Element[] {\n\tconst elements: Element[] = [];\n\tforEachInclusiveDescendant(root, (node) => {\n\t\t// Only matches descendant elements\n\t\tif (node === root || node.nodeType !== NodeType.ELEMENT_NODE) {\n\t\t\treturn;\n\t\t}\n\t\tconst element = node as Element;\n\n\t\tif (\n\t\t\t// 1. If qualifiedName is \"*\" (U+002A), return a HTMLCollection rooted at root, whose\n\t\t\t// filter matches only descendant elements.\n\t\t\tqualifiedName === '\\u002a' ||\n\t\t\t// 2. Otherwise, if root’s node document is an HTML document, return a HTMLCollection\n\t\t\t// rooted at root, whose filter matches the following descendant elements:\n\t\t\t//    - Whose namespace is the HTML namespace and whose qualified name is qualifiedName,\n\t\t\t//      in ASCII lowercase.\n\t\t\t//    - Whose namespace is not the HTML namespace and whose qualified name is\n\t\t\t//      qualifiedName.\n\t\t\t// (html documents not implemented)\n\n\t\t\t// 3. Otherwise, return a HTMLCollection rooted at root, whose filter matches descendant\n\t\t\t// elements whose qualified name is qualifiedName.\n\t\t\telement.nodeName === qualifiedName\n\t\t) {\n\t\t\telements.push(element);\n\t\t}\n\t});\n\n\treturn elements;\n}\n\n/**\n * The list of elements with namespace namespace and local name localName for a node root is the\n * HTMLCollection returned by the following algorithm:\n *\n * (this implementation returns a non-live array instead)\n *\n * @param namespace - The namespace of the elements to return, or '*' to match any namespace\n * @param localName - The local name of the elements to return, or '*' to match any local name\n * @param root      - The root of the subtree from which to collect matching descendants\n */\nexport function getListOfElementsWithNamespaceAndLocalName(\n\tnamespace: string | null,\n\tlocalName: string,\n\troot: Node\n): Element[] {\n\t// 1. If namespace is the empty string, set it to null.\n\tif (namespace === '') {\n\t\tnamespace = null;\n\t}\n\n\tconst elements: Element[] = [];\n\tforEachInclusiveDescendant(root, (node) => {\n\t\t// Only matches descendant elements\n\t\tif (node === root || node.nodeType !== NodeType.ELEMENT_NODE) {\n\t\t\treturn;\n\t\t}\n\t\tconst element = node as Element;\n\n\t\tif (\n\t\t\t// 2. If both namespace and localName are \"*\" (U+002A), return a HTMLCollection\n\t\t\t//    rooted at root, whose filter matches descendant elements.\n\t\t\t// 3. Otherwise, if namespace is \"*\" (U+002A), return a HTMLCollection rooted at\n\t\t\t//    root, whose filter matches descendant elements whose local name is localName.\n\t\t\t// 4. Otherwise, if localName is \"*\" (U+002A), return a HTMLCollection rooted at\n\t\t\t//    root, whose filter matches descendant elements whose namespace is namespace.\n\t\t\t// 5. Otherwise, return a HTMLCollection rooted at root, whose filter matches\n\t\t\t//    descendant elements whose namespace is namespace and local name is localName.\n\t\t\t(namespace === '\\u002a' || element.namespaceURI === namespace) &&\n\t\t\t(localName === '\\u002a' || element.localName === localName)\n\t\t) {\n\t\t\telements.push(element);\n\t\t}\n\t});\n\n\treturn elements;\n}\n","import Document from '../Document';\nimport Node from '../Node';\n\nimport { getNodeDocument } from './treeHelpers';\n\n// 3.4. Interface Node\n\n/**\n * To clone a node, with an optional document and clone children flag, run these steps:\n *\n * @param node          - The node to clone\n * @param cloneChildren - Whether to also clone node's descendants\n * @param document      - The document used to create the copy\n */\nexport default function cloneNode<TNode extends Node>(\n\tnode: TNode,\n\tcloneChildren: boolean,\n\tdocument?: Document\n): TNode {\n\t// 1. If document is not given, let document be node’s node document.\n\tif (!document) {\n\t\tdocument = getNodeDocument(node);\n\t}\n\n\t// 2. If node is an element, then:\n\t// 2.1. Let copy be the result of creating an element, given document, node’s local name, node’s\n\t// namespace, node’s namespace prefix, and node’s is value, with the synchronous custom elements\n\t// flag unset.\n\t// 2.2. For each attribute in node’s attribute list:\n\t// 2.2.1. Let copyAttribute be a clone of attribute.\n\t// 2.2.2. Append copyAttribute to copy.\n\t// 3. Otherwise, let copy be a node that implements the same interfaces as node, and fulfills\n\t// these additional requirements, switching on node:\n\t// Document: Set copy’s encoding, content type, URL, origin, type, and mode, to those of node.\n\t// DocumentType: Set copy’s name, public ID, and system ID, to those of node.\n\t// Attr: Set copy’s namespace, namespace prefix, local name, and value, to those of node.\n\t// Text, Comment: Set copy’s data, to that of node.\n\t// ProcessingInstruction: Set copy’s target and data to those of node.\n\t// Any other node: —\n\t// 4. Set copy’s node document and document to copy, if copy is a document, and set copy’s node\n\t// document to document otherwise.\n\t// (all handled by _copy method)\n\tlet copy = node._copy(document) as TNode;\n\n\t// 5. Run any cloning steps defined for node in other applicable specifications and pass copy,\n\t// node, document and the clone children flag if set, as parameters.\n\t// (cloning steps not implemented)\n\n\t// 6. If the clone children flag is set, clone all the children of node and append them to copy,\n\t// with document as specified and the clone children flag being set.\n\tif (cloneChildren) {\n\t\tfor (let child = node.firstChild; child; child = child.nextSibling) {\n\t\t\tcopy.appendChild(cloneNode(child, true, document));\n\t\t}\n\t}\n\n\t// 7. Return copy.\n\treturn copy;\n}\n","export function expectArity(args: IArguments, minArity: number): void {\n\t// According to WebIDL overload resolution semantics, only a lower bound applies to the number\n\t// of arguments provided\n\tif (args.length < minArity) {\n\t\tthrow new TypeError(`Function should be called with at least ${minArity} arguments`);\n\t}\n}\n\nexport function expectObject<T>(value: T, Constructor: Function): void {\n\tif (!(value instanceof Constructor)) {\n\t\tthrow new TypeError(`Value should be an instance of ${Constructor.name}`);\n\t}\n}\n\nconst codeByName: Record<string, number> = {\n\tIndexSizeError: 1,\n\tHierarchyRequestError: 3,\n\tWrongDocumentError: 4,\n\tInvalidCharacterError: 5,\n\tNotFoundError: 8,\n\tNotSupportedError: 9,\n\tInUseAttributeError: 10,\n\tInvalidStateError: 11,\n\tNamespaceError: 14,\n\tInvalidNodeTypeError: 24,\n};\n\n/**\n * Exception type used for DOM errors\n *\n * @public\n */\nexport class DOMException extends Error {\n\tpublic readonly name: string;\n\tpublic readonly message: string;\n\tpublic readonly code: number;\n\tpublic readonly stack: string | undefined;\n\n\tconstructor(message: string = '', name: string = 'Error') {\n\t\tsuper(message);\n\n\t\tthis.message = message;\n\t\tthis.name = name;\n\t\tthis.code = codeByName[name] || 0;\n\t\tthis.stack = new Error(message).stack;\n\t}\n}\n\nfunction createDOMException(name: string, message: string): Error {\n\treturn new DOMException(`${name}: ${message}`, name);\n}\n\nexport function throwHierarchyRequestError(message: string): never {\n\tthrow createDOMException('HierarchyRequestError', message);\n}\n\nexport function throwIndexSizeError(message: string): never {\n\tthrow createDOMException('IndexSizeError', message);\n}\n\nexport function throwInUseAttributeError(message: string): never {\n\tthrow createDOMException('InUseAttributeError', message);\n}\n\nexport function throwInvalidCharacterError(message: string): never {\n\tthrow createDOMException('InvalidCharacterError', message);\n}\n\nexport function throwInvalidNodeTypeError(message: string): never {\n\tthrow createDOMException('InvalidNodeTypeError', message);\n}\n\nexport function throwInvalidStateError(message: string): never {\n\tthrow createDOMException('InvalidStateError', message);\n}\n\nexport function throwNamespaceError(message: string): never {\n\tthrow createDOMException('NamespaceError', message);\n}\n\nexport function throwNotFoundError(message: string): never {\n\tthrow createDOMException('NotFoundError', message);\n}\n\nexport function throwNotSupportedError(message: string): never {\n\tthrow createDOMException('NotSupportedError', message);\n}\n\nexport function throwWrongDocumentError(message: string): never {\n\tthrow createDOMException('WrongDocumentError', message);\n}\n","import Node from '../Node';\n\nexport interface MutationRecordInit {\n\tname?: string;\n\tnamespace?: string | null;\n\toldValue?: string | null;\n\taddedNodes?: Node[];\n\tremovedNodes?: Node[];\n\tpreviousSibling?: Node | null;\n\tnextSibling?: Node | null;\n}\n\n/**\n * 3.3.3. Interface MutationRecord\n *\n * A helper class which describes a specific mutation as it is observed by a MutationObserver.\n *\n * @public\n */\nexport default class MutationRecord {\n\t/**\n\t * Returns \"attributes\" if it was an attribute mutation. \"characterData\" if it was a mutation to\n\t * a CharacterData node. And \"childList\" if it was a mutation to the tree of nodes.\n\t */\n\tpublic type: string;\n\n\t/**\n\t * Returns the node the mutation affected, depending on the type. For \"attributes\", it is the\n\t * element whose attribute changed. For \"characterData\", it is the CharacterData node. For\n\t * \"childList\", it is the node whose children changed.\n\t */\n\tpublic target: Node;\n\n\t/**\n\t * Children of target added in this mutation.\n\t *\n\t * (non-standard) According to the spec this should be a NodeList. This implementation uses an\n\t * array.\n\t */\n\tpublic addedNodes: Node[] = [];\n\n\t/**\n\t * Children of target removed in this mutation.\n\t *\n\t * (non-standard) According to the spec this should be a NodeList. This implementation uses an\n\t * array.\n\t */\n\tpublic removedNodes: Node[] = [];\n\n\t/**\n\t * The previous sibling of the added or removed nodes, or null otherwise.\n\t */\n\tpublic previousSibling: Node | null = null;\n\n\t/**\n\t * The next sibling Node of the added or removed nodes, or null otherwise.\n\t */\n\tpublic nextSibling: Node | null = null;\n\n\t/**\n\t * The local name of the changed attribute, or null otherwise.\n\t */\n\tpublic attributeName: string | null = null;\n\n\t/**\n\t * The namespace of the changed attribute, or null otherwise.\n\t */\n\tpublic attributeNamespace: string | null = null;\n\n\t/**\n\t * The return value depends on type. For \"attributes\", it is the value of the changed attribute\n\t * before the change. For \"characterData\", it is the data of the changed node before the change.\n\t * For \"childList\", it is null.\n\t */\n\tpublic oldValue: string | null = null;\n\n\t/**\n\t * (non-standard) Constructs a MutationRecord\n\t *\n\t * @param type   - The value for the type property\n\t * @param target - The value for the target property\n\t */\n\tconstructor(type: string, target: Node) {\n\t\tthis.type = type;\n\t\tthis.target = target;\n\t}\n}\n","import { getContext } from '../context/Context';\nimport MutationObserver from './MutationObserver';\nimport { MutationRecordInit, default as MutationRecord } from './MutationRecord';\nimport Node from '../Node';\n\n/**\n * 3.3.2. Queuing a mutation record\n *\n * To queue a mutation record of type for target with name, namespace, oldValue, addedNodes,\n * removedNodes, previousSibling and nextSibling, run these steps:\n * namespace namespace, oldValue oldValue, addedNodes addedNodes, removedNodes removedNodes,\n *\n * To queue a tree mutation record for target with addedNodes, removedNodes, previousSibling, and\n * nextSibling, run these steps:\n *  - Assert: either addedNodes or removedNodes is not empty.\n *  - Queue a mutation record of \"childList\" for target with null, null, null, addedNodes,\n *    removedNodes, previousSibling, and nextSibling.\n *\n * @param type   - The type of mutation record to queue\n * @param target - The target node\n * @param data   - The data for the mutation record\n */\nexport default function queueMutationRecord(type: string, target: Node, data: MutationRecordInit) {\n\t// 1. Let interested observers be an empty map\n\tconst interestedObservers: MutationObserver[] = [];\n\tconst pairedStrings: (string | null | undefined)[] = [];\n\n\t// 2. Let nodes be the inclusive ancestors of target.\n\t// 3. For each node in nodes, ...:\n\tfor (let node: Node | null = target; node; node = node.parentNode) {\n\t\tnode._registeredObservers.collectInterestedObservers(\n\t\t\ttype,\n\t\t\ttarget,\n\t\t\tdata,\n\t\t\tinterestedObservers,\n\t\t\tpairedStrings\n\t\t);\n\t}\n\n\tconst context = getContext(target);\n\n\t// 4. For each observer → mappedOldValue of interestedObservers:\n\tinterestedObservers.forEach((observer, index) => {\n\t\tconst mappedOldValue = pairedStrings[index];\n\n\t\t// 4.1. Let record be a new MutationRecord object with its type set to type and target set\n\t\t// to target,\n\t\tconst record = new MutationRecord(type, target);\n\n\t\t// ...attributeName set to to name, attributeNamespace set to namespace...\n\t\tif (data.name !== undefined && data.namespace !== undefined) {\n\t\t\trecord.attributeName = data.name;\n\t\t\trecord.attributeNamespace = data.namespace;\n\t\t}\n\n\t\t// ...oldValue set to mappedOldValue...\n\t\tif (mappedOldValue !== undefined) {\n\t\t\trecord.oldValue = mappedOldValue;\n\t\t}\n\n\t\t// ...addedNodes set to addedNodes...\n\t\tif (data.addedNodes !== undefined) {\n\t\t\trecord.addedNodes = data.addedNodes;\n\t\t}\n\n\t\t// ...removedNodes set to removedNodes...\n\t\tif (data.removedNodes !== undefined) {\n\t\t\trecord.removedNodes = data.removedNodes;\n\t\t}\n\n\t\t// ...previousSibling set to previousSibling...\n\t\tif (data.previousSibling !== undefined) {\n\t\t\trecord.previousSibling = data.previousSibling;\n\t\t}\n\n\t\t// ...and nextSibling set to nextSibling.\n\t\tif (data.nextSibling !== undefined) {\n\t\t\trecord.nextSibling = data.nextSibling;\n\t\t}\n\n\t\t// 4.2. Enqueue record to observer’s record queue.\n\t\tcontext._notifySet.appendRecord(observer, record);\n\t});\n\n\t// 5. Queue a mutation observer microtask.\n\tcontext._notifySet.queueMutationObserverMicrotask();\n}\n","import CharacterData from './CharacterData';\nimport Document from './Document';\nimport DocumentFragment from './DocumentFragment';\nimport Element from './Element';\nimport Node from './Node';\n\nimport { NodeType, isNodeOfType, isElement } from './util/NodeType';\n\n/**\n * 3.2.4. Mixin NonElementParentNode\n */\nexport interface NonElementParentNode {}\n// Document implements NonElementParentNode;\n// DocumentFragment implements NonElementParentNode;\n\n/**\n * 3.2.6. Mixin ParentNode\n */\nexport interface ParentNode {\n\treadonly children: Element[];\n\n\tfirstElementChild: Element | null;\n\tlastElementChild: Element | null;\n\tchildElementCount: number;\n\n\tprepend(...nodes: (Node | string)[]): void;\n\tappend(...nodes: (Node | string)[]): void;\n\treplaceChildren(...nodes: (Node | string)[]): void;\n}\n// Document implements ParentNode;\n// DocumentFragment implements ParentNode;\n// Element implements ParentNode;\n\nexport function asParentNode(node: Node): ParentNode | null {\n\t// This is only called from treeMutations.js, where node can never be anything other than these\n\t/* istanbul ignore else */\n\tif (\n\t\tisNodeOfType(\n\t\t\tnode,\n\t\t\tNodeType.ELEMENT_NODE,\n\t\t\tNodeType.DOCUMENT_NODE,\n\t\t\tNodeType.DOCUMENT_FRAGMENT_NODE\n\t\t)\n\t) {\n\t\treturn node as Element | Document | DocumentFragment;\n\t}\n\n\t/* istanbul ignore next */\n\treturn null;\n}\n\n/**\n * Returns the element children of node.\n *\n * (Non-standard) According to the spec, the children getter should return a live HTMLCollection.\n * This implementation returns a static array instead.\n *\n * @param node - The node to get element children of\n *\n * @returns The\n */\nexport function getChildren(node: ParentNode): Element[] {\n\tconst elements: Element[] = [];\n\tfor (let child = node.firstElementChild; child; child = child.nextElementSibling) {\n\t\telements.push(child);\n\t}\n\treturn elements;\n}\n\n/**\n * 3.2.7. Mixin NonDocumentTypeChildNode\n */\nexport interface NonDocumentTypeChildNode {\n\treadonly previousElementSibling: Element | null;\n\treadonly nextElementSibling: Element | null;\n}\n// Element implements NonDocumentTypeChildNode;\n// CharacterData implements NonDocumentTypeChildNode;\n\nexport function getPreviousElementSibling(node: Node): Element | null {\n\tfor (let sibling = node.previousSibling; sibling; sibling = sibling.previousSibling) {\n\t\tif (isElement(sibling)) {\n\t\t\treturn sibling;\n\t\t}\n\t}\n\n\treturn null;\n}\n\nexport function getNextElementSibling(node: Node): Element | null {\n\tfor (let sibling = node.nextSibling; sibling; sibling = sibling.nextSibling) {\n\t\tif (isElement(sibling)) {\n\t\t\treturn sibling;\n\t\t}\n\t}\n\n\treturn null;\n}\n\n/**\n * 3.2.8. Mixin ChildNode\n */\nexport interface ChildNode {\n\tbefore(...nodes: (Node | string)[]): void;\n\tafter(...nodes: (Node | string)[]): void;\n\treplaceWith(...nodes: (Node | string)[]): void;\n\tremove(): void;\n}\n// DocumentType implements ChildNode;\n// Element implements ChildNode;\n// CharacterData implements ChildNode;\n","import { asParentNode } from '../mixins';\nimport CharacterData from '../CharacterData';\nimport Document from '../Document';\nimport DocumentFragment from '../DocumentFragment';\nimport DocumentType from '../DocumentType';\nimport Element from '../Element';\nimport Node from '../Node';\n\nimport { NodeType, isNodeOfType, isElement, isDocument, isDocumentType } from './NodeType';\n\n/**\n * Insert node into parent's children before referenceNode.\n *\n * Updates the pointers that model the tree, as well as precomputing derived properties.\n *\n * @param node           - Node to insert\n * @param parent         - Parent to insert under\n * @param referenceChild - Child to insert before\n */\nexport function insertIntoChildren(node: Node, parent: Node, referenceChild: Node | null): void {\n\t// Node\n\tnode.parentNode = parent;\n\tconst previousSibling: Node | null =\n\t\treferenceChild === null ? parent.lastChild : referenceChild.previousSibling;\n\tconst nextSibling: Node | null = referenceChild === null ? null : referenceChild;\n\tnode.previousSibling = previousSibling;\n\tnode.nextSibling = nextSibling;\n\tif (previousSibling) {\n\t\tpreviousSibling.nextSibling = node;\n\t} else {\n\t\tparent.firstChild = node;\n\t}\n\tif (nextSibling) {\n\t\tnextSibling.previousSibling = node;\n\t\tparent.childNodes.splice(parent.childNodes.indexOf(nextSibling), 0, node);\n\t} else {\n\t\tparent.lastChild = node;\n\t\tparent.childNodes.push(node);\n\t}\n\n\t// ParentNode\n\tif (isElement(node)) {\n\t\t// Functions calling this will ensure parent is always a ParentNode\n\t\tconst parentNode = parent as Element | Document | DocumentFragment;\n\t\tlet previousElementSibling: Element | null = null;\n\t\tfor (let sibling = previousSibling; sibling; sibling = sibling.previousSibling) {\n\t\t\tif (isElement(sibling)) {\n\t\t\t\tpreviousElementSibling = sibling;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst siblingNonDocumentTypeChildNode = sibling as CharacterData | DocumentType;\n\t\t\tif (!isDocumentType(siblingNonDocumentTypeChildNode)) {\n\t\t\t\tpreviousElementSibling = siblingNonDocumentTypeChildNode.previousElementSibling;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tlet nextElementSibling: Element | null = null;\n\t\tfor (let sibling = nextSibling; sibling; sibling = sibling!.nextSibling) {\n\t\t\tif (isElement(sibling)) {\n\t\t\t\tnextElementSibling = sibling;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// An element can never be inserted before a doctype\n\t\t\tconst siblingNonDocumentTypeChildNode = sibling as CharacterData;\n\t\t\tnextElementSibling = siblingNonDocumentTypeChildNode.nextElementSibling;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!previousElementSibling) {\n\t\t\tparentNode.firstElementChild = node;\n\t\t}\n\t\tif (!nextElementSibling) {\n\t\t\tparentNode.lastElementChild = node;\n\t\t}\n\t\tparentNode.childElementCount += 1;\n\t}\n\n\t// Document\n\tif (isDocument(parent)) {\n\t\tif (isElement(node)) {\n\t\t\tparent.documentElement = node;\n\t\t} else if (isDocumentType(node)) {\n\t\t\tparent.doctype = node;\n\t\t}\n\t}\n}\n\n/**\n * Remove node from parent's children.\n *\n * Updates the pointers that model the tree, as well as precomputing derived properties.\n *\n * @param node   - Node to remove\n * @param parent - Parent to remove from\n */\nexport function removeFromChildren(node: Node, parent: Node) {\n\tconst previousSibling = node.previousSibling;\n\tconst nextSibling = node.nextSibling;\n\tconst isElement = isNodeOfType(node, NodeType.ELEMENT_NODE);\n\tconst previousElementSibling = isElement ? (node as Element).previousElementSibling : null;\n\tconst nextElementSibling = isElement ? (node as Element).nextElementSibling : null;\n\n\t// Node\n\tnode.parentNode = null;\n\tnode.previousSibling = null;\n\tnode.nextSibling = null;\n\tif (previousSibling) {\n\t\tpreviousSibling.nextSibling = nextSibling;\n\t} else {\n\t\tparent.firstChild = nextSibling;\n\t}\n\tif (nextSibling) {\n\t\tnextSibling.previousSibling = previousSibling;\n\t} else {\n\t\tparent.lastChild = previousSibling;\n\t}\n\tparent.childNodes.splice(parent.childNodes.indexOf(node), 1);\n\n\t// ParentNode\n\tif (isElement) {\n\t\tconst parentNode = asParentNode(parent);\n\t\t// Functions calling this will ensure parent is always a ParentNode\n\t\t/* istanbul ignore else */\n\t\tif (parentNode) {\n\t\t\tif (parentNode.firstElementChild === node) {\n\t\t\t\tparentNode.firstElementChild = nextElementSibling;\n\t\t\t}\n\t\t\tif (parentNode.lastElementChild === node) {\n\t\t\t\tparentNode.lastElementChild = previousElementSibling;\n\t\t\t}\n\t\t\tparentNode.childElementCount -= 1;\n\t\t}\n\t}\n\n\t// Document\n\tif (isNodeOfType(parent, NodeType.DOCUMENT_NODE)) {\n\t\tconst parentDocument = parent as Document;\n\t\tif (isNodeOfType(node, NodeType.ELEMENT_NODE)) {\n\t\t\tparentDocument.documentElement = null;\n\t\t} else if (isNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE)) {\n\t\t\tparentDocument.doctype = null;\n\t\t}\n\t}\n}\n","import { getContext } from '../context/Context';\nimport queueMutationRecord from '../mutation-observer/queueMutationRecord';\nimport { throwHierarchyRequestError, throwNotFoundError } from './errorHelpers';\nimport { NodeType, isNodeOfType, isTextNode, isDocumentFragment } from './NodeType';\nimport {\n\tgetNodeDocument,\n\tgetNodeIndex,\n\tforEachInclusiveDescendant,\n\tdetermineLengthOfNode,\n} from './treeHelpers';\nimport { insertIntoChildren, removeFromChildren } from './treeMutations';\nimport Document from '../Document';\nimport DocumentFragment from '../DocumentFragment';\nimport Element from '../Element';\nimport { ParentNode, ChildNode } from '../mixins';\nimport Node from '../Node';\nimport Range from '../Range';\nimport Text from '../Text';\n\n// 3.2.3. Mutation algorithms\n\n/**\n * To ensure pre-insertion validity of a node into a parent before a child, run these steps:\n */\nfunction ensurePreInsertionValidity(node: Node, parent: Node, child: Node | null): void {\n\t// 1. If parent is not a Document, DocumentFragment, or Element node, throw a\n\t// HierarchyRequestError.\n\tif (\n\t\t!isNodeOfType(\n\t\t\tparent,\n\t\t\tNodeType.DOCUMENT_NODE,\n\t\t\tNodeType.DOCUMENT_FRAGMENT_NODE,\n\t\t\tNodeType.ELEMENT_NODE\n\t\t)\n\t) {\n\t\tthrowHierarchyRequestError('parent must be a Document, DocumentFragment or Element node');\n\t}\n\n\t// 2. If node is a host-including inclusive ancestor of parent, throw a HierarchyRequestError.\n\tif (node.contains(parent)) {\n\t\tthrowHierarchyRequestError('node must not be an inclusive ancestor of parent');\n\t}\n\n\t// 3. If child is non-null and its parent is not parent, then throw a NotFoundError.\n\tif (child && child.parentNode !== parent) {\n\t\tthrowNotFoundError('child is not a child of parent');\n\t}\n\n\t// 4. If node is not a DocumentFragment, DocumentType, Element, Text, ProcessingInstruction, or\n\t// Comment node, throw a HierarchyRequestError.\n\tif (\n\t\t!isNodeOfType(\n\t\t\tnode,\n\t\t\tNodeType.DOCUMENT_FRAGMENT_NODE,\n\t\t\tNodeType.DOCUMENT_TYPE_NODE,\n\t\t\tNodeType.ELEMENT_NODE,\n\t\t\tNodeType.TEXT_NODE,\n\t\t\tNodeType.CDATA_SECTION_NODE,\n\t\t\tNodeType.PROCESSING_INSTRUCTION_NODE,\n\t\t\tNodeType.COMMENT_NODE\n\t\t)\n\t) {\n\t\tthrowHierarchyRequestError(\n\t\t\t'node must be a DocumentFragment, DocumentType, Element, Text, ProcessingInstruction ' +\n\t\t\t\t'or Comment node'\n\t\t);\n\t}\n\n\t// 5. If either node is a Text node and parent is a document, or node is a doctype and parent is\n\t// not a document, throw a HierarchyRequestError.\n\tif (isNodeOfType(node, NodeType.TEXT_NODE) && isNodeOfType(parent, NodeType.DOCUMENT_NODE)) {\n\t\tthrowHierarchyRequestError('can not insert a Text node under a Document');\n\t}\n\tif (\n\t\tisNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE) &&\n\t\t!isNodeOfType(parent, NodeType.DOCUMENT_NODE)\n\t) {\n\t\tthrowHierarchyRequestError('can only insert a DocumentType node under a Document');\n\t}\n\n\t// 6. If parent is a document, and any of the statements below, switched on node, are true,\n\t// throw a HierarchyRequestError.\n\tif (isNodeOfType(parent, NodeType.DOCUMENT_NODE)) {\n\t\tconst parentDocument = parent as Document;\n\t\tswitch (node.nodeType) {\n\t\t\t// DocumentFragment node\n\t\t\tcase NodeType.DOCUMENT_FRAGMENT_NODE:\n\t\t\t\t// If node has more than one element child or has a Text node child.\n\t\t\t\tconst fragment = node as DocumentFragment;\n\t\t\t\tif (fragment.firstElementChild !== fragment.lastElementChild) {\n\t\t\t\t\tthrowHierarchyRequestError(\n\t\t\t\t\t\t'can not insert more than one element under a Document'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tArray.from(fragment.childNodes).some((child) =>\n\t\t\t\t\t\tisNodeOfType(child, NodeType.TEXT_NODE)\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tthrowHierarchyRequestError('can not insert a Text node under a Document');\n\t\t\t\t}\n\t\t\t\t// Otherwise, if node has one element child and either parent has an element child,\n\t\t\t\t// child is a doctype, or child is non-null and a doctype is following child.\n\t\t\t\tif (\n\t\t\t\t\tfragment.firstElementChild &&\n\t\t\t\t\t(parentDocument.documentElement ||\n\t\t\t\t\t\t(child && isNodeOfType(child, NodeType.DOCUMENT_TYPE_NODE)) ||\n\t\t\t\t\t\t(child &&\n\t\t\t\t\t\t\tparentDocument.doctype &&\n\t\t\t\t\t\t\tgetNodeIndex(child) < getNodeIndex(parentDocument.doctype)))\n\t\t\t\t) {\n\t\t\t\t\tthrowHierarchyRequestError(\n\t\t\t\t\t\t'Document should contain at most one doctype, followed by at most one ' +\n\t\t\t\t\t\t\t'element'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// element\n\t\t\tcase NodeType.ELEMENT_NODE:\n\t\t\t\t// parent has an element child, child is a doctype, or child is non-null and a\n\t\t\t\t// doctype is following child.\n\t\t\t\tif (\n\t\t\t\t\tparentDocument.documentElement ||\n\t\t\t\t\t(child && isNodeOfType(child, NodeType.DOCUMENT_TYPE_NODE)) ||\n\t\t\t\t\t(child &&\n\t\t\t\t\t\tparentDocument.doctype &&\n\t\t\t\t\t\tgetNodeIndex(child) < getNodeIndex(parentDocument.doctype))\n\t\t\t\t) {\n\t\t\t\t\tthrowHierarchyRequestError(\n\t\t\t\t\t\t'Document should contain at most one doctype, followed by at most one ' +\n\t\t\t\t\t\t\t'element'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// doctype\n\t\t\tcase NodeType.DOCUMENT_TYPE_NODE:\n\t\t\t\t// parent has a doctype child, child is non-null and an element is preceding child,\n\t\t\t\t// or child is null and parent has an element child.\n\t\t\t\tif (\n\t\t\t\t\tparentDocument.doctype ||\n\t\t\t\t\t(child &&\n\t\t\t\t\t\tparentDocument.documentElement &&\n\t\t\t\t\t\tgetNodeIndex(parentDocument.documentElement) < getNodeIndex(child)) ||\n\t\t\t\t\t(!child && parentDocument.documentElement)\n\t\t\t\t) {\n\t\t\t\t\tthrowHierarchyRequestError(\n\t\t\t\t\t\t'Document should contain at most one doctype, followed by at most one ' +\n\t\t\t\t\t\t\t'element'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * To pre-insert a node into a parent before a child, run these steps:\n *\n * @param node   - Node to pre-insert\n * @param parent - Parent to insert under\n * @param child  - Child to insert before, or null to insert at the end of parent\n *\n * @returns The inserted node\n */\nexport function preInsertNode<TNode extends Node>(\n\tnode: TNode,\n\tparent: Node,\n\tchild: Node | null\n): TNode {\n\t// 1. Ensure pre-insertion validity of node into parent before child.\n\tensurePreInsertionValidity(node, parent, child);\n\n\t// 2. Let referenceChild be child.\n\tlet referenceChild = child;\n\n\t// 3. If referenceChild is node, set it to node’s next sibling.\n\tif (referenceChild === node) {\n\t\treferenceChild = node.nextSibling;\n\t}\n\n\t// 4. Adopt node into parent's node document.\n\tadoptNode(node, getNodeDocument(parent));\n\n\t// 5. Insert node into parent before referenceChild.\n\tinsertNode(node, parent, referenceChild);\n\n\t// 6. Return node.\n\treturn node;\n}\n\n/**\n * To insert a node into a parent before a child, with an optional suppress observers flag, run\n * these steps:\n *\n * @param node              - Node to insert\n * @param parent            - Parent to insert under\n * @param child             - Child to insert before, or null to insert at end of parent\n * @param suppressObservers - Whether to skip enqueueing a mutation record for this mutation\n */\nexport function insertNode(\n\tnode: Node,\n\tparent: Node,\n\tchild: Node | null,\n\tsuppressObservers: boolean = false\n): void {\n\t// 1. Let nodes be node’s children if node is a DocumentFragment node; otherwise « node ».\n\tconst isFragment = isDocumentFragment(node);\n\tconst nodes = isFragment ? Array.from(node.childNodes) : [node];\n\n\t// 2. Let count be nodes's size.\n\tconst count = nodes.length;\n\n\t// 3. If count is 0, then return.\n\tif (count === 0) {\n\t\treturn;\n\t}\n\n\t// 4. If node is a DocumentFragment node, then:\n\tif (isFragment) {\n\t\t// 4.1 Remove its children with the suppress observers flag set.\n\t\tnodes.forEach((n) => removeNode(n, true));\n\n\t\t// 4.2 Queue a tree mutation record for node with « », nodes, null, and null.\n\t\t// Note: This step intentionally does not pay attention to the suppress observers flag.\n\t\tqueueMutationRecord('childList', node, {\n\t\t\tremovedNodes: nodes,\n\t\t});\n\t}\n\n\t// 5. If child is non-null, then:\n\tif (child !== null) {\n\t\tconst childIndex = getNodeIndex(child);\n\t\tconst context = getContext(node);\n\t\tcontext.forEachRange((range) => {\n\t\t\t// 2.1. For each live range whose start node is parent and start offset is greater than\n\t\t\t// child’s index, increase its start offset by count.\n\t\t\tif (range.startContainer === parent && range.startOffset > childIndex) {\n\t\t\t\trange.startOffset += count;\n\t\t\t}\n\n\t\t\t// 2.2. For each live range whose end node is parent and end offset is greater than\n\t\t\t// child’s index, increase its end offset by count.\n\t\t\tif (range.endContainer === parent && range.endOffset > childIndex) {\n\t\t\t\trange.endOffset += count;\n\t\t\t}\n\t\t});\n\t}\n\n\t// 6. Let previousSibling be child’s previous sibling or parent’s last child if child is null.\n\tlet previousSibling = child === null ? parent.lastChild : child.previousSibling;\n\n\t// 7. For each node in nodes, in tree order:\n\tnodes.forEach((node) => {\n\t\t// 7.1. If child is null, then append node to parent’s children.\n\t\t// 7.2. Otherwise, insert node into parent’s children before child’s index.\n\t\tinsertIntoChildren(node, parent, child);\n\n\t\t// 7.3. If parent is a shadow host and node is a slottable, then assign a slot for node.\n\t\t// (shadow dom not implemented)\n\n\t\t// 7.4. If parent's root is a shadow root, and parent is a slot whose assigned nodes is the\n\t\t// empty list, then run signal a slot change for parent.\n\t\t// 7.5. Run assign slottables for a tree with node’s tree.\n\t\t// (shadow dom not implemented)\n\n\t\t// 7.6. For each shadow-including inclusive descendant inclusiveDescendant of node, in\n\t\t// shadow-including tree order:\n\t\t// 7.6.1. Run the insertion steps with inclusiveDescendant.\n\t\t// (insertion steps not implemented)\n\n\t\t// 7.6.2. If inclusiveDescendant is connected, then:\n\t\t// 7.6.2.1. If inclusiveDescendant is custom, then enqueue a custom element callback\n\t\t// reaction with inclusiveDescendant, callback name \"connectedCallback\", and an empty\n\t\t// argument list.\n\t\t// 7.6.2.2. Otherwise, try to upgrade inclusiveDescendant. If this successfully upgrades\n\t\t// inclusiveDescendant, its connectedCallback will be enqueued automatically during the\n\t\t// upgrade an element algorithm.\n\t\t// (custom elements not implemented)\n\t});\n\n\t// 8. If suppress observers flag is unset, queue a tree mutation record for parent with nodes,\n\t// « », previousSibling and child.\n\tif (!suppressObservers) {\n\t\tqueueMutationRecord('childList', parent, {\n\t\t\taddedNodes: nodes,\n\t\t\tnextSibling: child,\n\t\t\tpreviousSibling: previousSibling,\n\t\t});\n\t}\n\n\t// 9. Run the children changed steps for parent\n\t// (children changed steps not implemented)\n}\n\n/**\n * To append a node to a parent\n *\n * @param node   - Node to append\n * @param parent - Parent to append to\n *\n * @returns The appended node\n */\nexport function appendNode<TNode extends Node>(node: TNode, parent: Node): TNode {\n\t// pre-insert node into parent before null.\n\treturn preInsertNode(node, parent, null);\n}\n\n/**\n * To replace a child with node within a parent, run these steps:\n *\n * @param child  - The child node to replace\n * @param node   - The node to replace child with\n * @param parent - The parent to replace under\n *\n * @returns The old child node\n */\nexport function replaceChildWithNode<TChild extends Node>(\n\tchild: TChild,\n\tnode: Node,\n\tparent: Node\n): TChild {\n\t// 1. If parent is not a Document, DocumentFragment, or Element node, throw a\n\t// HierarchyRequestError.\n\tif (\n\t\t!isNodeOfType(\n\t\t\tparent,\n\t\t\tNodeType.DOCUMENT_NODE,\n\t\t\tNodeType.DOCUMENT_FRAGMENT_NODE,\n\t\t\tNodeType.ELEMENT_NODE\n\t\t)\n\t) {\n\t\tthrowHierarchyRequestError('Can not replace under a non-parent node');\n\t}\n\n\t// 2. If node is a host-including inclusive ancestor of parent, throw a HierarchyRequestError.\n\tif (node.contains(parent)) {\n\t\tthrowHierarchyRequestError('Can not insert a node under its own descendant');\n\t}\n\n\t// 3. If child’s parent is not parent, then throw a NotFoundError.\n\tif (child.parentNode !== parent) {\n\t\tthrowNotFoundError('child is not a child of parent');\n\t}\n\n\t// 4. If node is not a DocumentFragment, DocumentType, Element, Text, ProcessingInstruction, or\n\t// Comment node, throw a HierarchyRequestError.\n\tif (\n\t\t!isNodeOfType(\n\t\t\tnode,\n\t\t\tNodeType.DOCUMENT_FRAGMENT_NODE,\n\t\t\tNodeType.DOCUMENT_TYPE_NODE,\n\t\t\tNodeType.ELEMENT_NODE,\n\t\t\tNodeType.TEXT_NODE,\n\t\t\tNodeType.CDATA_SECTION_NODE,\n\t\t\tNodeType.PROCESSING_INSTRUCTION_NODE,\n\t\t\tNodeType.COMMENT_NODE\n\t\t)\n\t) {\n\t\tthrowHierarchyRequestError(\n\t\t\t\"Can not insert a node that isn't a DocumentFragment, DocumentType, Element, Text, \" +\n\t\t\t\t'ProcessingInstruction or Comment'\n\t\t);\n\t}\n\n\t// 5. If either node is a Text node and parent is a document, or node is a doctype and parent is\n\t// not a document, throw a HierarchyRequestError.\n\tif (isNodeOfType(node, NodeType.TEXT_NODE) && isNodeOfType(parent, NodeType.DOCUMENT_NODE)) {\n\t\tthrowHierarchyRequestError('can not insert a Text node under a Document');\n\t}\n\tif (\n\t\tisNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE) &&\n\t\t!isNodeOfType(parent, NodeType.DOCUMENT_NODE)\n\t) {\n\t\tthrowHierarchyRequestError('can only insert a DocumentType node under a Document');\n\t}\n\n\t// 6. If parent is a document, and any of the statements below, switched on node, are true,\n\t// throw a HierarchyRequestError.\n\tif (isNodeOfType(parent, NodeType.DOCUMENT_NODE)) {\n\t\tconst parentDocument = parent as Document;\n\t\tswitch (node.nodeType) {\n\t\t\t// DocumentFragment node\n\t\t\tcase NodeType.DOCUMENT_FRAGMENT_NODE:\n\t\t\t\t// If node has more than one element child or has a Text node child.\n\t\t\t\tconst fragment = node as DocumentFragment;\n\t\t\t\tif (fragment.firstElementChild !== fragment.lastElementChild) {\n\t\t\t\t\tthrowHierarchyRequestError(\n\t\t\t\t\t\t'can not insert more than one element under a Document'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tArray.from(fragment.childNodes).some((child) =>\n\t\t\t\t\t\tisNodeOfType(child, NodeType.TEXT_NODE)\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tthrowHierarchyRequestError('can not insert a Text node under a Document');\n\t\t\t\t}\n\t\t\t\t// Otherwise, if node has one element child and either parent has an element child\n\t\t\t\t// that is not child or a doctype is following child.\n\t\t\t\tif (\n\t\t\t\t\tfragment.firstElementChild &&\n\t\t\t\t\t((parentDocument.documentElement &&\n\t\t\t\t\t\tparentDocument.documentElement !== (child as Node)) ||\n\t\t\t\t\t\t(child &&\n\t\t\t\t\t\t\tparentDocument.doctype &&\n\t\t\t\t\t\t\tgetNodeIndex(child) < getNodeIndex(parentDocument.doctype)))\n\t\t\t\t) {\n\t\t\t\t\tthrowHierarchyRequestError(\n\t\t\t\t\t\t'Document should contain at most one doctype, followed by at most one ' +\n\t\t\t\t\t\t\t'element'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// element\n\t\t\tcase NodeType.ELEMENT_NODE:\n\t\t\t\t// parent has an element child that is not child or a doctype is following child.\n\t\t\t\tif (\n\t\t\t\t\t(parentDocument.documentElement &&\n\t\t\t\t\t\tparentDocument.documentElement !== (child as Node)) ||\n\t\t\t\t\t(parentDocument.doctype &&\n\t\t\t\t\t\tgetNodeIndex(child) < getNodeIndex(parentDocument.doctype))\n\t\t\t\t) {\n\t\t\t\t\tthrowHierarchyRequestError(\n\t\t\t\t\t\t'Document should contain at most one doctype, followed by at most one ' +\n\t\t\t\t\t\t\t'element'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// doctype\n\t\t\tcase NodeType.DOCUMENT_TYPE_NODE:\n\t\t\t\t// parent has a doctype child that is not child, or an element is preceding child.\n\t\t\t\tif (\n\t\t\t\t\t(parentDocument.doctype && parentDocument.doctype !== (child as Node)) ||\n\t\t\t\t\t(parentDocument.documentElement &&\n\t\t\t\t\t\tgetNodeIndex(parentDocument.documentElement) < getNodeIndex(child))\n\t\t\t\t) {\n\t\t\t\t\tthrowHierarchyRequestError(\n\t\t\t\t\t\t'Document should contain at most one doctype, followed by at most one ' +\n\t\t\t\t\t\t\t'element'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\t// The above statements differ from the pre-insert algorithm.\n\t}\n\n\t// 7. Let referenceChild be child’s next sibling.\n\tlet referenceChild = child.nextSibling;\n\n\t// 8. If referenceChild is node, set it to node’s next sibling.\n\tif (referenceChild === node) {\n\t\treferenceChild = node.nextSibling;\n\t}\n\n\t// 9. Let previousSibling be child’s previous sibling.\n\tconst previousSibling = child.previousSibling;\n\n\t// 10. Adopt node into parent's node document\n\tadoptNode(node, getNodeDocument(parent));\n\n\t// 11. Let removedNodes be the empty set.\n\tlet removedNodes: Node[] = [];\n\n\t// 12. If child’s parent is non-null, then:\n\tif (child.parentNode !== null) {\n\t\t// 11.1. Set removedNodes to « child ».\n\t\tremovedNodes.push(child);\n\n\t\t// 11.2. Remove child with the suppress observers flag set.\n\t\tremoveNode(child, true);\n\t}\n\t// The above can only be false if child is node.\n\n\t// 13. Let nodes be node’s children if node is a DocumentFragment node; otherwise « node ».\n\tconst nodes = isNodeOfType(node, NodeType.DOCUMENT_FRAGMENT_NODE)\n\t\t? Array.from(node.childNodes)\n\t\t: [node];\n\n\t// 14. Insert node into parent before referenceChild with the suppress observers flag set.\n\tinsertNode(node, parent, referenceChild, true);\n\n\t// 15. Queue a tree mutation record for parent with nodes, removedNodes, previousSibling and\n\t// referenceChild.\n\tqueueMutationRecord('childList', parent, {\n\t\taddedNodes: nodes,\n\t\tremovedNodes: removedNodes,\n\t\tnextSibling: referenceChild,\n\t\tpreviousSibling: previousSibling,\n\t});\n\n\t// 16. Return child.\n\treturn child;\n}\n\n/**\n * To replace all with a node within a parent, run these steps:\n *\n * @param node   New node to insert, or null to remove all nodes under parent\n * @param parent Parent to replace under\n */\nexport function replaceAllWithNode(node: Node | null, parent: Node): void {\n\t// 1. If node is non-null, then adopt node into parent's node document\n\tif (node !== null) {\n\t\tadoptNode(node, getNodeDocument(parent));\n\t}\n\n\t// 2. Let removedNodes be parent’s children.\n\tconst removedNodes = Array.from(parent.childNodes);\n\n\t// 3. Let addedNodes be the empty set.\n\tlet addedNodes: Node[] = [];\n\n\tif (node !== null) {\n\t\t// 4. If node is a DocumentFragment node, then set addedNodes to node's children.\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_FRAGMENT_NODE)) {\n\t\t\tnode.childNodes.forEach((child) => {\n\t\t\t\taddedNodes.push(child);\n\t\t\t});\n\t\t} else {\n\t\t\t// 5. Otherwise, if node is non-null, set addedNodes to « node ».\n\t\t\taddedNodes.push(node);\n\t\t}\n\t}\n\n\t// 6. Remove all parent’s children, in tree order, with the suppress observers flag set.\n\tremovedNodes.forEach((child) => {\n\t\tremoveNode(child, true);\n\t});\n\n\t// 7. If node is non-null, then insert node into parent before null with the suppress observers\n\t// flag set.\n\tif (node !== null) {\n\t\tinsertNode(node, parent, null, true);\n\t}\n\n\t// 8. If either addedNodes or removedNodes is not empty, then queue a tree mutation record for\n\t// parent with addedNodes, removedNodes, null, and null.\n\tif (addedNodes.length > 0 || removedNodes.length > 0) {\n\t\tqueueMutationRecord('childList', parent, {\n\t\t\taddedNodes,\n\t\t\tremovedNodes,\n\t\t});\n\t}\n\n\t// This algorithm does not make any checks with regards to the node tree constraints.\n\t// Specification authors need to use it wisely.\n}\n\n/**\n * To pre-remove a child from a parent, run these steps:\n *\n * @param child  - Child node to remove\n * @param parent - Parent under which to remove child\n *\n * @returns The removed child\n */\nexport function preRemoveChild<TChild extends Node>(child: TChild, parent: Node): TChild {\n\t// 1. If child’s parent is not parent, then throw a NotFoundError.\n\tif (child.parentNode !== parent) {\n\t\tthrowNotFoundError('child is not a child of parent');\n\t}\n\n\t// 2. Remove child.\n\tremoveNode(child);\n\n\t// 3. Return child.\n\treturn child;\n}\n\n/**\n * To remove a node, with an optional suppress observers flag, run these steps:\n *\n * @param node              - Child to remove\n * @param suppressObservers - Whether to skip enqueueing a mutation record for this mutation\n */\nexport function removeNode(node: Node, suppressObservers: boolean = false): void {\n\t// 1. Let parent be node's parent\n\t// 2. Assert: parent is non-null.\n\tconst parent = node.parentNode!;\n\n\t// 3. Let index be node’s index.\n\tconst index = getNodeIndex(node);\n\n\tconst context = getContext(node);\n\tcontext.forEachRange((range) => {\n\t\t// 4. For each live range whose start node is an inclusive descendant of node, set its start\n\t\t// to (parent, index).\n\t\tif (node.contains(range.startContainer)) {\n\t\t\trange.startContainer = parent;\n\t\t\trange.startOffset = index;\n\t\t}\n\n\t\t// 5. For each live range whose end node is an inclusive descendant of node, set its end to\n\t\t// (parent, index).\n\t\tif (node.contains(range.endContainer)) {\n\t\t\trange.endContainer = parent;\n\t\t\trange.endOffset = index;\n\t\t}\n\n\t\t// 6. For each live range whose start node is parent and start offset is greater than index,\n\t\t// decrease its start offset by one.\n\t\tif (range.startContainer === parent && range.startOffset > index) {\n\t\t\trange.startOffset -= 1;\n\t\t}\n\n\t\t// 7. For each live range whose end node is parent and end offset is greater than index,\n\t\t// decrease its end offset by one.\n\t\tif (range.endContainer === parent && range.endOffset > index) {\n\t\t\trange.endOffset -= 1;\n\t\t}\n\t});\n\n\t// 8. For each NodeIterator object iterator whose root’s node document is node’s node document,\n\t// run the NodeIterator pre-removing steps given node and iterator.\n\t// (NodeIterator not implemented)\n\n\t// 9. Let oldPreviousSibling be node’s previous sibling.\n\tconst oldPreviousSibling = node.previousSibling;\n\n\t// 10. Let oldNextSibling be node’s next sibling.\n\tconst oldNextSibling = node.nextSibling;\n\n\t// 11. Remove node from its parent’s children.\n\tremoveFromChildren(node, parent);\n\n\t// 12. If node is assigned, then run assign slottables for node’s assigned slot.\n\t// (shadow dom not implemented)\n\n\t// 13. If parent's root is a shadow root, and parent is a slot whose assigned nodes is the empty\n\t// list, then run signal a slot change for parent.\n\t// (shadow dom not implemented)\n\n\t// 14. If node has an inclusive descendant that is a slot, then:\n\t// 14.1. Run assign slottables for a tree with parent’s tree.\n\t// 14.2. Run assign slottables for a tree with node’s tree.\n\t// (shadow dom not implemented)\n\n\t// 15. Run the removing steps with node and parent.\n\t// (removing steps not implemented)\n\n\t// 16. Let isParentConnected be parent's connected.\n\t// 17. If node is custom and isParentConnected is true, then enqueue a custom element callback\n\t// reaction with node, callback name \"disconnectedCallback\", and an empty argument list.\n\t// It is intentional for now that custom elements do not get parent passed. This might change in\n\t// the future if there is a need.\n\t// (custom elements not implemented)\n\n\t// 18. For each shadow-including descendant descendant of node, in shadow-including tree order,\n\t// then:\n\t// 18.1. Run the removing steps with descendant.\n\t// (shadow dom not implemented)\n\n\t// 18.2. If descendant is custom and isParentConnected is true, then enqueue a custom element\n\t// callback reaction with descendant, callback name \"disconnectedCallback\", and an empty\n\t// argument list.\n\t// (custom elements not implemented)\n\n\t// 19. For each inclusive ancestor inclusiveAncestor of parent, and then for each registered of\n\t// inclusiveAncestor's registered observer list, if registered's options's subtree is true, then\n\t// append a new transient registered observer whose observer is registered's observer, options\n\t// is registered's options, and source is registered to node's registered observer list.\n\tfor (\n\t\tlet inclusiveAncestor: Node | null = parent;\n\t\tinclusiveAncestor;\n\t\tinclusiveAncestor = inclusiveAncestor.parentNode\n\t) {\n\t\tinclusiveAncestor._registeredObservers.appendTransientRegisteredObservers(node);\n\t}\n\n\t// 20. If suppress observers flag is unset, queue a tree mutation record for parent with « »,\n\t// « node », oldPreviousSibling, and oldNextSibling\n\tif (!suppressObservers) {\n\t\tqueueMutationRecord('childList', parent, {\n\t\t\tremovedNodes: [node],\n\t\t\tnextSibling: oldNextSibling,\n\t\t\tpreviousSibling: oldPreviousSibling,\n\t\t});\n\t}\n\n\t// 21. Run the children changed steps for parent\n\t// (children changed steps not implemented)\n}\n\n/**\n * 3.5. Interface Document\n *\n * To adopt a node into a document, with an optional forceDocumentFragmentAdoption, run these steps:\n *\n * (forceDocumentFragmentAdoption is only set to true for HTML template, so is not implemented here)\n *\n * @param node     - Node to adopt\n * @param document - Document to adopt node into\n */\nexport function adoptNode(node: Node, document: Document): void {\n\t// 1. If forceDocumentFragmentAdoption is not given, then set it false.\n\t// (value unused)\n\n\t// 2. Let oldDocument be node’s node document.\n\tconst oldDocument = getNodeDocument(node);\n\n\t// 2. If node’s parent is non-null, remove node.\n\tif (node.parentNode) {\n\t\tremoveNode(node);\n\t}\n\n\t// 3. If document is not oldDocument, then:\n\tif (document === oldDocument) {\n\t\treturn;\n\t}\n\n\t// 3.1. For each inclusiveDescendant in node’s shadow-including inclusive descendants:\n\tforEachInclusiveDescendant(node, (inclusiveDescendant) => {\n\t\t// 3.1.1. If forceDocumentFragmentAdoption is false, inclusiveDescendant is a\n\t\t// DocumentFragment node, inclusiveDescendant is node, and node's host is non-null, then\n\t\t// continue\n\t\t// Note: this is only reasonable as long as all adopt callers remove the children of node.\n\t\t// (shadow dom and HTML templates not implemented)\n\n\t\t// 3.1.2. Set inclusiveDescendant’s node document to document.\n\t\t// (calling code ensures that node is never a Document)\n\t\tinclusiveDescendant.ownerDocument = document;\n\n\t\t// 3.1.3. If inclusiveDescendant is an element, then set the node document of each attribute\n\t\t// in inclusiveDescendant’s attribute list to document.\n\t\tif (isNodeOfType(inclusiveDescendant, NodeType.ELEMENT_NODE)) {\n\t\t\tfor (const attr of (inclusiveDescendant as Element).attributes) {\n\t\t\t\tattr.ownerDocument = document;\n\t\t\t}\n\t\t}\n\t});\n\n\t// 3.2. For each inclusiveDescendant in node’s shadow-including inclusive descendants that is\n\t// custom, enqueue a custom element callback reaction with inclusiveDescendant, callback name\n\t// \"adoptedCallback\", and an argument list containing oldDocument and document.\n\t// (custom element support has not been implemented)\n\n\t// 3.3. For each inclusiveDescendant in node’s shadow-including inclusive descendants, in\n\t// shadow-including tree order, run the adopting steps with inclusiveDescendant and oldDocument.\n\t// (adopting steps not implemented)\n}\n\n/**\n * The descendant text content of a node node is the concatenation of the data of all the Text node\n * descendants of node, in tree order.\n *\n * @param node Root node\n *\n * @returns  The concatenation of data of all the Text node descendants of the given node, in tree\n *           order\n */\nexport function getDescendantTextContent(node: Node): string {\n\tconst data: string[] = [];\n\tforEachInclusiveDescendant(node, (descendant) => {\n\t\t// CDATASection is a subtype of Text\n\t\tif (!isNodeOfType(descendant, NodeType.TEXT_NODE, NodeType.CDATA_SECTION_NODE)) {\n\t\t\treturn;\n\t\t}\n\n\t\tdata.push((descendant as Text).data);\n\t});\n\treturn data.join('');\n}\n\n/**\n * Implementation of the textContent setter for DocumentFragment and Element\n *\n * @param parent    Node for which to set textContent\n * @param newValue  New textContent value\n */\nexport function stringReplaceAll(parent: Node, newValue: string): void {\n\t// 1. Let node be null.\n\tlet node = null;\n\n\t// 2. If the given value is not the empty string, then set node to a new Text node whose data is\n\t// the given value and node document is parent’s node document.\n\tif (newValue !== '') {\n\t\tconst context = getContext(parent);\n\t\tnode = new context.Text(newValue);\n\t}\n\n\t// 3. Replace all with node within the this.\n\treplaceAllWithNode(node, parent);\n}\n\n/**\n * To convert nodes into a node, given nodes and document, run these steps:\n *\n * @param nodes    Nodes and/or strings to convert\n * @param document Document used to create new nodes\n *\n * @returns A single node representing nodes\n */\nfunction convertNodesIntoNode(nodes: (Node | string)[], document: Document): Node {\n\t// 1. Let node be null.\n\t// (created as needed in branches below)\n\n\t// 2. Replace each string in nodes with a new Text node whose data is the string and node\n\t// document is document.\n\tconst actualNodes: Node[] = nodes.map((nodeOrString) => {\n\t\t// IDL actually coerces every non-node (e.g., null) into a string here\n\t\tif (nodeOrString instanceof Node) {\n\t\t\treturn nodeOrString;\n\t\t}\n\t\treturn document.createTextNode(String(nodeOrString));\n\t});\n\n\t// 3. If nodes contains one node, set node to that node.\n\tif (actualNodes.length === 1) {\n\t\treturn actualNodes[0];\n\t} else {\n\t\t// 4. Otherwise, set node to a new DocumentFragment whose node document is document, and then\n\t\t// append each node in nodes, if any, to it.\n\t\tconst node = document.createDocumentFragment();\n\t\tactualNodes.forEach((child) => {\n\t\t\tnode.appendChild(child);\n\t\t});\n\t\treturn node;\n\t}\n\n\t// 5. Return node.\n\t// (done in branches above)\n}\n\n/**\n * The prepend(nodes) method, when invoked, must run these steps:\n *\n * @param thisObject - The ParentNode on which the method is invoked\n * @param nodes      - The nodes (and/or strings) to prepend\n */\nexport function prependNodes(thisObject: Node & ParentNode, nodes: (Node | string)[]): void {\n\t// 1. Let node be the result of converting nodes into a node given nodes and this’s node\n\t// document.\n\tconst node = convertNodesIntoNode(nodes, getNodeDocument(thisObject));\n\n\t// 2. Pre-insert node into this before the this’s first child.\n\tpreInsertNode(node, thisObject, thisObject.firstChild);\n}\n\n/**\n * The append(nodes) method, when invoked, must run these steps:\n *\n * @param thisObject - The ParentNode on which the method is invoked\n * @param nodes      - The nodes (and/or strings) to append\n */\nexport function appendNodes(thisObject: Node & ParentNode, nodes: (Node | string)[]): void {\n\t// 1. Let node be the result of converting nodes into a node given nodes and this’s node\n\t// document.\n\tconst node = convertNodesIntoNode(nodes, getNodeDocument(thisObject));\n\n\t// 2. Append node to this\n\tappendNode(node, thisObject);\n}\n\n/**\n * The replaceChildren(nodes) method, when invoked, must run these steps:\n *\n * @param thisObject - The ParentNode on which the method is invoked\n * @param nodes      - The nodes (and/or strings) to replace the children with\n */\nexport function replaceChildren(thisObject: Node & ParentNode, nodes: (Node | string)[]): void {\n\t// 1. Let node be the result of converting nodes into a node given nodes and this's node\n\t// document.\n\tconst node = convertNodesIntoNode(nodes, getNodeDocument(thisObject));\n\n\t// 2. Ensure pre-insertion validity of node into this before null.\n\tensurePreInsertionValidity(node, thisObject, null);\n\n\t// 3. Replace all with node within this.\n\treplaceAllWithNode(node, thisObject);\n}\n\n/**\n * The before(nodes) method, when invoked, must run these steps:\n *\n * @param thisObject - The ChildNode on which the method is invoked\n * @param nodes        The nodes (and/or strings) to insert\n */\nexport function insertNodesBefore(thisObject: Node & ChildNode, nodes: (Node | string)[]): void {\n\t// 1. Let parent be this’s parent.\n\tconst parent = thisObject.parentNode;\n\n\t// 2. If parent is null, then return.\n\tif (parent === null) {\n\t\treturn;\n\t}\n\n\t// 3. Let viablePreviousSibling be this’s first preceding sibling not in nodes, and\n\t// null otherwise.\n\tlet viablePreviousSibling = thisObject.previousSibling;\n\twhile (viablePreviousSibling !== null && nodes.indexOf(viablePreviousSibling) >= 0) {\n\t\tviablePreviousSibling = viablePreviousSibling.previousSibling;\n\t}\n\n\t// 4. Let node be the result of converting nodes into a node, given nodes and this’s\n\t// node document.\n\tconst node = convertNodesIntoNode(nodes, getNodeDocument(thisObject));\n\n\t// 5. If viablePreviousSibling is null, set it to parent’s first child, and to\n\t// viablePreviousSibling’s next sibling otherwise.\n\t// (it makes more sense to rename this as it will no longer be a previous sibling to the\n\t// inserted nodes)\n\tconst referenceNode =\n\t\tviablePreviousSibling === null ? parent.firstChild : viablePreviousSibling.nextSibling;\n\n\t// 6. Pre-insert node into parent before viablePreviousSibling.\n\tpreInsertNode(node, parent, referenceNode);\n}\n\n/**\n * The after(nodes) method, when invoked, must run these steps:\n *\n * @param thisObject - The ChildNode on which the method is invoked\n * @param nodes      - The nodes (and/or strings) to insert\n */\nexport function insertNodesAfter(thisObject: Node & ChildNode, nodes: (Node | string)[]): void {\n\t// 1. Let parent be this’s parent.\n\tconst parent = thisObject.parentNode;\n\n\t// 2. If parent is null, then return.\n\tif (parent === null) {\n\t\treturn;\n\t}\n\n\t// 3. Let viableNextSibling be this’s first following sibling not in nodes, and null\n\t// otherwise.\n\tlet viableNextSibling = thisObject.nextSibling;\n\twhile (viableNextSibling !== null && nodes.indexOf(viableNextSibling) >= 0) {\n\t\tviableNextSibling = viableNextSibling.nextSibling;\n\t}\n\n\t// 4. Let node be the result of converting nodes into a node, given nodes and this’s\n\t// node document.\n\tconst node = convertNodesIntoNode(nodes, getNodeDocument(thisObject));\n\n\t// 5. Pre-insert node into parent before viableNextSibling.\n\tpreInsertNode(node, parent, viableNextSibling);\n}\n\n/**\n * The replaceWith(nodes) method, when invoked, must run these steps:\n *\n * @param thisObject - The ChildNode on which the method is invoked\n * @param nodes      - The nodes (and/or strings) to insert\n */\nexport function replaceWithNodes(thisObject: Node & ChildNode, nodes: (Node | string)[]): void {\n\t// 1. Let parent be this’s parent.\n\tconst parent = thisObject.parentNode;\n\n\t// 2. If parent is null, then return.\n\tif (parent === null) {\n\t\treturn;\n\t}\n\n\t// 3. Let viableNextSibling be this’s first following sibling not in nodes, and null\n\t// otherwise.\n\tlet viableNextSibling = thisObject.nextSibling;\n\twhile (viableNextSibling !== null && nodes.indexOf(viableNextSibling) >= 0) {\n\t\tviableNextSibling = viableNextSibling.nextSibling;\n\t}\n\n\t// 4. Let node be the result of converting nodes into a node, given nodes and this’s\n\t// node document.\n\tconst node = convertNodesIntoNode(nodes, getNodeDocument(thisObject));\n\n\t// 5. If this’s parent is parent, replace the this with node within parent.\n\t// Note: this could have been inserted into node.\n\tif (thisObject.parentNode === parent) {\n\t\treplaceChildWithNode(thisObject, node, parent);\n\t} else {\n\t\t// 6. Otherwise, pre-insert node into parent before viableNextSibling.\n\t\tpreInsertNode(node, parent, viableNextSibling);\n\t}\n}\n\n/**\n * The remove() method, when invoked, must run these steps:\n *\n * @param thisObject The ChildNode on which the method is invoked\n */\nexport function removeFromParent(thisObject: Node & ChildNode): void {\n\t// 1. If this’s parent is null, then return.\n\tif (thisObject.parentNode === null) {\n\t\treturn;\n\t}\n\n\t// 2. Remove the this.\n\tremoveNode(thisObject);\n}\n\n/**\n * To insert a node node into a live range range, run these steps:\n *\n * @param node  - the node to insert\n * @param range - the live range to insert into\n */\nexport function insertNodeIntoRange(node: Node, range: Range): void {\n\t// 1. If range's start node is a ProcessingInstruction or Comment node, is a Text node whose\n\t// parent is null, or is node, then throw a \"HierarchyRequestError\" DOMException.\n\tconst startContainer = range.startContainer;\n\tif (isNodeOfType(startContainer, NodeType.PROCESSING_INSTRUCTION_NODE)) {\n\t\tthrowHierarchyRequestError('Can not insert into a processing instruction');\n\t}\n\tif (isNodeOfType(startContainer, NodeType.COMMENT_NODE)) {\n\t\tthrowHierarchyRequestError('Can not insert into a comment');\n\t}\n\tif (isTextNode(startContainer) && startContainer.parentNode === null) {\n\t\tthrowHierarchyRequestError('Can not insert into a text node without a parent');\n\t}\n\n\t// 2. Let referenceNode be null.\n\tlet referenceNode: Node | null = null;\n\n\t// 3. If range's start node is a Text node, set referenceNode to that Text node.\n\tif (isTextNode(startContainer)) {\n\t\treferenceNode = startContainer;\n\t} else {\n\t\t// 4. Otherwise, set referenceNode to the child of start node whose index is start offset,\n\t\t// and null if there is no such child.\n\t\treferenceNode = startContainer.childNodes[range.startOffset] || null;\n\t}\n\n\t// 5. Let parent be range's start node if referenceNode is null, and referenceNode's parent\n\t// otherwise.\n\tconst parent = referenceNode === null ? startContainer : referenceNode.parentNode!;\n\n\t// 6. Ensure pre-insertion validity of node into parent before referenceNode.\n\tensurePreInsertionValidity(node, parent, referenceNode);\n\n\t// 7. If range's start node is a Text node, set referenceNode to the result of splitting it with\n\t// offset range's start offset.\n\tif (isTextNode(startContainer)) {\n\t\treferenceNode = startContainer.splitText(range.startOffset);\n\t}\n\n\t// 8. If node is referenceNode, set referenceNode to its next sibling.\n\tif (node === referenceNode) {\n\t\treferenceNode = referenceNode.nextSibling;\n\t}\n\n\t// 9. If node's parent is non-null, then remove node.\n\tif (node.parentNode !== null) {\n\t\tremoveNode(node);\n\t}\n\n\t// 10. Let newOffset be parent's length if referenceNode is null, and referenceNode's index\n\t// otherwise.\n\tlet newOffset =\n\t\treferenceNode === null ? determineLengthOfNode(parent) : getNodeIndex(referenceNode);\n\n\t// 11. Increase newOffset by node's length if node is a DocumentFragment node, and one\n\t// otherwise.\n\tif (isNodeOfType(node, NodeType.DOCUMENT_FRAGMENT_NODE)) {\n\t\tnewOffset += determineLengthOfNode(node);\n\t} else {\n\t\tnewOffset += 1;\n\t}\n\n\t// 12. Pre-insert node into parent before referenceNode.\n\tpreInsertNode(node, parent, referenceNode);\n\n\t// 13. If range is collapsed, then set range’s end to (parent, newOffset).\n\tif (range.collapsed) {\n\t\trange.setEnd(parent, newOffset);\n\t}\n}\n","import { expectObject } from './errorHelpers';\n\nexport function asUnsignedLong(number: number): number {\n\treturn number >>> 0;\n}\n\nexport function legacyNullToEmptyString(value: string | null): string {\n\t// Treat null as empty string\n\tif (value === null) {\n\t\treturn '';\n\t}\n\n\t// Coerce other values to string\n\treturn String(value);\n}\n\nexport function ifNullActAsIfEmptyString(value: string | null | undefined): string {\n\t// Treat both undefined and null as empty string\n\tif (value === undefined || value === null) {\n\t\treturn '';\n\t}\n\n\t// Coerce other values to string\n\treturn String(value);\n}\n\nexport function asObject<T>(value: T, Constructor: any): T {\n\texpectObject(value, Constructor);\n\n\treturn value;\n}\n\nexport function asNullableObject<T>(value: T | null | undefined, Constructor: any): T | null {\n\tif (value === undefined || value === null) {\n\t\treturn null;\n\t}\n\n\treturn asObject(value, Constructor);\n}\n\nexport function asNullableString(value: string | null | undefined): string | null {\n\t// Treat undefined as null\n\tif (value === undefined) {\n\t\treturn null;\n\t}\n\n\treturn value;\n}\n","import Attr from './Attr';\nimport Element from './Element';\nimport Document from './Document';\nimport Text from './Text';\nimport { getContext } from './context/Context';\nimport RegisteredObservers from './mutation-observer/RegisteredObservers';\nimport cloneNode from './util/cloneNode';\nimport { expectArity } from './util/errorHelpers';\nimport {\n\tpreInsertNode,\n\tappendNode,\n\treplaceChildWithNode,\n\tpreRemoveChild,\n\tremoveNode,\n} from './util/mutationAlgorithms';\nimport { NodeType, isNodeOfType, isAttrNode } from './util/NodeType';\nimport {\n\tgetInclusiveAncestors,\n\tgetNodeDocument,\n\tgetNodeIndex,\n\tgetRootOfNode,\n} from './util/treeHelpers';\nimport { asNullableObject, asNullableString, asObject } from './util/typeHelpers';\n\nconst orderKeyByNode = new WeakMap<Node, number>();\n\n/**\n * Get an implementation-dependent integer value that can be used to consistently determine an\n * ordering between unrelated nodes.\n *\n * @param node - The node to compare ordering for\n */\nfunction getOrderKey(node: Node): number {\n\tlet orderKey = orderKeyByNode.get(node);\n\tif (orderKey === undefined) {\n\t\torderKey = Math.random();\n\t\torderKeyByNode.set(node, orderKey);\n\t}\n\treturn orderKey;\n}\n\n/**\n * 3.4. Interface Node\n *\n * @public\n */\nexport default abstract class Node {\n\t// Node types are exposed as properties of the constructor\n\tstatic ELEMENT_NODE: number = NodeType.ELEMENT_NODE;\n\tstatic ATTRIBUTE_NODE: number = NodeType.ATTRIBUTE_NODE;\n\tstatic TEXT_NODE: number = NodeType.TEXT_NODE;\n\tstatic CDATA_SECTION_NODE: number = NodeType.CDATA_SECTION_NODE;\n\tstatic ENTITY_REFERENCE_NODE: number = NodeType.ENTITY_REFERENCE_NODE; // legacy\n\tstatic ENTITY_NODE: number = NodeType.ENTITY_NODE; // legacy\n\tstatic PROCESSING_INSTRUCTION_NODE: number = NodeType.PROCESSING_INSTRUCTION_NODE;\n\tstatic COMMENT_NODE: number = NodeType.COMMENT_NODE;\n\tstatic DOCUMENT_NODE: number = NodeType.DOCUMENT_NODE;\n\tstatic DOCUMENT_TYPE_NODE: number = NodeType.DOCUMENT_TYPE_NODE;\n\tstatic DOCUMENT_FRAGMENT_NODE: number = NodeType.DOCUMENT_FRAGMENT_NODE;\n\tstatic NOTATION_NODE: number = NodeType.NOTATION_NODE; // legacy\n\n\t// Node types also exist as instance properties, assigned to the prototype below\n\tpublic ELEMENT_NODE!: number;\n\tpublic ATTRIBUTE_NODE!: number;\n\tpublic TEXT_NODE!: number;\n\tpublic CDATA_SECTION_NODE!: number;\n\tpublic ENTITY_REFERENCE_NODE!: number; // legacy\n\tpublic ENTITY_NODE!: number; // legacy\n\tpublic PROCESSING_INSTRUCTION_NODE!: number;\n\tpublic COMMENT_NODE!: number;\n\tpublic DOCUMENT_NODE!: number;\n\tpublic DOCUMENT_TYPE_NODE!: number;\n\tpublic DOCUMENT_FRAGMENT_NODE!: number;\n\tpublic NOTATION_NODE!: number; // legacy\n\n\t/**\n\t * Returns the type of node, represented by a number.\n\t */\n\tpublic abstract get nodeType(): number;\n\n\t/**\n\t * Returns a string appropriate for the type of node.\n\t */\n\tpublic abstract get nodeName(): string;\n\n\t/**\n\t * A reference to the Document node in which the current node resides.\n\t */\n\tpublic ownerDocument: Document | null = null;\n\n\t/**\n\t * The parent node of the current node.\n\t */\n\tpublic parentNode: Node | null = null;\n\n\t/**\n\t * The parent if it is an element, or null otherwise.\n\t */\n\tpublic get parentElement(): Element | null {\n\t\treturn this.parentNode && isNodeOfType(this.parentNode, NodeType.ELEMENT_NODE)\n\t\t\t? (this.parentNode as Element)\n\t\t\t: null;\n\t}\n\n\t/**\n\t * Returns true if this has children, and false otherwise.\n\t */\n\tpublic hasChildNodes(): boolean {\n\t\treturn !!this.childNodes.length;\n\t}\n\n\t/**\n\t * The node's children.\n\t *\n\t * Non-standard: implemented as an array rather than a NodeList.\n\t */\n\tpublic childNodes: Node[] = [];\n\n\t/**\n\t * The first child node of the current node, or null if it has no children.\n\t */\n\tpublic firstChild: Node | null = null;\n\n\t/**\n\t * The last child node of the current node, or null if it has no children.\n\t */\n\tpublic lastChild: Node | null = null;\n\n\t/**\n\t * The first preceding sibling of the current node, or null if it has none.\n\t */\n\tpublic previousSibling: Node | null = null;\n\n\t/**\n\t * The first following sibling of the current node, or null if it has none.\n\t */\n\tpublic nextSibling: Node | null = null;\n\n\t/**\n\t * The value of the node.\n\t */\n\tpublic abstract get nodeValue(): string | null;\n\tpublic abstract set nodeValue(value: string | null);\n\n\t/**\n\t * The textContent of the node.\n\t */\n\tpublic abstract get textContent(): string | null;\n\tpublic abstract set textContent(value: string | null);\n\n\t/**\n\t * (non-standard)\n\t * Each node has a registered observer list of zero or more registered observers, which is\n\t * initially empty.\n\t */\n\tpublic _registeredObservers: RegisteredObservers = new RegisteredObservers(this);\n\n\t/**\n\t * Puts the specified node and all of its subtree into a \"normalized\" form. In a normalized\n\t * subtree, no text nodes in the subtree are empty and there are no adjacent text nodes.\n\t */\n\tpublic normalize(): void {\n\t\t// for each descendant exclusive Text node node of this:\n\t\tlet node = this.firstChild;\n\t\tlet index = 0;\n\t\tconst document = getNodeDocument(this);\n\t\twhile (node) {\n\t\t\tlet nextNode = node.nextSibling;\n\t\t\tif (!isNodeOfType(node, NodeType.TEXT_NODE)) {\n\t\t\t\t// Process descendants\n\t\t\t\tnode.normalize();\n\t\t\t\tnode = nextNode;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst textNode = node as Text;\n\t\t\t// 1. Let length be node’s length.\n\t\t\tlet length = textNode.length;\n\n\t\t\t// 2. If length is zero, then remove node and continue with the next exclusive Text\n\t\t\t// node, if any.\n\t\t\tif (length === 0) {\n\t\t\t\tremoveNode(node);\n\t\t\t\t--index;\n\t\t\t\tnode = nextNode;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// 3. Let data be the concatenation of the data of node’s contiguous exclusive Text\n\t\t\t// nodes (excluding itself), in tree order.\n\t\t\tlet data = '';\n\t\t\tconst siblingsToRemove = [];\n\t\t\tfor (\n\t\t\t\tlet sibling = textNode.nextSibling;\n\t\t\t\tsibling && isNodeOfType(sibling, NodeType.TEXT_NODE);\n\t\t\t\tsibling = sibling.nextSibling\n\t\t\t) {\n\t\t\t\tdata += (sibling as Text).data;\n\t\t\t\tsiblingsToRemove.push(sibling);\n\t\t\t}\n\n\t\t\t// 4. Replace data with node node, offset length, count 0, and data data.\n\t\t\tif (data) {\n\t\t\t\ttextNode.replaceData(length, 0, data);\n\t\t\t}\n\n\t\t\t// 5. Let currentNode be node’s next sibling.\n\t\t\t// 6. While currentNode is an exclusive Text node:\n\t\t\tconst context = getContext(this);\n\t\t\tfor (let i = 0, l = siblingsToRemove.length; i < l; ++i) {\n\t\t\t\tconst currentNode = siblingsToRemove[i];\n\t\t\t\tconst currentNodeIndex = index + i + 1;\n\n\t\t\t\tcontext.forEachRange((range) => {\n\t\t\t\t\t// 6.1. For each live range whose start node is currentNode, add length to its\n\t\t\t\t\t// start offset and set its start node to node.\n\t\t\t\t\tif (range.startContainer === currentNode) {\n\t\t\t\t\t\trange.startOffset += length;\n\t\t\t\t\t\trange.startContainer = textNode;\n\t\t\t\t\t}\n\n\t\t\t\t\t// 6.2. For each live range whose end node is currentNode, add length to its end\n\t\t\t\t\t// offset and set its end node to node.\n\t\t\t\t\tif (range.endContainer === currentNode) {\n\t\t\t\t\t\trange.endOffset += length;\n\t\t\t\t\t\trange.endContainer = textNode;\n\t\t\t\t\t}\n\n\t\t\t\t\t// 6.3. For each live range whose start node is currentNode’s parent and start\n\t\t\t\t\t// offset is currentNode’s index, set its start node to node and its start\n\t\t\t\t\t// offset to length.\n\t\t\t\t\tif (range.startContainer === this && range.startOffset === currentNodeIndex) {\n\t\t\t\t\t\trange.startContainer = textNode;\n\t\t\t\t\t\trange.startOffset = length;\n\t\t\t\t\t}\n\n\t\t\t\t\t// 6.4. For each live range whose end node is currentNode’s parent and end\n\t\t\t\t\t// offset is currentNode’s index, set its end node to node and its end offset to\n\t\t\t\t\t// length.\n\t\t\t\t\tif (range.endContainer === this && range.endOffset === currentNodeIndex) {\n\t\t\t\t\t\trange.endContainer = textNode;\n\t\t\t\t\t\trange.endOffset = length;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// 6.5. Add currentNode’s length to length.\n\t\t\t\tlength += (currentNode as Text).length;\n\n\t\t\t\t// 6.6. Set currentNode to its next sibling.\n\t\t\t\t// (see for-loop increment)\n\t\t\t}\n\n\t\t\t// 7. Remove node’s contiguous exclusive Text nodes (excluding itself), in tree order.\n\t\t\twhile (siblingsToRemove.length) {\n\t\t\t\tremoveNode(siblingsToRemove.shift() as Node);\n\t\t\t}\n\n\t\t\t// Move to next node\n\t\t\tnode = node.nextSibling;\n\t\t\t++index;\n\t\t}\n\t}\n\n\t/**\n\t * Returns a copy of the current node.\n\t *\n\t * @param deep - Whether to also clone the node's descendants\n\t *\n\t * @returns A copy of the current node\n\t */\n\tpublic cloneNode(deep: boolean = false): this {\n\t\treturn cloneNode(this, deep);\n\t}\n\n\tstatic DOCUMENT_POSITION_DISCONNECTED = 0x1;\n\tstatic DOCUMENT_POSITION_PRECEDING = 0x2;\n\tstatic DOCUMENT_POSITION_FOLLOWING = 0x4;\n\tstatic DOCUMENT_POSITION_CONTAINS = 0x8;\n\tstatic DOCUMENT_POSITION_CONTAINED_BY = 0x10;\n\tstatic DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;\n\n\t/**\n\t * Compare the position of this node with the given one.\n\t *\n\t * @param other - Node to compare with\n\t *\n\t * @returns a combination of the DOCUMENT_POSITION_* flags\n\t */\n\tpublic compareDocumentPosition(other: Node): number {\n\t\texpectArity(arguments, 1);\n\t\tother = asObject(other, Node);\n\n\t\t// 1. If this is other, then return zero.\n\t\tif (this === other) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// 2. Let node1 be other and node2 be this.\n\t\tlet node1: Node | null = other;\n\t\tlet node2: Node | null = this;\n\n\t\t// 3. Let attr1 and attr2 be null.\n\t\tlet attr1: Attr | null = null;\n\t\tlet attr2: Attr | null = null;\n\n\t\t// 4. If node1 is an attribute, then set attr1 to node1 and node1 to attr1's element.\n\t\tif (isAttrNode(node1)) {\n\t\t\tattr1 = node1;\n\t\t\tnode1 = attr1.ownerElement;\n\t\t}\n\n\t\t// 5. If node2 is an attribute, then:\n\t\tif (isAttrNode(node2)) {\n\t\t\t// 5.1. Set attr2 to node2 and node2 to attr2's element.\n\t\t\tattr2 = node2;\n\t\t\tnode2 = attr2.ownerElement;\n\n\t\t\t// 5.2. If attr1 and node1 are non-null, and node2 is node1, then:\n\t\t\tif (attr1 !== null && node1 !== null && node2 === node1) {\n\t\t\t\t// 5.2.1. For each attr in node2’s attribute list:\n\t\t\t\tfor (const attr of (node2 as Element).attributes) {\n\t\t\t\t\t// 5.2.1.1. If attr equals attr1, then return the result of adding\n\t\t\t\t\t// DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC and DOCUMENT_POSITION_PRECEDING.\n\t\t\t\t\tif (attr === attr1) {\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\tNode.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |\n\t\t\t\t\t\t\tNode.DOCUMENT_POSITION_PRECEDING\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\t// 5.2.1.2. If attr equals attr2, then return the result of adding\n\t\t\t\t\t// DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC and DOCUMENT_POSITION_FOLLOWING.\n\t\t\t\t\tif (attr === attr2) {\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\tNode.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |\n\t\t\t\t\t\t\tNode.DOCUMENT_POSITION_FOLLOWING\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 6. If node1 or node2 is null, or node1's root is not node2's root, then return the result\n\t\t// of adding DOCUMENT_POSITION_DISCONNECTED, DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and\n\t\t// either DOCUMENT_POSITION_PRECEDING or DOCUMENT_POSITION_FOLLOWING, with the constraint\n\t\t// that this is to be consistent, together.\n\t\t// Note: Whether to return DOCUMENT_POSITION_PRECEDING or DOCUMENT_POSITION_FOLLOWING is\n\t\t// typically implemented via pointer comparison. In JavaScript implementations a cached\n\t\t// Math.random() value can be used.\n\t\tif (node1 === null || node2 === null) {\n\t\t\treturn (\n\t\t\t\tNode.DOCUMENT_POSITION_DISCONNECTED |\n\t\t\t\tNode.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |\n\t\t\t\t(getOrderKey(node1 || attr1!) > getOrderKey(node2 || attr2!)\n\t\t\t\t\t? Node.DOCUMENT_POSITION_FOLLOWING\n\t\t\t\t\t: Node.DOCUMENT_POSITION_PRECEDING)\n\t\t\t);\n\t\t}\n\t\tconst ancestors1 = getInclusiveAncestors(node1);\n\t\tconst ancestors2 = getInclusiveAncestors(node2);\n\t\tif (ancestors1[0] !== ancestors2[0]) {\n\t\t\treturn (\n\t\t\t\tNode.DOCUMENT_POSITION_DISCONNECTED |\n\t\t\t\tNode.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |\n\t\t\t\t(getOrderKey(ancestors1[0]) > getOrderKey(ancestors2[0])\n\t\t\t\t\t? Node.DOCUMENT_POSITION_FOLLOWING\n\t\t\t\t\t: Node.DOCUMENT_POSITION_PRECEDING)\n\t\t\t);\n\t\t}\n\n\t\t// 7. If node1 is an ancestor of node2 and attr1 is null, or node1 is node2 and attr2 is\n\t\t// non-null, then return the result of adding DOCUMENT_POSITION_CONTAINS to\n\t\t// DOCUMENT_POSITION_PRECEDING.\n\t\tlet firstDistinctAncestorIndex = 0;\n\t\twhile (\n\t\t\tfirstDistinctAncestorIndex < ancestors1.length &&\n\t\t\tfirstDistinctAncestorIndex < ancestors2.length\n\t\t) {\n\t\t\tif (ancestors1[firstDistinctAncestorIndex] !== ancestors2[firstDistinctAncestorIndex]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++firstDistinctAncestorIndex;\n\t\t}\n\t\tconst node1ContainsNode2 =\n\t\t\tnode1 !== node2 && firstDistinctAncestorIndex === ancestors1.length;\n\t\tconst node2ContainsNode1 =\n\t\t\tnode1 !== node2 && firstDistinctAncestorIndex === ancestors2.length;\n\t\tif ((node1ContainsNode2 && attr1 === null) || (node1 === node2 && attr2 !== null)) {\n\t\t\treturn Node.DOCUMENT_POSITION_CONTAINS | Node.DOCUMENT_POSITION_PRECEDING;\n\t\t}\n\n\t\t// 8. If node1 is a descendant of node2 and attr2 is null, or node1 is node2 and attr1 is\n\t\t// non-null, then return the result of adding DOCUMENT_POSITION_CONTAINED_BY to\n\t\t// DOCUMENT_POSITION_FOLLOWING.\n\t\tif ((node2ContainsNode1 && attr2 === null) || (node1 === node2 && attr1 !== null)) {\n\t\t\treturn Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_FOLLOWING;\n\t\t}\n\n\t\t// 9. If node1 is preceding node2, then return DOCUMENT_POSITION_PRECEDING.\n\t\t// Note: Due to the way attributes are handled in this algorithm this results in a node's\n\t\t// attributes counting as preceding that node's children, despite attributes not\n\t\t// participating in the same tree.\n\t\tif (\n\t\t\tnode1ContainsNode2 ||\n\t\t\tgetNodeIndex(ancestors1[firstDistinctAncestorIndex]) <\n\t\t\t\tgetNodeIndex(ancestors2[firstDistinctAncestorIndex])\n\t\t) {\n\t\t\treturn Node.DOCUMENT_POSITION_PRECEDING;\n\t\t}\n\n\t\t// 10. Return DOCUMENT_POSITION_FOLLOWING.\n\t\treturn Node.DOCUMENT_POSITION_FOLLOWING;\n\t}\n\n\t/**\n\t * Returns true if other is an inclusive descendant of this, and false otherwise\n\t * (including when other is null).\n\t *\n\t * @param childNode - Node to check\n\t *\n\t * @returns Whether childNode is an inclusive descendant of the current node\n\t */\n\tpublic contains(other: Node | null): boolean {\n\t\texpectArity(arguments, 1);\n\t\tother = asNullableObject(other, Node);\n\n\t\twhile (other && other != this) {\n\t\t\tother = other.parentNode;\n\t\t}\n\t\treturn other === this;\n\t}\n\n\t/**\n\t *\n\t *\n\t * @param namespace - The namespace to look up\n\t *\n\t * @returns The prefix for the given namespace, or null if none was found\n\t */\n\tpublic abstract lookupPrefix(namespace: string | null): string | null;\n\n\t/**\n\t * Returns the namespace for the given prefix.\n\t *\n\t * @param prefix - The prefix to look up\n\t *\n\t * @returns The namespace for the given prefix, or null if the prefix is not defined\n\t */\n\tpublic abstract lookupNamespaceURI(prefix: string | null): string | null;\n\n\t/**\n\t * Return true if defaultNamespace is the same as namespace, and false otherwise.\n\t *\n\t * @param namespace - The namespace to check\n\t *\n\t * @returns Whether namespace is the default namespace\n\t */\n\tpublic isDefaultNamespace(namespace: string | null): boolean {\n\t\texpectArity(arguments, 1);\n\t\tnamespace = asNullableString(namespace);\n\n\t\t// 1. If namespace is the empty string, then set it to null.\n\t\tif (namespace === '') {\n\t\t\tnamespace = null;\n\t\t}\n\n\t\t// 2. Let defaultNamespace be the result of running locate a namespace for this\n\t\t// using null.\n\t\tconst defaultNamespace = this.lookupNamespaceURI(null);\n\n\t\t// 3. Return true if defaultNamespace is the same as namespace, and false otherwise.\n\t\treturn defaultNamespace === namespace;\n\t}\n\n\t/**\n\t * Inserts the specified node before child within this.\n\t *\n\t * If child is null, the new node is appended after the last child node of the current node.\n\t *\n\t * @param node  - Node to insert\n\t * @param child - Childnode of the current node before which to insert, or null to append\n\t *                newNode at the end\n\t *\n\t * @returns The node that was inserted\n\t */\n\tpublic insertBefore<TNode extends Node>(node: TNode, child: Node | null): TNode {\n\t\texpectArity(arguments, 2);\n\t\tnode = asObject(node, Node);\n\t\tchild = asNullableObject(child, Node);\n\n\t\treturn preInsertNode(node, this, child);\n\t}\n\n\t/**\n\t * Adds node to the end of the list of children of this.\n\t *\n\t * If the node already exists it is removed from its current parent node, then added.\n\t *\n\t * @param node - Node to append\n\t *\n\t * @returns The node that was inserted\n\t */\n\tpublic appendChild<TNode extends Node>(node: TNode): TNode {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\treturn appendNode(node, this);\n\t}\n\n\t/**\n\t * Replaces child with node within this and returns child.\n\t *\n\t * @param node  - Node to insert\n\t * @param child - Node to remove\n\t *\n\t * @returns The node that was removed\n\t */\n\tpublic replaceChild<TChild extends Node>(node: Node, child: TChild): TChild {\n\t\texpectArity(arguments, 2);\n\t\tnode = asObject(node, Node);\n\t\tchild = asObject(child, Node);\n\n\t\treturn replaceChildWithNode(child, node, this);\n\t}\n\n\t/**\n\t * Removes child from this and returns the removed node.\n\t *\n\t * @param child - Child of the current node to remove\n\t *\n\t * @returns The node that was removed\n\t */\n\tpublic removeChild<TChild extends Node>(child: TChild): TChild {\n\t\texpectArity(arguments, 1);\n\t\tchild = asObject(child, Node);\n\n\t\treturn preRemoveChild(child, this);\n\t}\n\n\t/**\n\t * (non-standard) Creates a copy of this, not including its children.\n\t *\n\t * @param document - The node document to associate with the copy\n\t *\n\t * @returns A shallow copy of this\n\t */\n\tpublic abstract _copy(document: Document): Node;\n}\n\nNode.prototype.ELEMENT_NODE = NodeType.ELEMENT_NODE;\nNode.prototype.ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE;\nNode.prototype.TEXT_NODE = NodeType.TEXT_NODE;\nNode.prototype.CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE;\nNode.prototype.ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE; // legacy\nNode.prototype.ENTITY_NODE = NodeType.ENTITY_NODE; // legacy\nNode.prototype.PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE;\nNode.prototype.COMMENT_NODE = NodeType.COMMENT_NODE;\nNode.prototype.DOCUMENT_NODE = NodeType.DOCUMENT_NODE;\nNode.prototype.DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE;\nNode.prototype.DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE;\nNode.prototype.NOTATION_NODE = NodeType.NOTATION_NODE; // legacy\n","import Attr from '../Attr';\nimport Element from '../Element';\nimport queueMutationRecord from '../mutation-observer/queueMutationRecord';\n\n/**\n * To handle attribute changes for an attribute attribute with element, oldValue, and newValue, run\n * these steps:\n *\n * @param attribute - The attribute that is being changed\n * @param element   - The element that has the attribute\n * @param oldValue  - The old value for the attribute\n * @param newValue  - The new value for the attribute\n */\nexport function handleAttributeChanges(\n\tattribute: Attr,\n\telement: Element,\n\toldValue: string | null,\n\tnewValue: string | null\n): void {\n\t// 1. Queue a mutation record of \"attributes\" for element with attribute’s local name,\n\t// attribute's namespace, oldValue, « », « », null, and null.\n\tqueueMutationRecord('attributes', element, {\n\t\tname: attribute.localName,\n\t\tnamespace: attribute.namespaceURI,\n\t\toldValue,\n\t});\n\n\t// 2. If element is custom, then enqueue a custom element callback reaction with element,\n\t// callback name \"attributeChangedCallback\", and an argument list containing attribute’s local\n\t// name, attribute’s value, value, and attribute’s namespace.\n\t// (custom elements not implemented)\n\n\t// 3. Run the attribute change steps with element, attribute’s local name, oldValue, newValue,\n\t// and attribute’s namespace.\n\t// (attribute change steps not implemented)\n}\n\n/**\n * To change an attribute attribute to value, run these steps:\n *\n * @param attribute - The attribute to change\n * @param value     - The new value for the attribute\n */\nexport function changeAttribute(attribute: Attr, value: string): void {\n\t// 1. Handle attribute changes for attribute with attribute’s element, attribute’s value, and\n\t// value.\n\thandleAttributeChanges(attribute, attribute.ownerElement!, attribute.value, value);\n\n\t// 2. Set attribute’s value to value.\n\t(attribute as any)._value = value;\n}\n\n/**\n * To append an attribute attribute to an element element, run these steps:\n *\n * @param attribute         - The attribute to append\n * @param element           - The element to append attribute to\n * @param suppressObservers - Set to true to not queue a mutation observer event for this change\n */\nexport function appendAttribute(\n\tattribute: Attr,\n\telement: Element,\n\tsuppressObservers: boolean = false\n): void {\n\t// 1. Handle attribute changes for attribute with element, null and attribute's value.\n\tif (!suppressObservers) {\n\t\thandleAttributeChanges(attribute, element, null, attribute.value);\n\t}\n\n\t// 2. Append attribute to element’s attribute list.\n\telement.attributes.push(attribute);\n\n\t// 3. Set attribute’s element to element.\n\tattribute.ownerElement = element;\n}\n\n/**\n * To remove an attribute attribute, run these steps:\n *\n * @param attribute - The attribute to remove\n */\nexport function removeAttribute(attribute: Attr): void {\n\tconst attributeElement = attribute.ownerElement!;\n\t// 1. Handle attribute changes for attribute with attribute’s element, attribute’s value, and\n\t// null.\n\thandleAttributeChanges(attribute, attributeElement, attribute.value, null);\n\n\t// 2. Remove attribute from attribute's element’s attribute list.\n\tattributeElement.attributes.splice(attributeElement.attributes.indexOf(attribute), 1);\n\n\t// 3. Set attribute’s element to null.\n\tattribute.ownerElement = null;\n}\n\n/**\n * To replace an attribute oldAttr with an attribute newAttr, run these steps:\n *\n * @param oldAttr - The attribute to replace\n * @param newAttr - The attribute to replace oldAttr with\n */\nexport function replaceAttribute(oldAttr: Attr, newAttr: Attr): void {\n\tconst oldAttrElement = oldAttr.ownerElement!;\n\t// 1. Handle attribute changes for oldAttr with oldAttr’s element, oldAttr’s value,\n\t// and newAttr’s value.\n\thandleAttributeChanges(oldAttr, oldAttrElement, oldAttr.value, newAttr.value);\n\n\t// 4. Replace oldAttr by newAttr in element’s attribute list.\n\toldAttrElement.attributes.splice(oldAttrElement.attributes.indexOf(oldAttr), 1, newAttr);\n\n\t// 5. Set newAttr’s element to oldAttr's element.\n\tnewAttr.ownerElement = oldAttrElement;\n\n\t// 6. Set oldAttr’s element to null.\n\toldAttr.ownerElement = null;\n}\n","import Document from './Document';\nimport Element from './Element';\nimport Node from './Node';\nimport { getContext } from './context/Context';\nimport { changeAttribute } from './util/attrMutations';\nimport { expectArity } from './util/errorHelpers';\nimport { NodeType } from './util/NodeType';\nimport { ifNullActAsIfEmptyString } from './util/typeHelpers';\n\n/**\n * 3.9.2. Interface Attr\n *\n * @public\n */\nexport default class Attr extends Node {\n\t// Node\n\n\tpublic get nodeType(): number {\n\t\treturn NodeType.ATTRIBUTE_NODE;\n\t}\n\n\tpublic get nodeName(): string {\n\t\t// Return the qualified name\n\t\treturn this.name;\n\t}\n\n\tpublic get nodeValue(): string | null {\n\t\treturn this._value;\n\t}\n\n\tpublic set nodeValue(newValue: string | null) {\n\t\tnewValue = ifNullActAsIfEmptyString(newValue);\n\n\t\t// Set an existing attribute value with this and new value.\n\t\tsetExistingAttributeValue(this, newValue);\n\t}\n\n\tpublic get textContent(): string | null {\n\t\treturn this._value;\n\t}\n\n\tpublic set textContent(newValue: string | null) {\n\t\tnewValue = ifNullActAsIfEmptyString(newValue);\n\n\t\t// Set an existing attribute value with this and new value.\n\t\tsetExistingAttributeValue(this, newValue);\n\t}\n\n\tpublic lookupPrefix(namespace: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\n\t\t// 1. If namespace is null or the empty string, then return null.\n\t\t// (not necessary due to recursion)\n\n\t\t// 2. Switch on this:\n\t\t// Attr - Return the result of locating a namespace prefix for its element, if its element\n\t\t// is non-null, and null otherwise.\n\t\tif (this.ownerElement !== null) {\n\t\t\treturn this.ownerElement.lookupPrefix(namespace);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic lookupNamespaceURI(prefix: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\n\t\t// 1. If prefix is the empty string, then set it to null.\n\t\t// (not necessary due to recursion)\n\n\t\t// 2. Return the result of running locate a namespace for this using prefix.\n\n\t\t// To locate a namespace for a node using prefix, switch on node: Attr\n\t\t// 1. If its element is null, then return null.\n\t\tif (this.ownerElement === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// 2. Return the result of running locate a namespace on its element using prefix.\n\t\treturn this.ownerElement.lookupNamespaceURI(prefix);\n\t}\n\n\t// Attr\n\n\tpublic readonly namespaceURI: string | null;\n\tpublic readonly prefix: string | null;\n\tpublic readonly localName: string;\n\tpublic readonly name: string;\n\n\tprivate _value: string;\n\n\tpublic get value(): string {\n\t\treturn this._value;\n\t}\n\n\tpublic set value(value: string) {\n\t\tsetExistingAttributeValue(this, value);\n\t}\n\n\tpublic ownerElement: Element | null;\n\n\t/**\n\t * (non-standard) use Document#createAttribute(NS) or Element#setAttribute(NS) to create\n\t * attribute nodes\n\t *\n\t * @param namespace - The namespace URI for the attribute\n\t * @param prefix    - The prefix for the attribute\n\t * @param localName - The local name for the attribute\n\t * @param value     - The value for the attribute\n\t * @param element   - The element for the attribute, or null if the attribute is not attached to\n\t *                    an element\n\t */\n\tconstructor(\n\t\tnamespace: string | null,\n\t\tprefix: string | null,\n\t\tlocalName: string,\n\t\tvalue: string,\n\t\telement: Element | null\n\t) {\n\t\tsuper();\n\n\t\tthis.namespaceURI = namespace;\n\t\tthis.prefix = prefix;\n\t\tthis.localName = localName;\n\t\tthis.name = prefix === null ? localName : `${prefix}:${localName}`;\n\t\tthis._value = value;\n\t\tthis.ownerElement = element;\n\t\tthis.ownerDocument = element ? element.ownerDocument : getContext(this).document;\n\t}\n\n\t/**\n\t * (non-standard) Creates a copy of this, not including its children.\n\t *\n\t * @param document - The node document to associate with the copy\n\t *\n\t * @returns A shallow copy of this\n\t */\n\tpublic _copy(document: Document): Attr {\n\t\t// Set copy’s namespace, namespace prefix, local name, and value, to those of node.\n\t\tconst context = getContext(document);\n\t\tconst copy = new context.Attr(\n\t\t\tthis.namespaceURI,\n\t\t\tthis.prefix,\n\t\t\tthis.localName,\n\t\t\tthis.value,\n\t\t\tnull\n\t\t);\n\t\tcopy.ownerDocument = document;\n\t\treturn copy;\n\t}\n}\n\n/**\n * To set an existing attribute value, given an attribute attribute and string value, run these\n * steps:\n *\n * @param attribute - The attribute to set the value of\n * @param value     - The new value for attribute\n */\nfunction setExistingAttributeValue(attribute: Attr, value: string) {\n\tvalue = String(value);\n\n\t// 1. If attribute’s element is null, then set attribute’s value to value.\n\tconst element = attribute.ownerElement;\n\tif (element === null) {\n\t\t(attribute as any)._value = value;\n\t} else {\n\t\t// 2. Otherwise, change attribute to value.\n\t\tchangeAttribute(attribute, value);\n\t}\n}\n","import {\n\tNonDocumentTypeChildNode,\n\tChildNode,\n\tgetNextElementSibling,\n\tgetPreviousElementSibling,\n} from './mixins';\nimport Element from './Element';\nimport Node from './Node';\nimport { getContext } from './context/Context';\nimport queueMutationRecord from './mutation-observer/queueMutationRecord';\nimport { expectArity, throwIndexSizeError } from './util/errorHelpers';\nimport {\n\tasUnsignedLong,\n\tifNullActAsIfEmptyString,\n\tlegacyNullToEmptyString,\n} from './util/typeHelpers';\nimport {\n\tinsertNodesBefore,\n\tinsertNodesAfter,\n\treplaceWithNodes,\n\tremoveFromParent,\n} from './util/mutationAlgorithms';\n\n/**\n * 3.10. Interface CharacterData\n *\n * @public\n */\nexport default abstract class CharacterData\n\textends Node\n\timplements NonDocumentTypeChildNode, ChildNode\n{\n\t// Node\n\n\tpublic get nodeValue(): string | null {\n\t\treturn this._data;\n\t}\n\n\tpublic set nodeValue(newValue: string | null) {\n\t\tnewValue = ifNullActAsIfEmptyString(newValue);\n\n\t\t// Set an existing attribute value with this and new value.\n\t\treplaceData(this, 0, this.length, newValue);\n\t}\n\n\tpublic get textContent(): string | null {\n\t\treturn this._data;\n\t}\n\n\tpublic set textContent(newValue: string | null) {\n\t\tnewValue = ifNullActAsIfEmptyString(newValue);\n\n\t\t// Set an existing attribute value with this and new value.\n\t\treplaceData(this, 0, this.length, newValue);\n\t}\n\n\tpublic lookupPrefix(namespace: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\n\t\t// 1. If namespace is null or the empty string, then return null.\n\t\t// (not necessary due to recursion)\n\n\t\t// 2. Switch on this:\n\t\t// Any other node - Return the result of locating a namespace prefix for its parent element,\n\t\t// if its parent element is non-null, and null otherwise.\n\t\tconst parentElement = this.parentElement;\n\t\tif (parentElement !== null) {\n\t\t\treturn parentElement.lookupPrefix(namespace);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic lookupNamespaceURI(prefix: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\n\t\t// 1. If prefix is the empty string, then set it to null.\n\t\t// (not necessary due to recursion)\n\n\t\t// 2. Return the result of running locate a namespace for this using prefix.\n\n\t\t// To locate a namespace for a node using prefix, switch on node: Any other node\n\t\t// 1. If its parent element is null, then return null.\n\t\tconst parentElement = this.parentElement;\n\t\tif (parentElement === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// 2. Return the result of running locate a namespace on its parent element using prefix.\n\t\treturn parentElement.lookupNamespaceURI(prefix);\n\t}\n\n\t// ChildNode\n\n\tpublic before(...nodes: (Node | string)[]): void {\n\t\tinsertNodesBefore(this, nodes);\n\t}\n\n\tpublic after(...nodes: (Node | string)[]): void {\n\t\tinsertNodesAfter(this, nodes);\n\t}\n\n\tpublic replaceWith(...nodes: (Node | string)[]): void {\n\t\treplaceWithNodes(this, nodes);\n\t}\n\n\tpublic remove(): void {\n\t\tremoveFromParent(this);\n\t}\n\n\t// NonDocumentTypeChildNode\n\n\tpublic get previousElementSibling(): Element | null {\n\t\treturn getPreviousElementSibling(this);\n\t}\n\n\tpublic get nextElementSibling(): Element | null {\n\t\treturn getNextElementSibling(this);\n\t}\n\n\t// CharacterData\n\n\t/**\n\t * Each node inheriting from the CharacterData interface has an associated mutable string called\n\t * data.\n\t */\n\tprotected _data: string;\n\n\tpublic get data(): string {\n\t\treturn this._data;\n\t}\n\n\tpublic set data(newValue: string) {\n\t\t// [LegacyNullToEmptyString]\n\t\tnewValue = legacyNullToEmptyString(newValue);\n\n\t\t// replace data with node this, offset 0, count this’s length, and data\n\t\t// new value.\n\t\treplaceData(this, 0, this.length, newValue);\n\t}\n\n\tpublic get length(): number {\n\t\treturn this.data.length;\n\t}\n\n\t/**\n\t * (non-standard) CharacterData should never be instantiated directly.\n\t *\n\t * @param data - The data to associate with the node\n\t */\n\tprotected constructor(data: string) {\n\t\tsuper();\n\t\tthis._data = String(data);\n\t}\n\n\t/**\n\t * Returns a substring of the node's data.\n\t *\n\t * @param offset - Offset at which to start the substring\n\t * @param count  - The number of code units to return\n\t *\n\t * @returns The specified substring\n\t */\n\tpublic substringData(offset: number, count: number): string {\n\t\texpectArity(arguments, 2);\n\t\treturn substringData(this, offset, count);\n\t}\n\n\t/**\n\t * Appends data to the node's data.\n\t *\n\t * @param data - Data to append\n\t */\n\tpublic appendData(data: string): void {\n\t\texpectArity(arguments, 1);\n\t\treplaceData(this, this.length, 0, data);\n\t}\n\n\t/**\n\t * Inserts data at the specified position in the node's data.\n\t *\n\t * @param offset - Offset at which to insert\n\t * @param data   - Data to insert\n\t */\n\tpublic insertData(offset: number, data: string): void {\n\t\texpectArity(arguments, 1);\n\t\treplaceData(this, offset, 0, data);\n\t}\n\n\t/**\n\t * Deletes data from the specified position.\n\t *\n\t * @param offset - Offset at which to delete\n\t * @param count  - Number of code units to delete\n\t */\n\tpublic deleteData(offset: number, count: number): void {\n\t\texpectArity(arguments, 2);\n\t\treplaceData(this, offset, count, '');\n\t}\n\n\t/**\n\t * Replaces data at the specified position.\n\t *\n\t * @param offset - Offset at which to replace\n\t * @param count  - Number of code units to remove\n\t * @param data   - Data to insert\n\t */\n\tpublic replaceData(offset: number, count: number, data: string): void {\n\t\texpectArity(arguments, 3);\n\t\treplaceData(this, offset, count, data);\n\t}\n}\n\n/**\n * To replace data of node node with offset offset, count count, and data data, run these steps:\n *\n * @param node   - The node to replace data on\n * @param offset - The offset at which to start replacing\n * @param count  - The number of code units to replace\n * @param data   - The data to insert in place of the removed data\n */\nexport function replaceData(\n\tnode: CharacterData,\n\toffset: number,\n\tcount: number,\n\tdata: string\n): void {\n\t// Match spec data types\n\toffset = asUnsignedLong(offset);\n\tcount = asUnsignedLong(count);\n\n\t// 1. Let length be node’s length.\n\tconst length = node.length;\n\n\t// 2. If offset is greater than length, then throw an IndexSizeError.\n\tif (offset > length) {\n\t\tthrowIndexSizeError(\"can not replace data past the node's length\");\n\t}\n\n\t// 3. If offset plus count is greater than length, then set count to length minus offset.\n\tif (offset + count > length) {\n\t\tcount = length - offset;\n\t}\n\n\t// 4. Queue a mutation record of \"characterData\" for node with null, null, node's data, « »,\n\t// « », null, and null.\n\tqueueMutationRecord('characterData', node, {\n\t\toldValue: node.data,\n\t});\n\n\t// 5. Insert data into node’s data after offset code units.\n\t// 6. Let delete offset be offset + data's length.\n\t// 7. Starting from delete offset code units, remove count code units from node’s data.\n\tconst nodeData = node.data;\n\tconst newData = nodeData.substring(0, offset) + data + nodeData.substring(offset + count);\n\t(node as any)._data = newData;\n\n\tconst context = getContext(node);\n\tcontext.forEachRange((range) => {\n\t\t// 8. For each live range whose start node is node and start offset is greater than offset\n\t\t// but less than or equal to offset plus count, set its start offset to offset.\n\t\tif (\n\t\t\trange.startContainer === node &&\n\t\t\trange.startOffset > offset &&\n\t\t\trange.startOffset <= offset + count\n\t\t) {\n\t\t\trange.startOffset = offset;\n\t\t}\n\n\t\t// 9. For each live range whose end node is node and end offset is greater than offset but\n\t\t// less than or equal to offset plus count, set its end offset to offset.\n\t\tif (\n\t\t\trange.endContainer === node &&\n\t\t\trange.endOffset > offset &&\n\t\t\trange.endOffset <= offset + count\n\t\t) {\n\t\t\trange.endOffset = offset;\n\t\t}\n\n\t\t// 10. For each live range whose start node is node and start offset is greater than offset\n\t\t// plus count, increase its start offset by data's length and decrease it by count.\n\t\tif (range.startContainer === node && range.startOffset > offset + count) {\n\t\t\trange.startOffset = range.startOffset + data.length - count;\n\t\t}\n\n\t\t// 11. For each live range whose end node is node and end offset is greater than offset plus\n\t\t// count, increase its end offset by data's length and decrease it by count.\n\t\tif (range.endContainer === node && range.endOffset > offset + count) {\n\t\t\trange.endOffset = range.endOffset + data.length - count;\n\t\t}\n\t});\n\n\t// 12. If node's parent is non-null, then run the children changed steps for node’s parent.\n\t// (children changed steps not implemented)\n}\n\n/**\n * To substring data with node node, offset offset, and count count, run these steps:\n *\n * @param node   - The node to get data from\n * @param offset - The offset at which to start the substring\n * @param count  - The number of code units to include in the substring\n *\n * @returns The requested substring\n */\nexport function substringData(node: CharacterData, offset: number, count: number): string {\n\t// Match spec data types\n\toffset = asUnsignedLong(offset);\n\tcount = asUnsignedLong(count);\n\n\t// 1. Let length be node’s length.\n\tconst length = node.length;\n\n\t// 2. If offset is greater than length, then throw an IndexSizeError.\n\tif (offset > length) {\n\t\tthrowIndexSizeError(\"can not substring data past the node's length\");\n\t}\n\n\t// 3. If offset plus count is greater than length, return a string whose value is the code units\n\t// from the offsetth code unit to the end of node’s data, and then return.\n\tif (offset + count > length) {\n\t\treturn node.data.substring(offset);\n\t}\n\n\t// 4. Return a string whose value is the code units from the offsetth code unit to the\n\t// offset+countth code unit in node’s data.\n\treturn node.data.substring(offset, offset + count);\n}\n","import { replaceData, substringData, default as CharacterData } from './CharacterData';\nimport Document from './Document';\nimport { getContext } from './context/Context';\nimport { expectArity, throwIndexSizeError } from './util/errorHelpers';\nimport { insertNode } from './util/mutationAlgorithms';\nimport { NodeType, isNodeOfType } from './util/NodeType';\nimport { getNodeIndex } from './util/treeHelpers';\nimport { asUnsignedLong } from './util/typeHelpers';\n\n/**\n * 3.11. Interface Text\n *\n * @public\n */\nexport default class Text extends CharacterData {\n\t// Node\n\n\tpublic get nodeType(): number {\n\t\treturn NodeType.TEXT_NODE;\n\t}\n\n\tpublic get nodeName(): string {\n\t\treturn '#text';\n\t}\n\n\t// Text\n\n\t/**\n\t * Returns a new Text node whose data is data and node document is current global object’s\n\t * associated Document.\n\t *\n\t * @param data - The data for the new text node\n\t */\n\tconstructor(data: string = '') {\n\t\tsuper(data);\n\n\t\tconst context = getContext(this);\n\t\tthis.ownerDocument = context.document;\n\t}\n\n\t/**\n\t * Splits data at the given offset and returns the remainder as Text node.\n\t *\n\t * @param offset - The offset at which to split\n\t *\n\t * @returns a text node containing the second half of the split node's data\n\t */\n\tpublic splitText(offset: number): Text {\n\t\texpectArity(arguments, 1);\n\t\toffset = asUnsignedLong(offset);\n\n\t\treturn splitText(this, offset);\n\t}\n\n\t/**\n\t * (non-standard) Creates a copy of this, not including its children.\n\t *\n\t * @param document - The node document to associate with the copy\n\t *\n\t * @returns A shallow copy of this\n\t */\n\tpublic _copy(document: Document): Text {\n\t\t// Set copy’s data, to that of node.\n\t\tconst context = getContext(document);\n\t\tconst copy = new context.Text(this.data);\n\t\tcopy.ownerDocument = document;\n\t\treturn copy;\n\t}\n\n\t/**\n\t * Returns the combined data of all direct Text node siblings.\n\t *\n\t * @returns the concatenation of the data of the contiguous Text nodes of this, in\n\t *          tree order.\n\t */\n\tpublic get wholeText(): string {\n\t\tconst allData: string[] = [this.data];\n\n\t\tlet previousSibling = this.previousSibling;\n\t\twhile (\n\t\t\tpreviousSibling !== null &&\n\t\t\tisNodeOfType(previousSibling, NodeType.TEXT_NODE, NodeType.CDATA_SECTION_NODE)\n\t\t) {\n\t\t\tconst data = (previousSibling as Text).data;\n\t\t\tallData.unshift(data);\n\t\t\tpreviousSibling = previousSibling.previousSibling;\n\t\t}\n\n\t\tlet nextSibling = this.nextSibling;\n\t\twhile (\n\t\t\tnextSibling !== null &&\n\t\t\tisNodeOfType(nextSibling, NodeType.TEXT_NODE, NodeType.CDATA_SECTION_NODE)\n\t\t) {\n\t\t\tconst data = (nextSibling as Text).data;\n\t\t\tallData.push(data);\n\t\t\tnextSibling = nextSibling.nextSibling;\n\t\t}\n\n\t\treturn allData.join('');\n\t}\n}\n\n/**\n * To split a Text node node with offset offset, run these steps:\n *\n * @param node   - The text node to split\n * @param offset - The offset to split at\n *\n * @returns a text node containing the second half of the split node's data\n */\nfunction splitText(node: Text, offset: number): Text {\n\t// 1. Let length be node’s length.\n\tconst length = node.length;\n\n\t// 2. If offset is greater than length, then throw an IndexSizeError.\n\tif (offset > length) {\n\t\tthrowIndexSizeError(\"can not split past the node's length\");\n\t}\n\n\t// 3. Let count be length minus offset.\n\tconst count = length - offset;\n\n\t// 4. Let new data be the result of substringing data with node node, offset offset, and count\n\t// count.\n\tconst newData = substringData(node, offset, count);\n\n\t// 5. Let new node be a new Text node, with the same node document as node. Set new node’s data\n\t// to new data.\n\tconst context = getContext(node);\n\tconst newNode = new context.Text(newData);\n\tnewNode.ownerDocument = node.ownerDocument;\n\n\t// 6. Let parent be node’s parent.\n\tconst parent = node.parentNode;\n\n\t// 7. If parent is non-null, then:\n\tif (parent !== null) {\n\t\t// 7.1. Insert new node into parent before node’s next sibling.\n\t\tinsertNode(newNode, parent, node.nextSibling);\n\n\t\tconst indexOfNodePlusOne = getNodeIndex(node) + 1;\n\t\tconst context = getContext(node);\n\t\tcontext.forEachRange((range) => {\n\t\t\t// 7.2. For each live range whose start node is node and start offset is greater than\n\t\t\t// offset, set its start node to new node and decrease its start offset by offset.\n\t\t\tif (range.startContainer === node && range.startOffset > offset) {\n\t\t\t\trange.startContainer = newNode;\n\t\t\t\trange.startOffset -= offset;\n\t\t\t}\n\n\t\t\t// 7.3. For each live range whose end node is node and end offset is greater than\n\t\t\t// offset, set its end node to new node and decrease its end offset by offset.\n\t\t\tif (range.endContainer === node && range.endOffset > offset) {\n\t\t\t\trange.endContainer = newNode;\n\t\t\t\trange.endOffset -= offset;\n\t\t\t}\n\n\t\t\t// 7.4. For each live range whose start node is parent and start offset is equal to the\n\t\t\t// index of node + 1, increase its start offset by one.\n\t\t\tif (range.startContainer === parent && range.startOffset === indexOfNodePlusOne) {\n\t\t\t\trange.startOffset += 1;\n\t\t\t}\n\n\t\t\t// 7.5. For each live range whose end node is parent and end offset is equal to the\n\t\t\t// index of node + 1, increase its end offset by one.\n\t\t\tif (range.endContainer === parent && range.endOffset === indexOfNodePlusOne) {\n\t\t\t\trange.endOffset += 1;\n\t\t\t}\n\t\t});\n\t}\n\n\t// 8. Replace data with node node, offset offset, count count, and data the empty string.\n\treplaceData(node, offset, count, '');\n\n\t// 9. Return new node.\n\treturn newNode;\n}\n","import Document from './Document';\nimport Text from './Text';\nimport { getContext } from './context/Context';\nimport { NodeType } from './util/NodeType';\n\n/**\n * @public\n */\nexport default class CDATASection extends Text {\n\t// Node\n\n\tpublic get nodeType(): number {\n\t\treturn NodeType.CDATA_SECTION_NODE;\n\t}\n\n\tpublic get nodeName(): string {\n\t\treturn '#cdata-section';\n\t}\n\n\t// CDATASection\n\n\t/**\n\t * (non-standard) use Document#createCDATASection to create a CDATA section.\n\t *\n\t * @param data - The data for the node\n\t */\n\tconstructor(data: string) {\n\t\tsuper(data);\n\t}\n\n\t/**\n\t * (non-standard) Creates a copy of this, not including its children.\n\t *\n\t * @param document - The node document to associate with the copy\n\t *\n\t * @returns A shallow copy of this\n\t */\n\tpublic _copy(document: Document): CDATASection {\n\t\t// Set copy’s data, to that of node.\n\t\tconst context = getContext(document);\n\t\tconst copy = new context.CDATASection(this.data);\n\t\tcopy.ownerDocument = document;\n\t\treturn copy;\n\t}\n}\n","import CharacterData from './CharacterData';\nimport Document from './Document';\nimport { getContext } from './context/Context';\nimport { NodeType } from './util/NodeType';\n\n/**\n * @public\n */\nexport default class Comment extends CharacterData {\n\t// Node\n\n\tpublic get nodeType(): number {\n\t\treturn NodeType.COMMENT_NODE;\n\t}\n\n\tpublic get nodeName(): string {\n\t\treturn '#comment';\n\t}\n\n\t// Comment\n\n\t/**\n\t * Returns a new Comment node whose data is data and node document is current global object’s\n\t * associated Document.\n\t *\n\t * @param data - The data for the new comment\n\t */\n\tconstructor(data: string = '') {\n\t\tsuper(data);\n\n\t\tconst context = getContext(this);\n\t\tthis.ownerDocument = context.document;\n\t}\n\n\t/**\n\t * (non-standard) Creates a copy of this, not including its children.\n\t *\n\t * @param document - The node document to associate with the copy\n\t *\n\t * @returns A shallow copy of this\n\t */\n\tpublic _copy(document: Document): Comment {\n\t\t// Set copy’s data, to that of node.\n\t\tconst context = getContext(document);\n\t\tconst copy = new context.Comment(this.data);\n\t\tcopy.ownerDocument = document;\n\t\treturn copy;\n\t}\n}\n","import { ChildNode } from './mixins';\nimport Document from './Document';\nimport Node from './Node';\nimport { getContext } from './context/Context';\nimport { expectArity } from './util/errorHelpers';\nimport { NodeType } from './util/NodeType';\nimport {\n\tinsertNodesBefore,\n\tinsertNodesAfter,\n\treplaceWithNodes,\n\tremoveFromParent,\n} from './util/mutationAlgorithms';\n\n/**\n * @public\n */\nexport default class DocumentType extends Node implements ChildNode {\n\t// Node\n\n\tpublic get nodeType(): number {\n\t\treturn NodeType.DOCUMENT_TYPE_NODE;\n\t}\n\n\tpublic get nodeName(): string {\n\t\treturn this.name;\n\t}\n\n\tpublic get nodeValue(): string | null {\n\t\treturn null;\n\t}\n\n\tpublic set nodeValue(_newValue: string | null) {\n\t\t// Do nothing.\n\t}\n\n\tpublic get textContent(): string | null {\n\t\treturn null;\n\t}\n\n\tpublic set textContent(_newValue: string | null) {\n\t\t// Do nothing.\n\t}\n\n\tpublic lookupPrefix(namespace: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\n\t\t// 1. If namespace is null or the empty string, then return null.\n\t\t// (not necessary due to return value)\n\n\t\t// 2. Switch on this:\n\t\t// DocumentType - Return null\n\t\treturn null;\n\t}\n\n\tpublic lookupNamespaceURI(prefix: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\n\t\t// 1. If prefix is the empty string, then set it to null.\n\t\t// (not necessary due to return value)\n\n\t\t// 2. Return the result of running locate a namespace for this using prefix.\n\n\t\t// To locate a namespace for a node using prefix, switch on node: DocumentType\n\t\t// Return null.\n\t\treturn null;\n\t}\n\n\t// ChildNode\n\n\tpublic before(...nodes: (Node | string)[]): void {\n\t\tinsertNodesBefore(this, nodes);\n\t}\n\n\tpublic after(...nodes: (Node | string)[]): void {\n\t\tinsertNodesAfter(this, nodes);\n\t}\n\n\tpublic replaceWith(...nodes: (Node | string)[]): void {\n\t\treplaceWithNodes(this, nodes);\n\t}\n\n\tpublic remove(): void {\n\t\tremoveFromParent(this);\n\t}\n\n\t// DocumentType\n\n\t/**\n\t * The name of the doctype.\n\t */\n\tpublic name: string;\n\n\t/**\n\t * The public ID of the doctype.\n\t */\n\tpublic publicId: string;\n\n\t/**\n\t * The system ID of the doctype.\n\t */\n\tpublic systemId: string;\n\n\t/**\n\t * (non-standard) Use DOMImplementation#createDocumentType instead.\n\t *\n\t * @param name     - The name of the doctype\n\t * @param publicId - The public ID of the doctype\n\t * @param systemId - The system ID of the doctype\n\t */\n\tconstructor(name: string, publicId: string = '', systemId: string = '') {\n\t\tsuper();\n\n\t\tthis.name = name;\n\t\tthis.publicId = publicId;\n\t\tthis.systemId = systemId;\n\t}\n\n\t/**\n\t * (non-standard) Creates a copy of this, not including its children.\n\t *\n\t * @param document - The node document to associate with the copy\n\t *\n\t * @returns A shallow copy of this\n\t */\n\tpublic _copy(document: Document): DocumentType {\n\t\t// Set copy’s name, public ID, and system ID, to those of node.\n\t\tconst context = getContext(document);\n\t\tconst copy = new context.DocumentType(this.name, this.publicId, this.systemId);\n\t\tcopy.ownerDocument = document;\n\t\treturn copy;\n\t}\n}\n","import Attr from './Attr';\nimport Document from './Document';\nimport { createElement, default as Element } from './Element';\nimport { appendAttribute } from './util/attrMutations';\n\n/**\n * Create an Attr node without the usual validation of the given names.\n *\n * @public\n *\n * @param namespace - The namespace URI for the new node\n * @param prefix    - The prefix for the new node\n * @param localName - The local name for the new node\n * @param value     - The value for the new node\n * @param element   - The owner element for the new node\n *\n * @returns A new Attr node with the given values\n */\nexport function unsafeCreateAttribute(\n\tnamespace: string | null,\n\tprefix: string | null,\n\tlocalName: string,\n\tvalue: string,\n\townerElement: Element | null\n): Attr {\n\treturn new Attr(namespace, prefix, localName, value, ownerElement);\n}\n\n/**\n * Create an Element node without the usual validation of the given names.\n *\n * @public\n *\n * @param document  - The node document for the new element\n * @param localName - The local name for the new element\n * @param namespace - The namespace URI for the new element, or null for the null namespace\n * @param prefix    - The prefix for the new element, or null for no prefix\n *\n * @returns The new element\n */\nexport function unsafeCreateElement(\n\tdocument: Document,\n\tlocalName: string,\n\tnamespace: string | null,\n\tprefix: string | null = null\n): Element {\n\treturn createElement(document, localName, namespace, prefix);\n}\n\n/**\n * Append an attribute attribute to an element without the usual checks.\n *\n * @public\n *\n * @param attribute - The attribute to append\n * @param element   - The element to append attribute to\n */\nexport function unsafeAppendAttribute(attribute: Attr, element: Element): void {\n\tappendAttribute(attribute, element);\n}\n","import { matchesNameProduction } from '../dom-parsing/parsingAlgorithms';\nimport Element from '../Element';\nimport { throwInvalidCharacterError, throwNamespaceError } from './errorHelpers';\n\n// 1.5. Namespaces\n\nexport const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\nexport const XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';\nexport const XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';\n\n/**\n * @param name - The name to check\n *\n * @returns True if the name is a valid QName, provided it is also a valid Name, otherwise false\n */\nfunction isValidQName(name: string): boolean {\n\t// (QName is basically NCName | (NCName ':' NCName) where NCName is Name without ':', so here we\n\t// check that name contains at most a single colon, and that the other parts are valid Names)\n\tconst parts = name.split(':');\n\tif (parts.length > 2) {\n\t\t// Too many colons\n\t\treturn false;\n\t}\n\t// Each part should be a valid Name - we already know they don't contain ':', so a valid Name\n\t// here also means a valid NCName\n\treturn parts.every((part) => matchesNameProduction(part));\n}\n\n/**\n * To validate a qualifiedName,\n *\n * @param qualifiedName - Qualified name to validate\n */\nexport function validateQualifiedName(qualifiedName: string): void {\n\t// throw an InvalidCharacterError if qualifiedName does not match the QName production.\n\tif (!isValidQName(qualifiedName)) {\n\t\tthrowInvalidCharacterError('The qualified name is not a valid QName');\n\t}\n}\n\n/**\n * To validate and extract a namespace and qualifiedName, run these steps:\n *\n * @param namespace     - Namespace for the qualified name\n * @param qualifiedName - Qualified name to validate and extract the components of\n *\n * @returns Namespace, prefix and localName\n */\nexport function validateAndExtract(\n\tnamespace: string | null,\n\tqualifiedName: string\n): { namespace: string | null; prefix: string | null; localName: string } {\n\t// 1. If namespace is the empty string, set it to null.\n\tif (namespace === '') {\n\t\tnamespace = null;\n\t}\n\n\t// 2. Validate qualifiedName.\n\tvalidateQualifiedName(qualifiedName);\n\n\t// 3. Let prefix be null.\n\tlet prefix: string | null = null;\n\n\t// 4.  Let localName be qualifiedName.\n\tlet localName = qualifiedName;\n\n\t// 5. If qualifiedName contains a \":\" (U+003A), then split the string on it and set prefix to\n\t// the part before and localName to the part after.\n\tconst index = qualifiedName.indexOf(':');\n\tif (index >= 0) {\n\t\tprefix = qualifiedName.substring(0, index);\n\t\tlocalName = qualifiedName.substring(index + 1);\n\t}\n\n\t// 6. If prefix is non-null and namespace is null, then throw a NamespaceError.\n\tif (prefix !== null && namespace === null) {\n\t\tthrowNamespaceError('Qualified name with prefix can not have a null namespace');\n\t}\n\n\t// 7. If prefix is \"xml\" and namespace is not the XML namespace, then throw a NamespaceError.\n\tif (prefix === 'xml' && namespace !== XML_NAMESPACE) {\n\t\tthrowNamespaceError('xml prefix can only be used for the XML namespace');\n\t}\n\n\t// 8. If either qualifiedName or prefix is \"xmlns\" and namespace is not the XMLNS namespace,\n\t// then throw a NamespaceError.\n\tif ((qualifiedName === 'xmlns' || prefix === 'xmlns') && namespace !== XMLNS_NAMESPACE) {\n\t\tthrowNamespaceError('xmlns prefix or qualifiedName must use the XMLNS namespace');\n\t}\n\n\t// 9. If namespace is the XMLNS namespace and neither qualifiedName nor prefix is \"xmlns\", then\n\t// throw a NamespaceError.\n\tif (namespace === XMLNS_NAMESPACE && qualifiedName !== 'xmlns' && prefix !== 'xmlns') {\n\t\tthrowNamespaceError('xmlns prefix or qualifiedName must be used for the XMLNS namespace');\n\t}\n\n\t// 10. Return namespace, prefix, and localName.\n\treturn { namespace, prefix, localName };\n}\n\n/**\n * To locate a namespace prefix for an element using namespace, run these steps:\n *\n * @param element    - The element at which to start the lookup\n * @param namespace  - Namespace for which to look up the prefix\n *\n * @returns The prefix, or null if there isn't one\n */\nexport function locateNamespacePrefix(element: Element, namespace: string | null): string | null {\n\t// 1. If element’s namespace is namespace and its namespace prefix is non-null, then return its\n\t// namespace prefix.\n\tif (element.namespaceURI === namespace && element.prefix !== null) {\n\t\treturn element.prefix;\n\t}\n\n\t// 2. If element has an attribute whose namespace prefix is \"xmlns\" and value is namespace, then\n\t// return element’s first such attribute’s local name.\n\tconst attr = Array.from(element.attributes).find(\n\t\t(attr) => attr.prefix === 'xmlns' && attr.value === namespace\n\t);\n\tif (attr) {\n\t\treturn attr.localName;\n\t}\n\n\t// 3. If element’s parent element is non-null, then return the result of running locate a\n\t// namespace prefix on that element using namespace.\n\tif (element.parentElement !== null) {\n\t\treturn locateNamespacePrefix(element.parentElement, namespace);\n\t}\n\n\t// 4. Return null.\n\treturn null;\n}\n","import { EntityRefEvent } from './parserEvents';\nimport { throwErrorWithContext } from './parsingAlgorithms';\n\n/*\n * Guard against entity expansion attacks by keeping track of the initial input\n * length vs. the expanded input length. The latter includes the length of the\n * replacement text for each processed entity reference. An attack is likely if\n * the ratio between the two exceeds the maximum amplification factor AND the\n * expanded input length exceeds a threshold. This approach and defaults are\n * taken from libexpat's billion laughs attack protection.\n */\nexport default class EntityExpansionGuard {\n\tprivate readonly _initialInputLength: number;\n\n\tprivate _expandedInputLength: number;\n\n\tprivate readonly _entityExpansionThreshold: number;\n\n\tprivate readonly _entityExpansionMaxAmplification: number;\n\n\tprivate _topLevelEntityRef: EntityRefEvent | null = null;\n\n\tprivate _depth = 0;\n\n\tpublic constructor(\n\t\tinitialInputLength: number,\n\t\tentityExpansionThreshold: number,\n\t\tentityExpansionMaxAmplification: number\n\t) {\n\t\tthis._initialInputLength = initialInputLength;\n\t\tthis._expandedInputLength = initialInputLength;\n\t\tthis._entityExpansionThreshold = entityExpansionThreshold;\n\t\tthis._entityExpansionMaxAmplification = entityExpansionMaxAmplification;\n\t}\n\n\tpublic enter(event: EntityRefEvent, replacementTextLength: number): void {\n\t\tconst topLevelEntityRef = this._topLevelEntityRef ?? event;\n\t\tthis._expandedInputLength += replacementTextLength;\n\t\tif (this._expandedInputLength > this._entityExpansionThreshold) {\n\t\t\tconst amplification = this._expandedInputLength / this._initialInputLength;\n\t\t\tif (amplification > this._entityExpansionMaxAmplification) {\n\t\t\t\tthrowErrorWithContext('too much entity expansion', topLevelEntityRef);\n\t\t\t}\n\t\t}\n\t\tthis._topLevelEntityRef = topLevelEntityRef;\n\t\tthis._depth += 1;\n\t}\n\n\tpublic exit(): void {\n\t\tthis._depth -= 1;\n\t\tif (this._depth === 0) {\n\t\t\tthis._topLevelEntityRef = null;\n\t\t}\n\t}\n}\n","/**\n * The result of parsing - either success (with an offset at which to resume parsing the next thing)\n * or failure. If a failure is fatal, parsing should not continue to try alternative options.\n *\n * A ParseResult may contain a value that represents the parsed input.\n *\n * @public\n */\nexport type ParseResult<T> =\n\t| { success: true; offset: number; value: T }\n\t| { success: false; offset: number; expected: string[]; fatal: boolean };\n\n/**\n * A parser is a function that tries to match whatever it expects at the given offset in the input\n * string. Returns a ParseResult.\n *\n * @public\n */\nexport type Parser<T> = (input: string, offset: number) => ParseResult<T>;\n\n/**\n * Creates a successful ParseResult containing the given value.\n *\n * @public\n *\n * @param offset - The offset in the input at which to continue parsing\n * @param value  - The value resulting from applying the parser\n */\nexport function okWithValue<T>(offset: number, value: T): ParseResult<T> {\n\treturn { success: true, offset, value };\n}\n\n/**\n * Creates a successful ParseResult with an undefined value. Use this to signal success in cases\n * where no value is required.\n *\n * @public\n *\n * @param offset - The offset in the input at which to continue parsing\n */\nexport function ok(offset: number): ParseResult<undefined> {\n\treturn okWithValue(offset, undefined);\n}\n\n/**\n * Creates an unsuccessful ParseResult (parse error) at the given offset.\n *\n * @public\n *\n * @param offset   - The offset in the input at which matching failed\n * @param expected - An array of strings indicating things that were expected at offset\n * @param fatal    - If true, no other branches should be tried as a result of this error\n */\nexport function error<T>(\n\toffset: number,\n\texpected: string[],\n\tfatal: boolean = false\n): ParseResult<T> {\n\treturn { success: false, offset, expected, fatal };\n}\n\n/**\n * Creates a Parser that matches the given string.\n *\n * @public\n *\n * @param token - The expected string\n */\nexport function token(token: string): Parser<string> {\n\treturn (input, offset) => {\n\t\tconst offsetAfter = offset + token.length;\n\t\tif (input.slice(offset, offsetAfter) === token) {\n\t\t\treturn okWithValue(offsetAfter, token);\n\t\t}\n\t\treturn error(offset, [token]);\n\t};\n}\n\nfunction lengthFromCodePoint(cp: number): number {\n\treturn cp > 0xffff ? 2 : 1;\n}\n\n/**\n * Creates a Parser that skips the next code point if the given predicate returns true.\n *\n * This counts in unicode characters (code points), not UTF-16 code units.\n *\n * To match a sequence of code points, consider using `codepoints` instead.\n *\n * @public\n *\n * @param isMatch  - callback called with the next codepoint, should return whether that matches\n * @param expected - expected strings to return if the codepoint does not match\n */\nexport function codepoint(\n\tisMatch: (codepoint: number) => boolean,\n\texpected: string[]\n): Parser<void> {\n\treturn (input: string, offset: number) => {\n\t\tconst cp = input.codePointAt(offset);\n\t\tif (cp === undefined || !isMatch(cp)) {\n\t\t\treturn error(offset, expected);\n\t\t}\n\t\treturn ok(offset + lengthFromCodePoint(cp));\n\t};\n}\n\n/**\n * Creates a Parser that skips code points while the given predicate returns true.\n *\n * This counts in unicode characters (code points), not UTF-16 code units.\n *\n * This acts like `starConsumed(codepoint(isMatch, []))` if expected is not set, or as\n * `plusConsumed(codepoint(isMatch, expected))` if it is, but is much more efficient than either of\n * those combinations.\n *\n * @public\n *\n * @param isMatch  - callback called for each codepoint, should return whether that matches\n * @param expected - expected strings to return if the first codepoint does not match\n */\nexport function codepoints(\n\tisMatch: (codepoint: number) => boolean,\n\texpected?: string[]\n): Parser<void> {\n\treturn (input: string, offset: number) => {\n\t\tconst startOffset = offset;\n\t\twhile (true) {\n\t\t\tconst cp = input.codePointAt(offset);\n\t\t\tif (cp === undefined) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!isMatch(cp)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\toffset += cp > 0xffff ? 2 : 1;\n\t\t}\n\t\tif (expected !== undefined && offset === startOffset) {\n\t\t\treturn error(offset, expected);\n\t\t}\n\t\treturn ok(offset);\n\t};\n}\n\n/**\n * Creates a Parser that matches a single character from a range of codepoints.\n *\n * Use `recognize` if you need the character that was matched.\n *\n * @public\n *\n * @param firstCodePoint - The first code point to accept\n * @param lastCodePoint  - The last code point to accept (inclusive)\n */\nexport function range(\n\tfirstCodePoint: number,\n\tlastCodePoint: number,\n\texpected?: string[]\n): Parser<void> {\n\treturn codepoint(\n\t\t(cp) => firstCodePoint <= cp && cp <= lastCodePoint,\n\t\texpected || [\n\t\t\t`${String.fromCodePoint(firstCodePoint)}-${String.fromCodePoint(lastCodePoint)}`,\n\t\t]\n\t);\n}\n\n/**\n * Creates a Parser that skips the given number of characters.\n *\n * This counts in unicode characters (code points), not UTF-16 code units.\n *\n * @public\n *\n * @param nCodepoints - number of characters to skip\n */\nexport function skipChars(nCodepoints: number): Parser<void> {\n\treturn (input: string, offset: number) => {\n\t\tlet i = nCodepoints;\n\t\twhile (i > 0) {\n\t\t\tconst cp = input.codePointAt(offset);\n\t\t\tif (cp === undefined) {\n\t\t\t\treturn error(offset, ['any character']);\n\t\t\t}\n\t\t\toffset += lengthFromCodePoint(cp);\n\t\t\ti -= 1;\n\t\t}\n\t\treturn ok(offset);\n\t};\n}\n\n/**\n * Creates a Parser that applies the given function to each value generated by the given parser.\n *\n * @public\n *\n * @param parser - Parser to map over\n * @param map    - Function to transform values generated by parser\n */\nexport function map<T, U>(parser: Parser<T>, map: (v: T) => U): Parser<U> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn okWithValue(res.offset, map(res.value));\n\t};\n}\n\n/**\n * Creates a Parser that applies the given parser but discards the resulting value.\n *\n * @public\n *\n * @param parser - Parser to apply\n */\nexport function consume<T>(parser: Parser<T>): Parser<void> {\n\treturn map(parser, () => undefined);\n}\n\n/**\n * Creates a Parser that uses the given filter predicate to check values generated by the given\n * parser. Values that pass the predicate are passed through, those that don't return a parse error\n * instead.\n *\n * @public\n *\n * @param parser   - Parser to filter\n * @param filter   - Predicate function over the inner parser's values\n * @param expected - Expected values for parse errors generated when the filter rejects a value\n * @param fatal    - Whether the error returned when the filter rejects should be fatal\n */\nexport function filter<T>(\n\tparser: Parser<T>,\n\tfilter: (v: T) => boolean,\n\texpected: string[],\n\tfatal?: boolean\n): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\tif (!filter(res.value)) {\n\t\t\treturn error(offset, expected, fatal);\n\t\t}\n\t\treturn res;\n\t};\n}\n\n/**\n * Creates a Parser that applies each of the given parsers in turn until one matches, then returns\n * that parser's result. If no parser matches, an error is returned reflecting the furthest offset\n * reached in the input string. If any parser returns a fatal error, no further branches are tried.\n *\n * @public\n *\n * @param parsers  - Parsers to attempt to apply\n * @param expected - Overrides the expected value used if none of the inner parsers match\n */\nexport function or<T>(parsers: Parser<T>[], expected?: string[]): Parser<T> {\n\treturn (input, offset) => {\n\t\tlet lastError: ParseResult<T> | null = null;\n\t\tfor (const parser of parsers) {\n\t\t\tconst res = parser(input, offset);\n\t\t\tif (res.success) {\n\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (lastError === null || res.offset > lastError.offset) {\n\t\t\t\tlastError = res;\n\t\t\t} else if (res.offset === lastError.offset && expected === undefined) {\n\t\t\t\tlastError.expected = lastError.expected.concat(res.expected);\n\t\t\t}\n\t\t\tif (res.fatal) {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\texpected = expected || lastError?.expected || [];\n\t\tif (lastError) {\n\t\t\tlastError.expected = expected;\n\t\t}\n\t\treturn lastError || error(offset, expected);\n\t};\n}\n\n/**\n * Creates a Parser that tries to apply the given parser optionally. It returns the inner parser's\n * result if succesful, and otherwise indicates success at the starting offset with a `null` value.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - Parser to attempt to apply\n */\nexport function optional<T>(parser: Parser<T>): Parser<T | null> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success && !res.fatal) {\n\t\t\treturn okWithValue(offset, null);\n\t\t}\n\n\t\treturn res;\n\t};\n}\n\n/**\n * Creates a Parser that tries to apply the given parser zero or more times in sequence. Values for\n * successful matches are collected in an array. Once the inner parser no longer matches, success is\n * returned at the offset reached with the accumulated values.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - Parser to apply repeatedly\n */\nexport function star<T>(parser: Parser<T>): Parser<T[]> {\n\treturn (input, offset) => {\n\t\tlet ts: T[] = [];\n\t\tlet nextOffset = offset;\n\t\twhile (true) {\n\t\t\tconst res = parser(input, nextOffset);\n\t\t\tif (!res.success) {\n\t\t\t\tif (res.fatal) {\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tts.push(res.value);\n\t\t\tif (res.offset === nextOffset) {\n\t\t\t\t// Did not advance\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnextOffset = res.offset;\n\t\t}\n\n\t\treturn okWithValue(nextOffset, ts);\n\t};\n}\n\n/**\n * Creates a Parser that tries to apply the given parser zero or more times in sequence. Values for\n * successful matches are discarded. Once the inner parser no longer matches, success is returned at\n * the offset reached.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - Parser to apply repeatedly\n */\nexport function starConsumed<T>(parser: Parser<T>): Parser<void> {\n\treturn (input, offset) => {\n\t\tlet nextOffset = offset;\n\t\twhile (true) {\n\t\t\tconst res = parser(input, nextOffset);\n\t\t\tif (!res.success) {\n\t\t\t\tif (res.fatal) {\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (res.offset === nextOffset) {\n\t\t\t\t// Did not advance\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnextOffset = res.offset;\n\t\t}\n\n\t\treturn ok(nextOffset);\n\t};\n}\n\n/**\n * Creates a parser that discards undefined values from the array produced by the\n * given parser.\n *\n * Useful in combination with `star`, `or` and `consume`:\n *\n * ```\n * const a: Parser<string> = token('a');\n * const b: Parser<void> = consume(token('b'));\n * const abs: Parser<(string | void)[]> = star(or<string | void>([a, b]));\n * const as: Parser<string[]> = filterUndefined(abs);\n * ```\n *\n * @public\n *\n * @param parser - Parser to apply, should produce an array that may contain undefined entries.\n */\nexport function filterUndefined<T>(parser: Parser<(T | void)[]>): Parser<T[]> {\n\treturn map(parser, (vs) => vs.filter((v) => v !== undefined) as T[]);\n}\n\n/**\n * Creates a Parser that applies the given two parsers in sequence, returning success only if both\n * succeed. The given join function is used to combine the values from both parsers into the single\n * value to return. If either parser fails, the failure is returned as-is.\n *\n * @public\n *\n * @param parser1 - First parser to apply\n * @param parser2 - Parser to apply after the first one is successful\n * @param join    - Function used to combine the values of both parsers\n */\nexport function then<T1, T2, T>(\n\tparser1: Parser<T1>,\n\tparser2: Parser<T2>,\n\tjoin: (value1: T1, value2: T2) => T\n): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst r1 = parser1(input, offset);\n\t\tif (!r1.success) {\n\t\t\treturn r1;\n\t\t}\n\t\tconst r2 = parser2(input, r1.offset);\n\t\tif (!r2.success) {\n\t\t\treturn r2;\n\t\t}\n\t\treturn okWithValue(r2.offset, join(r1.value, r2.value));\n\t};\n}\n\n/**\n * Creates a parser that applies the given parsers in sequence, returning a tuple of the\n * corresponding values if all of them accept.\n *\n * This can be slightly less efficient than nesting `then` and its variations, but may be a lot more\n * readable. If you don't care about any of the values produced, consider using `sequenceConsumed`\n * instead.\n *\n * @public\n *\n * @param parsers - Parsers to apply one after the other\n */\nexport function sequence<Ts extends unknown[]>(\n\t...parsers: { [key in keyof Ts]: Parser<Ts[key]> }\n): Parser<Ts> {\n\treturn (input, offset) => {\n\t\tconst values: Ts = [] as unknown[] as Ts;\n\t\tfor (const parser of parsers) {\n\t\t\tconst res = parser(input, offset);\n\t\t\tif (!res.success) {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\toffset = res.offset;\n\t\t\tvalues.push(res.value);\n\t\t}\n\t\treturn okWithValue(offset, values);\n\t};\n}\n\n/**\n * Creates a parser that applies the given parsers in sequence, discarding all of the values\n * produced.\n *\n * @public\n *\n * @param parsers - Parsers to apply one after the other\n */\nexport function sequenceConsumed(...parsers: Parser<unknown>[]): Parser<void> {\n\treturn (input, offset) => {\n\t\tfor (const parser of parsers) {\n\t\t\tconst res = parser(input, offset);\n\t\t\tif (!res.success) {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\toffset = res.offset;\n\t\t}\n\t\treturn ok(offset);\n\t};\n}\n\n/**\n * Creates a Parser that tries to apply the given parser one or more times in sequence. Values for\n * successful matches are collected in an array. Once the inner parser no longer matches, success is\n * returned at the offset reached with the accumulated values. The parser is required to match at\n * least once, so an initial failure is returned as-is.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - The parser to apply repeatedly\n */\nexport function plus<T>(parser: Parser<T>): Parser<T[]> {\n\treturn then(parser, star(parser), (v, vs) => [v].concat(vs));\n}\n\n/**\n * Returns the first of the given two arguments. Useful as a `join` function for `then`. See also\n * `followed`.\n *\n * @public\n *\n * @param x - Argument to return\n * @param y - Argument to ignore\n */\nexport function first<T1, T2>(x: T1, y: T2): T1 {\n\treturn x;\n}\n\n/**\n * Returns the second of the given two arguments. Useful as a `join` function for `then`. See also\n * `preceded`.\n *\n * @public\n *\n * @param x - Argument to ignore\n * @param y - Argument to return\n */\nexport function second<T1, T2>(x: T1, y: T2): T2 {\n\treturn y;\n}\n\n/**\n * Creates a Parser that tries to apply the given parser one or more times in sequence. Values for\n * successful matches are discarded. Once the inner parser no longer matches, success is returned at\n * the offset reached. The parser is required to match at least once, so an initial failure is\n * returned as-is.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - The parser to apply repeatedly\n */\nexport function plusConsumed<T>(parser: Parser<T>): Parser<void> {\n\treturn then(parser, starConsumed(parser), second);\n}\n\n/**\n * Creates a Parser that applies the given two parsers in sequence, returning the result of the\n * second if the first succeeds.\n *\n * Equivalent to `then(before, parser, second)`.\n *\n * @public\n *\n * @param before - First parser to apply, value is discarded\n * @param parser - Second parser to apply, value is kept\n */\nexport function preceded<TBefore, T>(before: Parser<TBefore>, parser: Parser<T>): Parser<T> {\n\treturn then(before, parser, second);\n}\n\n/**\n * Creates a Parser that applies the given two parsers in sequence, returning the result value of\n * the first at the offset of the second if both succeed. If either parser fails the error is\n * returned as-is.\n *\n * Equivalent to `then(parser, after, first)`.\n *\n * @public\n *\n * @param parser - First parser to apply, value is kept\n * @param before - Second parser to apply, value is discarded\n */\nexport function followed<T, TAfter>(parser: Parser<T>, after: Parser<TAfter>): Parser<T> {\n\treturn then(parser, after, first);\n}\n\n/**\n * Creates a Parser that applies the given parsers in sequence, returning the result value of the\n * middle parser at the offset of the third if all are successful. If any parser fails, the error is\n * returned as-is.\n *\n * Optionally makes errors by the second and third parsers fatal if `cutAfterOpen` is `true`.\n *\n * @public\n *\n * @param open         - First parser to apply, value is discarded\n * @param inner        - Second parser to apply, value is kept\n * @param close        - Third parser to apply, value is discarded\n * @param cutAfterOpen - If `true`, errors returned by the second and third parsers are considered\n *                       fatal, causing parsers using this to stop trying other branches.\n */\nexport function delimited<TOpen, T, TClose>(\n\topen: Parser<TOpen>,\n\tinner: Parser<T>,\n\tclose: Parser<TClose>,\n\tcutAfterOpen: boolean = false\n): Parser<T> {\n\tconst rest = cutAfterOpen ? cut(followed(inner, close)) : followed(inner, close);\n\treturn preceded(open, rest);\n}\n\n/**\n * Creates a Parser that applies the given parser. If successful, the inner parser's value is\n * discarded and the substring that was consumed from the input is returned as value instead. Errors\n * are returned as-is.\n *\n * When using this in combination with `star` or `plus`, consider using `starConsumed` or\n * `plusConsumed` instead for efficiency.\n *\n * @public\n *\n * @param parser - The parser to apply, value is discarded and replaced by the consumed input.\n */\nexport function recognize<T>(parser: Parser<T>): Parser<string> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn okWithValue(res.offset, input.slice(offset, res.offset));\n\t};\n}\n\n/**\n * Creates a Parser that applies the given parser without consuming any input. That is, if the inner\n * parser is successful, success is returned (with the resulting value) at the starting offset,\n * effectively making the parser consume no input.\n *\n * Errors returned by the inner parser are returned as-is.\n *\n * @public\n *\n * @param parser - The parser to apply, value is discarded and any progress made in input is reset.\n */\nexport function peek<T>(parser: Parser<T>): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn okWithValue(offset, res.value);\n\t};\n}\n\n/**\n * Creates a Parser that succeeds at the starting offset if the given parser fails and vice-versa.\n *\n * @public\n *\n * @param parser   - The parser to apply\n * @param expected - Expected values for parse errors generated when the inner parser succeeds\n */\nexport function not<T>(parser: Parser<T>, expected: string[]): Parser<void> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn ok(offset);\n\t\t}\n\t\treturn error(offset, expected);\n\t};\n}\n\n/**\n * Creates a Parser that matches only if the first Parser matches input at the starting position,\n * but the second Parser does not.\n *\n * @public\n *\n * @param match    - Parser that should match\n * @param except   - Parser that should not match\n * @param expected - Expected values for parse errors generated when the except parser succeeds\n */\nexport function except<T, U>(match: Parser<T>, except: Parser<U>, expected: string[]): Parser<T> {\n\treturn preceded(not(except, expected), match);\n}\n\n/**\n * Creates a parser that looks at a single codepoint to determine which parser to invoke. Can be\n * used as an alternative to large `or` parsers if looking ahead can narrow down the options.\n *\n * Can optionally look ahead further than the current codepoint, which is useful when nesting\n * several `dispatch` parsers.\n *\n * @public\n *\n * @param mapping     - Object mapping code points to parsers\n * @param otherwise   - Parser to use when the code point is not found in the mapping, or undefined\n *                      to reject in that situation.\n * @param extraOffset - How far ahead to look for the codepoint, defaults to 0\n * @param expected    - Expected values for parse errors generated when there is no codepoint or\n *                      when the codepoint is not in the mapping and there is no `otherwise` parser\n */\nexport function dispatch<T>(\n\tmapping: { [codepoint: number]: Parser<T> },\n\totherwise: Parser<T> | undefined,\n\textraOffset: number = 0,\n\texpected: string[] = []\n): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst cp = input.codePointAt(offset + extraOffset);\n\t\tif (cp === undefined) {\n\t\t\treturn error(offset, expected);\n\t\t}\n\t\tconst parser = mapping[cp];\n\t\tif (parser === undefined) {\n\t\t\tif (otherwise === undefined) {\n\t\t\t\treturn error(offset, expected);\n\t\t\t}\n\t\t\treturn otherwise(input, offset);\n\t\t}\n\t\treturn parser(input, offset);\n\t};\n}\n\n/**\n * Creates a Parser that turns errors returned by the inner parser into fatal errors. Parsers such\n * as `or` and `star` will not continue to attempt additional matches if a parser returns a fatal\n * error, and will usually return the error instead.\n *\n * @public\n *\n * @param parser - The parser to wrap\n */\nexport function cut<T>(parser: Parser<T>): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn error(res.offset, res.expected, true);\n\t\t}\n\t\treturn res;\n\t};\n}\n\n/**\n * A parser that only succeeds at the start of the input string.\n *\n * @public\n *\n * @param input  - The input to match in\n * @param offset - The offset in `input` at which to start matching\n */\nexport const start: Parser<void> = (_input, offset) =>\n\toffset === 0 ? ok(offset) : error(offset, ['start of input']);\n\n/**\n * A parser that only succeeds if the end of the input string is reached.\n *\n * @public\n *\n * @param input  - The input to match in\n * @param offset - The offset in `input` at which to start matching\n */\nexport const end: Parser<void> = (input, offset) =>\n\tinput.length === offset ? ok(offset) : error(offset, ['end of input']);\n\n/**\n * Creates a Parser that applies the given parser and only succeeds (returning the inner parser's\n * result) if parsing concludes at the end of the input string.\n *\n * @public\n *\n * @param parser - The parser to wrap\n */\nexport function complete<T>(parser: Parser<T>): Parser<T> {\n\treturn then(parser, end, first);\n}\n","import { end, Parser, ParseResult } from 'prsc';\n\nexport const enum ParserStateType {\n\tone,\n\tstar,\n\toptional,\n}\n\nexport type ParserState<T> = {\n\tparser: Parser<T | void>;\n\ttype: ParserStateType;\n};\n\nexport default class ParserStateMachine<T> implements Iterator<T> {\n\tprivate _states: ParserState<T>[];\n\tprivate _state = 0;\n\n\tprivate _input: string;\n\tprivate _offset = 0;\n\n\tconstructor(input: string, states: ParserState<T>[]) {\n\t\tthis._input = input;\n\t\tthis._states = states;\n\t}\n\n\tpublic next(): IteratorResult<T, ParseResult<unknown>> {\n\t\tif (this._state >= this._states.length) {\n\t\t\treturn { done: true, value: end(this._input, this._offset) };\n\t\t}\n\n\t\tconst { parser, type } = this._states[this._state];\n\t\tconst res = parser(this._input, this._offset);\n\t\tif (!res.success) {\n\t\t\tif (type === ParserStateType.one || res.fatal) {\n\t\t\t\treturn { done: true, value: res };\n\t\t\t}\n\t\t\tthis._state += 1;\n\t\t\treturn this.next();\n\t\t}\n\t\tthis._offset = res.offset;\n\t\tif (type !== ParserStateType.star) {\n\t\t\tthis._state += 1;\n\t\t}\n\t\tif (res.value === undefined) {\n\t\t\treturn this.next();\n\t\t}\n\t\treturn { done: false, value: res.value };\n\t}\n}\n","import {\n\tcodepoint,\n\tcodepoints,\n\tcomplete,\n\tconsume,\n\tcut,\n\tdelimited,\n\tdispatch,\n\texcept,\n\tfilter,\n\tfilterUndefined,\n\tfollowed,\n\tmap,\n\tnot,\n\tokWithValue,\n\toptional,\n\tor,\n\tParser,\n\tParseResult,\n\tpeek,\n\tplusConsumed,\n\tpreceded,\n\trange,\n\trecognize,\n\tsequence,\n\tsequenceConsumed,\n\tstar,\n\tstarConsumed,\n\tthen,\n\ttoken,\n} from 'prsc';\nimport {\n\tAttDefEvent,\n\tAttlistDeclEvent,\n\tAttributeEvent,\n\tAttValueEvent,\n\tCDSectEvent,\n\tCharRefEvent,\n\tCommentEvent,\n\tDefaultDeclEvent,\n\tDefaultDeclType,\n\tDoctypedeclEvent,\n\tDocumentParseEvent,\n\tEmptyElemTagEvent,\n\tEntityDeclEvent,\n\tEntityRefEvent,\n\tEntityValueEvent,\n\tETagEvent,\n\tExternalEntityEvent,\n\tExternalIDEvent,\n\tMarkupdeclEvent,\n\tMarkupdeclEventType,\n\tParserEventType,\n\tPEReferenceEvent,\n\tPIEvent,\n\tReferenceEvent,\n\tSTagEvent,\n\tTextEvent,\n\tWithPosition,\n\tXMLDeclEvent,\n} from './parserEvents';\nimport ParserStateMachine, { ParserState, ParserStateType } from './ParserStateMachine';\n\nfunction withPosition<T>(parser: Parser<T>): Parser<WithPosition<T>> {\n\treturn (input: string, offset: number) => {\n\t\tconst start = offset;\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn okWithValue(res.offset, { input, start, end: res.offset, ...res.value });\n\t};\n}\n\nconst UNDERSCORE = token('_');\nconst DASH = token('-');\nconst PERIOD = token('.');\nconst DOUBLE_QUOTE = token('\"');\nconst SINGLE_QUOTE = token(\"'\");\nconst ANGLE_BRACKET_OPEN = token('<');\nconst ANGLE_BRACKET_CLOSE = token('>');\nconst AMPERSAND = token('&');\nconst EQUALS = token('=');\nconst SQUARE_BRACKET_OPEN = token('[');\nconst SQUARE_BRACKET_CLOSE = token(']');\nconst SEMICOLON = token(';');\nconst PERCENT = token('%');\nconst PARENTHESIS_OPEN = token('(');\nconst PARENTHESIS_CLOSE = token(')');\nconst PLUS = token('+');\nconst COMMA = token(',');\nconst QUESTION_MARK = token('?');\nconst ASTERISK = token('*');\nconst VERTICAL_BAR = token('|');\n\nconst SECT_END = token(']]>');\nconst COMMENT_START = token('<!--');\nconst COMMENT_END = token('-->');\nconst PI_START = token('<?');\nconst PI_END = token('?>');\nconst ONE_POINT = token('1.');\nconst VERSION = token('version');\nconst ENCODING = token('encoding');\nconst STANDALONE = token('standalone');\nconst YES = token('yes');\nconst NO = token('no');\nconst XML_DECL_START = token('<?xml');\nconst DOCTYPE_START = token('<!DOCTYPE');\nconst SYSTEM = token('SYSTEM');\nconst PUBLIC = token('PUBLIC');\nconst ETAG_START = token('</');\nconst EMPTY_ELEMENT_END = token('/>');\nconst CHARREF_START = token('&#');\nconst CHARREF_HEX_START = token('&#x');\nconst ELEMENT_DECL_START = token('<!ELEMENT');\nconst EMPTY = token('EMPTY');\nconst ANY = token('ANY');\nconst PCDATA = token('#PCDATA');\nconst ATTLIST_DECL_START = token('<!ATTLIST');\nconst NOTATION = token('NOTATION');\nconst REQUIRED = token('#REQUIRED');\nconst IMPLIED = token('#IMPLIED');\nconst FIXED = token('#FIXED');\n// const CONDITIONAL_SECT_START = token('<![');\n// const INCLUDE = token('INCLUDE');\n// const IGNORE = token('IGNORE');\nconst ENTITY_DECL_START = token('<!ENTITY');\nconst NDATA = token('NDATA');\nconst NOTATION_DECL_START = token('<!NOTATION');\n\n// A-Z\nconst UPPER_A_CP = 0x41;\nconst UPPER_Z_CP = 0x5a;\nconst UPPER_ALPHA = range(UPPER_A_CP, UPPER_Z_CP);\n\n// a-z\nconst LOWER_A_CP = 0x61;\nconst LOWER_Z_CP = 0x7a;\nconst LOWER_ALPHA = range(LOWER_A_CP, LOWER_Z_CP);\n\n// 0-9\nconst ZERO_CP = 0x30;\nconst NINE_CP = 0x39;\nconst DIGIT = range(ZERO_CP, NINE_CP);\n\nconst HEX_DIGIT = or([DIGIT, range(0x41, 0x46), range(0x61, 0x66)], ['hexadecimal digit']);\n\n// [2] Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]\nfunction isValidChar(cp: number): boolean {\n\treturn (\n\t\tcp === 0x9 ||\n\t\tcp === 0xa ||\n\t\tcp === 0xd ||\n\t\t(0x20 <= cp && cp <= 0xd7ff) ||\n\t\t(0xe000 <= cp && cp <= 0xfffd) ||\n\t\t(0x10000 <= cp && cp <= 0x10ffff)\n\t);\n}\n// const Char = codepoint(isValidChar, ['valid character']);\n\nexport const CompleteChars = complete(codepoints(isValidChar));\n\n// [3] S ::= (#x20 | #x9 | #xD | #xA)+\nfunction isValidWhitespace(cp: number): boolean {\n\treturn cp === 0x20 || cp === 0x9 || cp === 0xd || cp === 0xa;\n}\nconst S = codepoints(isValidWhitespace, ['whitespace']);\n\nexport const CompleteWhitespace = complete(codepoints(isValidWhitespace));\n\n// [4] NameStartChar ::= \":\" | [A-Z] | \"_\" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF]\n//     | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF]\n//     | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\nconst COLON_CP = 0x3a;\nconst UNDERSCORE_CP = 0x5f;\nfunction isValidNameStartChar(cp: number): boolean {\n\treturn (\n\t\tcp === COLON_CP ||\n\t\t(UPPER_A_CP <= cp && cp <= UPPER_Z_CP) ||\n\t\tcp === UNDERSCORE_CP ||\n\t\t(LOWER_A_CP <= cp && cp <= LOWER_Z_CP) ||\n\t\t(0xc0 <= cp && cp <= 0xd6) ||\n\t\t(0xd8 <= cp && cp <= 0xf6) ||\n\t\t(0xf8 <= cp && cp <= 0x2ff) ||\n\t\t(0x370 <= cp && cp <= 0x37d) ||\n\t\t(0x37f <= cp && cp <= 0x1fff) ||\n\t\t(0x200c <= cp && cp <= 0x200d) ||\n\t\t(0x2070 <= cp && cp <= 0x218f) ||\n\t\t(0x2c00 <= cp && cp <= 0x2fef) ||\n\t\t(0x3001 <= cp && cp <= 0xd7ff) ||\n\t\t(0xf900 <= cp && cp <= 0xfdcf) ||\n\t\t(0xfdf0 <= cp && cp <= 0xfffd) ||\n\t\t(0x10000 <= cp && cp <= 0xeffff)\n\t);\n}\nconst NameStartChar = codepoint(isValidNameStartChar, ['valid name start character']);\n\n// [4a] NameChar ::= NameStartChar | \"-\" | \".\" | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]\nconst DASH_CP = 0x2d;\nconst PERIOD_CP = 0x2e;\nfunction isValidNameChar(cp: number): boolean {\n\treturn (\n\t\tisValidNameStartChar(cp) ||\n\t\tcp === DASH_CP ||\n\t\tcp === PERIOD_CP ||\n\t\t(ZERO_CP <= cp && cp <= NINE_CP) ||\n\t\tcp === 0xb7 ||\n\t\t(0x0300 <= cp && cp <= 0x036f) ||\n\t\t(0x203f <= cp && cp <= 0x2040)\n\t);\n}\n// const NameChar = codepoint(isValidNameChar, ['valid name character']);\n\n// [5] Name ::= NameStartChar (NameChar)*\nconst Name = recognize(preceded(NameStartChar, codepoints(isValidNameChar)));\n\nexport const CompleteName = complete(Name);\n\nconst NCName = filter(Name, (name) => !name.includes(':'), ['name must not contain colon'], true);\n\n// [6] Names ::= Name (#x20 Name)*\n// const Names = then(Name, star(preceded(SPACE, Name)), (first, next) => [first, ...next]);\n\n// [7] Nmtoken ::= (NameChar)+\nconst Nmtoken = recognize(codepoints(isValidNameChar, ['valid name character']));\n\n// [8] Nmtokens ::= Nmtoken (#x20 Nmtoken)*\n// const NmTokens = then(Nmtoken, star(preceded(SPACE, Nmtoken)), (first, next) => [first, ...next]);\n\n// [66] CharRef ::= '&#' [0-9]+ ';'\n//      | '&#x' [0-9a-fA-F]+ ';'\nconst CharRef: Parser<CharRefEvent> = withPosition(\n\tmap(\n\t\tfilter(\n\t\t\tor([\n\t\t\t\tmap(\n\t\t\t\t\tdelimited(\n\t\t\t\t\t\tCHARREF_HEX_START,\n\t\t\t\t\t\trecognize(plusConsumed(HEX_DIGIT)),\n\t\t\t\t\t\tSEMICOLON,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t),\n\t\t\t\t\t(n) => parseInt(n, 16)\n\t\t\t\t),\n\t\t\t\tmap(\n\t\t\t\t\tdelimited(CHARREF_START, recognize(plusConsumed(DIGIT)), SEMICOLON, true),\n\t\t\t\t\t(n) => parseInt(n, 10)\n\t\t\t\t),\n\t\t\t]),\n\t\t\t(cp) => isValidChar(cp),\n\t\t\t['character reference must reference a valid character'],\n\t\t\ttrue\n\t\t),\n\t\t(cp) => ({ type: ParserEventType.CharRef, cp })\n\t)\n);\n\n// [68] EntityRef ::= '&' Name ';'\n// Namespaces spec makes this an NCName\nconst EntityRef: Parser<EntityRefEvent> = withPosition(\n\tmap(delimited(AMPERSAND, NCName, cut(SEMICOLON)), (name) => ({\n\t\ttype: ParserEventType.EntityRef,\n\t\tname,\n\t}))\n);\n\n// [67] Reference ::= EntityRef | CharRef\nconst Reference: Parser<ReferenceEvent> = or<ReferenceEvent>([EntityRef, CharRef]);\n\n// [69] PEReference ::= '%' Name ';'\n// Namespaces spec makes this an NCName\nconst PEReference: Parser<PEReferenceEvent> = withPosition(\n\tmap(delimited(PERCENT, NCName, SEMICOLON), (name) => ({\n\t\ttype: ParserEventType.PEReference,\n\t\tname,\n\t}))\n);\n\n// [9] EntityValue ::= '\"' ([^%&\"] | PEReference | Reference)* '\"'\n//     | \"'\" ([^%&'] | PEReference | Reference)* \"'\"\nconst PERCENT_CP = 0x25;\nconst AMPERSAND_CP = 0x26;\nconst EntityValue = or([\n\tdelimited(\n\t\tDOUBLE_QUOTE,\n\t\tstar(\n\t\t\tor<EntityValueEvent>([\n\t\t\t\trecognize(\n\t\t\t\t\tcodepoints(\n\t\t\t\t\t\t(cp) =>\n\t\t\t\t\t\t\tcp !== PERCENT_CP &&\n\t\t\t\t\t\t\tcp !== AMPERSAND_CP &&\n\t\t\t\t\t\t\tcp !== DOUBLE_QUOTE_CP &&\n\t\t\t\t\t\t\tisValidChar(cp),\n\t\t\t\t\t\t[]\n\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\tPEReference,\n\t\t\t\tReference,\n\t\t\t])\n\t\t),\n\t\tDOUBLE_QUOTE,\n\t\ttrue\n\t),\n\tdelimited(\n\t\tSINGLE_QUOTE,\n\t\tstar(\n\t\t\tor<EntityValueEvent>([\n\t\t\t\trecognize(\n\t\t\t\t\tcodepoints(\n\t\t\t\t\t\t(cp) =>\n\t\t\t\t\t\t\tcp !== PERCENT_CP &&\n\t\t\t\t\t\t\tcp !== AMPERSAND_CP &&\n\t\t\t\t\t\t\tcp !== SINGLE_QUOTE_CP &&\n\t\t\t\t\t\t\tisValidChar(cp),\n\t\t\t\t\t\t[]\n\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\tPEReference,\n\t\t\t\tReference,\n\t\t\t])\n\t\t),\n\t\tSINGLE_QUOTE,\n\t\ttrue\n\t),\n]);\n\n// [10] AttValue ::= '\"' ([^<&\"] | Reference)* '\"'\n//      | \"'\" ([^<&'] | Reference)* \"'\"\nconst DOUBLE_QUOTE_CP = 0x22;\nconst SINGLE_QUOTE_CP = 0x27;\nconst AttValue: Parser<AttValueEvent[]> = dispatch(\n\t{\n\t\t[DOUBLE_QUOTE_CP]: delimited(\n\t\t\tDOUBLE_QUOTE,\n\t\t\tstar(\n\t\t\t\tdispatch<AttValueEvent>(\n\t\t\t\t\t{\n\t\t\t\t\t\t[AMPERSAND_CP]: Reference,\n\t\t\t\t\t},\n\t\t\t\t\trecognize(\n\t\t\t\t\t\tcodepoints(\n\t\t\t\t\t\t\t(cp) =>\n\t\t\t\t\t\t\t\tcp !== ANGLE_BRACKET_OPEN_CP &&\n\t\t\t\t\t\t\t\tcp !== AMPERSAND_CP &&\n\t\t\t\t\t\t\t\tcp !== DOUBLE_QUOTE_CP &&\n\t\t\t\t\t\t\t\tisValidChar(cp),\n\t\t\t\t\t\t\t[]\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t),\n\t\t\tDOUBLE_QUOTE,\n\t\t\ttrue\n\t\t),\n\t\t[SINGLE_QUOTE_CP]: delimited(\n\t\t\tSINGLE_QUOTE,\n\t\t\tstar(\n\t\t\t\tdispatch<AttValueEvent>(\n\t\t\t\t\t{\n\t\t\t\t\t\t[AMPERSAND_CP]: Reference,\n\t\t\t\t\t},\n\t\t\t\t\trecognize(\n\t\t\t\t\t\tcodepoints(\n\t\t\t\t\t\t\t(cp) =>\n\t\t\t\t\t\t\t\tcp !== ANGLE_BRACKET_OPEN_CP &&\n\t\t\t\t\t\t\t\tcp !== AMPERSAND_CP &&\n\t\t\t\t\t\t\t\tcp !== SINGLE_QUOTE_CP &&\n\t\t\t\t\t\t\t\tisValidChar(cp),\n\t\t\t\t\t\t\t[]\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t),\n\t\t\tSINGLE_QUOTE,\n\t\t\ttrue\n\t\t),\n\t},\n\tundefined,\n\t0,\n\t['quoted attribute value']\n);\n\nexport const EntityReplacementTextInLiteral = complete(\n\tstar(\n\t\tor<AttValueEvent>([\n\t\t\trecognize(\n\t\t\t\tcodepoints(\n\t\t\t\t\t(cp) => cp !== ANGLE_BRACKET_OPEN_CP && cp !== AMPERSAND_CP && isValidChar(cp),\n\t\t\t\t\t[]\n\t\t\t\t)\n\t\t\t),\n\t\t\tReference,\n\t\t])\n\t)\n);\n\n// [11] SystemLiteral ::= ('\"' [^\"]* '\"') | (\"'\" [^']* \"'\")\nconst SystemLiteral = filter(\n\tor([\n\t\tdelimited(\n\t\t\tDOUBLE_QUOTE,\n\t\t\trecognize(codepoints((cp) => cp !== DOUBLE_QUOTE_CP && isValidChar(cp))),\n\t\t\tDOUBLE_QUOTE\n\t\t),\n\t\tdelimited(\n\t\t\tSINGLE_QUOTE,\n\t\t\trecognize(codepoints((cp) => cp !== SINGLE_QUOTE_CP && isValidChar(cp))),\n\t\t\tSINGLE_QUOTE\n\t\t),\n\t]),\n\t(systemId) => !systemId.includes('#'),\n\t['system identifier must not contain a fragment identifier'],\n\ttrue\n);\n\n// [13] PubidChar ::= #x20 | #xD | #xA | [a-zA-Z0-9] | [-'()+,./:=?;!*#@$_%]\nfunction isValidPubidChar(cp: number): boolean {\n\treturn (\n\t\tcp === 0x20 ||\n\t\tcp === 0xd ||\n\t\tcp === 0xa ||\n\t\t(LOWER_A_CP <= cp && cp <= LOWER_Z_CP) ||\n\t\t(UPPER_A_CP <= cp && cp <= UPPER_Z_CP) ||\n\t\t(ZERO_CP <= cp && cp <= NINE_CP) ||\n\t\t(0x21 <= cp && cp <= 0x2f && cp !== 0x22 && cp !== 0x26) ||\n\t\t(0x3a <= cp && cp <= 0x40 && cp !== 0x3c && cp !== 0x3e) ||\n\t\tcp === 0x5f\n\t);\n}\n// const PubidChar = codepoint(isValidPubidChar, ['valid public ID character']);\n\nexport const CompletePubidChars = complete(codepoints(isValidPubidChar));\n\n// [12] PubidLiteral ::= '\"' PubidChar* '\"' | \"'\" (PubidChar - \"'\")* \"'\"\nconst PubidLiteral = or([\n\tdelimited(\n\t\tDOUBLE_QUOTE,\n\t\trecognize(codepoints((cp) => cp !== DOUBLE_QUOTE_CP && isValidPubidChar(cp))),\n\t\tDOUBLE_QUOTE,\n\t\ttrue\n\t),\n\tdelimited(\n\t\tSINGLE_QUOTE,\n\t\trecognize(codepoints((cp) => cp !== SINGLE_QUOTE_CP && isValidPubidChar(cp))),\n\t\tSINGLE_QUOTE,\n\t\ttrue\n\t),\n]);\n\n// [14] CharData ::= [^<&]* - ([^<&]* ']]>' [^<&]*)\n// CharData is only ever used as optional, it doesn't make sense to have it accept the empty string\n// For efficiency, hardcode the disallowed codepoints\nconst ANGLE_BRACKET_OPEN_CP = 0x3c;\nconst SQUARE_BRACKET_CLOSE_CP = 0x5d;\nconst CharData: Parser<TextEvent> = recognize(\n\tplusConsumed(\n\t\tor(\n\t\t\t[\n\t\t\t\t// Fast path: filtered codepoints\n\t\t\t\tcodepoints(\n\t\t\t\t\t(cp) =>\n\t\t\t\t\t\tcp !== ANGLE_BRACKET_OPEN_CP &&\n\t\t\t\t\t\tcp !== AMPERSAND_CP &&\n\t\t\t\t\t\tcp !== SQUARE_BRACKET_CLOSE_CP &&\n\t\t\t\t\t\tisValidChar(cp),\n\t\t\t\t\t[]\n\t\t\t\t),\n\t\t\t\t// Square bracket is allowed if it's not a SECT_END\n\t\t\t\texcept(consume(SQUARE_BRACKET_CLOSE), SECT_END, []),\n\t\t\t],\n\t\t\t['character data']\n\t\t)\n\t)\n);\n\n// [15] Comment ::= '<!--' ((Char - '-') | ('-' (Char - '-')))* '-->'\nconst Comment: Parser<CommentEvent> = map(\n\tdelimited(\n\t\tCOMMENT_START,\n\t\trecognize(\n\t\t\tstarConsumed(\n\t\t\t\tor([\n\t\t\t\t\t// Fast path - any Char except \"-\"\n\t\t\t\t\tcodepoints((cp) => cp !== DASH_CP && isValidChar(cp), []),\n\t\t\t\t\t// Dash may not be followed by another dash\n\t\t\t\t\tfollowed(consume(DASH), not(DASH, ['comment content may not contain --'])),\n\t\t\t\t])\n\t\t\t)\n\t\t),\n\t\tCOMMENT_END,\n\t\ttrue\n\t),\n\t(data) => ({ type: ParserEventType.Comment, data })\n);\n// [17] PITarget ::= Name - (('X' | 'x') ('M' | 'm') ('L' | 'l'))\n// Namespaces spec makes this an NCName\nconst PITarget = filter(\n\tNCName,\n\t(target) => target.toLowerCase() !== 'xml',\n\t['processing instruction target must not be \"xml\"'],\n\ttrue\n);\n\n// [16] PI ::= '<?' PITarget (S (Char* - (Char* '?>' Char*)))? '?>'\nconst QUESTION_MARK_CP = 0x3f;\nconst PI: Parser<PIEvent> = delimited(\n\tPI_START,\n\tthen(\n\t\tPITarget,\n\t\toptional(\n\t\t\tpreceded(\n\t\t\t\tS,\n\t\t\t\trecognize(\n\t\t\t\t\tstarConsumed(\n\t\t\t\t\t\tor([\n\t\t\t\t\t\t\t// Fast path - any Char except \"?\"\n\t\t\t\t\t\t\tcodepoints((cp) => cp !== QUESTION_MARK_CP && isValidChar(cp), []),\n\t\t\t\t\t\t\t// Question mark must not be part of \"?>\"\n\t\t\t\t\t\t\tfollowed(consume(QUESTION_MARK), not(ANGLE_BRACKET_CLOSE, ['PI data'])),\n\t\t\t\t\t\t])\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\t(target, data) => ({ type: ParserEventType.PI, target, data })\n\t),\n\tPI_END,\n\ttrue\n);\n\n// [19] CDStart ::= '<![CDATA['\nconst CDStart = token('<![CDATA[');\n\n// [20] CData ::= (Char* - (Char* ']]>' Char*))\nconst CData = recognize(\n\tstarConsumed(\n\t\tor([\n\t\t\t// Fast path - any Char except ]\n\t\t\tcodepoints((cp) => cp !== SQUARE_BRACKET_CLOSE_CP && isValidChar(cp), []),\n\t\t\texcept(consume(SQUARE_BRACKET_CLOSE), SECT_END, ['CData']),\n\t\t])\n\t)\n);\n\n// [21] CDEnd ::= ']]>'\nconst CDEnd = SECT_END;\n\n// [18] CDSect ::= CDStart CData CDEnd\nconst CDSect: Parser<CDSectEvent> = withPosition(\n\tmap(delimited(CDStart, CData, CDEnd, true), (data) => ({\n\t\ttype: ParserEventType.CDSect,\n\t\tdata,\n\t}))\n);\n\n// [25] Eq ::= S? '=' S?\nconst Eq = delimited(optional(S), EQUALS, optional(S));\n\n// [26] VersionNum ::= '1.' [0-9]+\nconst VersionNum = recognize(preceded(ONE_POINT, plusConsumed(DIGIT)));\n\n// [24] VersionInfo ::= S 'version' Eq (\"'\" VersionNum \"'\" | '\"' VersionNum '\"')\nconst VersionInfo = preceded(\n\tS,\n\tpreceded(\n\t\tVERSION,\n\t\tpreceded(\n\t\t\tEq,\n\t\t\tor([\n\t\t\t\tdelimited(DOUBLE_QUOTE, VersionNum, DOUBLE_QUOTE, true),\n\t\t\t\tdelimited(SINGLE_QUOTE, VersionNum, SINGLE_QUOTE, true),\n\t\t\t])\n\t\t)\n\t)\n);\n\n// [81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*\nconst EncName = recognize(\n\tpreceded(\n\t\tor([UPPER_ALPHA, LOWER_ALPHA]),\n\t\tstarConsumed(\n\t\t\tor([\n\t\t\t\tUPPER_ALPHA,\n\t\t\t\tLOWER_ALPHA,\n\t\t\t\tDIGIT,\n\t\t\t\tconsume(PERIOD),\n\t\t\t\tconsume(UNDERSCORE),\n\t\t\t\tconsume(DASH),\n\t\t\t])\n\t\t)\n\t)\n);\n\n// [80] EncodingDecl ::= S 'encoding' Eq ('\"' EncName '\"' | \"'\" EncName \"'\" )\nconst EncodingDecl = preceded(\n\tS,\n\tpreceded(\n\t\tENCODING,\n\t\tpreceded(\n\t\t\tEq,\n\t\t\tor([\n\t\t\t\tdelimited(DOUBLE_QUOTE, EncName, DOUBLE_QUOTE, true),\n\t\t\t\tdelimited(SINGLE_QUOTE, EncName, SINGLE_QUOTE, true),\n\t\t\t])\n\t\t)\n\t)\n);\n\n// [32] SDDecl ::= S 'standalone' Eq ((\"'\" ('yes' | 'no') \"'\") | ('\"' ('yes' | 'no') '\"'))\nconst YesOrNo = or([map(YES, () => true), map(NO, () => false)]);\nconst SDDecl = preceded(\n\tS,\n\tpreceded(\n\t\tSTANDALONE,\n\t\tcut(\n\t\t\tpreceded(\n\t\t\t\tEq,\n\t\t\t\tor([\n\t\t\t\t\tdelimited(DOUBLE_QUOTE, YesOrNo, DOUBLE_QUOTE, true),\n\t\t\t\t\tdelimited(SINGLE_QUOTE, YesOrNo, SINGLE_QUOTE, true),\n\t\t\t\t])\n\t\t\t)\n\t\t)\n\t)\n);\n\n// [23] XMLDecl ::= '<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'\nconst XMLDecl: Parser<XMLDeclEvent> = delimited(\n\t// PIs may also start with <?xml, but may never have their target be just 'xml'\n\t// We can therefore consider it a fatal error if parsing fails after the space\n\tfollowed(XML_DECL_START, peek(S)),\n\tfollowed(\n\t\tthen(\n\t\t\tVersionInfo,\n\t\t\tthen(optional(EncodingDecl), optional(SDDecl), (e, s) => [e, s] as const),\n\t\t\t(version, [encoding, standalone]) => ({\n\t\t\t\ttype: ParserEventType.XMLDecl,\n\t\t\t\tversion,\n\t\t\t\tencoding,\n\t\t\t\tstandalone,\n\t\t\t})\n\t\t),\n\t\toptional(S)\n\t),\n\tPI_END,\n\ttrue\n);\n\nconst NameWithPosition = withPosition(map(Name, (name) => ({ name })));\n\n// [41] Attribute ::= Name Eq AttValue\nconst Attribute: Parser<AttributeEvent> = then(\n\tNameWithPosition,\n\tpreceded(cut(Eq), cut(AttValue)),\n\t(name, value) => ({\n\t\tname,\n\t\tvalue,\n\t})\n);\n\n// [40] STag ::= '<' Name (S Attribute)* S? '>'\n// [44] EmptyElemTag ::= '<' Name (S Attribute)* S? '/>'\n// Combined to avoid reparsing all of the attributes when a tag turns out to be empty\nconst Attributes = followed(star(preceded(S, Attribute)), optional(S));\n\nconst SOLIDUS_CP = 0x2f;\nconst STagOrEmptyElemTag: Parser<STagEvent | EmptyElemTagEvent> = map(\n\tsequence(\n\t\tANGLE_BRACKET_OPEN,\n\t\tNameWithPosition,\n\t\tcut(Attributes),\n\t\tcut(\n\t\t\tdispatch(\n\t\t\t\t{ [SOLIDUS_CP]: map(EMPTY_ELEMENT_END, () => true) },\n\t\t\t\tmap(ANGLE_BRACKET_CLOSE, () => false),\n\t\t\t\t0,\n\t\t\t\t['>', '/>']\n\t\t\t)\n\t\t)\n\t),\n\t([_, name, attributes, isEmpty]) => ({\n\t\ttype: isEmpty ? ParserEventType.EmptyElemTag : ParserEventType.STag,\n\t\tname,\n\t\tattributes,\n\t})\n);\n\n// [42] ETag ::= '</' Name S? '>'\nconst ETag: Parser<ETagEvent> = withPosition(\n\tmap(delimited(ETAG_START, followed(Name, optional(S)), ANGLE_BRACKET_CLOSE, true), (name) => ({\n\t\ttype: ParserEventType.ETag,\n\t\tname,\n\t}))\n);\n\nconst Multiplicity = or([QUESTION_MARK, ASTERISK, PLUS]);\n\n// [48] cp ::= (Name | choice | seq) ('?' | '*' | '+')?\nconst cp = followed(\n\tor([consume(Name), choiceIndirect, seqIndirect]),\n\tconsume(optional(Multiplicity))\n);\n\n// [49] choice ::= '(' S? cp ( S? '|' S? cp )+ S? ')'\nconst choice = sequenceConsumed(\n\tPARENTHESIS_OPEN,\n\toptional(S),\n\tcp,\n\tplusConsumed(sequence(optional(S), VERTICAL_BAR, optional(S), cut(cp))),\n\toptional(S),\n\tPARENTHESIS_CLOSE\n);\n\nfunction choiceIndirect(input: string, offset: number): ParseResult<void> {\n\treturn choice(input, offset);\n}\n\n// [50] seq ::= '(' S? cp ( S? ',' S? cp )* S? ')'\nconst seq = sequenceConsumed(\n\tPARENTHESIS_OPEN,\n\toptional(S),\n\tcp,\n\tstarConsumed(sequence(optional(S), COMMA, optional(S), cut(cp))),\n\toptional(S),\n\tPARENTHESIS_CLOSE\n);\n\nfunction seqIndirect(input: string, offset: number): ParseResult<void> {\n\treturn seq(input, offset);\n}\n\n// [47] children ::= (choice | seq) ('?' | '*' | '+')?\nconst children = followed(or([choice, seq]), optional(Multiplicity));\n\n// [51] Mixed ::= '(' S? '#PCDATA' (S? '|' S? Name)* S? ')*'\n//      | '(' S? '#PCDATA' S? ')'\nconst Mixed = sequenceConsumed(\n\tPARENTHESIS_OPEN,\n\toptional(S),\n\tPCDATA,\n\tor([\n\t\tsequenceConsumed(\n\t\t\tstarConsumed(sequenceConsumed(optional(S), VERTICAL_BAR, optional(S), Name)),\n\t\t\toptional(S),\n\t\t\tPARENTHESIS_CLOSE,\n\t\t\tASTERISK\n\t\t),\n\t\tconsume(followed(optional(S), PARENTHESIS_CLOSE)),\n\t])\n);\n\n// [46] contentspec ::= 'EMPTY' | 'ANY' | Mixed | children\nconst contentspec = or([consume(EMPTY), consume(ANY), consume(Mixed), consume(children)]);\n\n// [45] elementdecl ::= '<!ELEMENT' S Name S contentspec S? '>'\nconst elementdecl = followed(\n\tELEMENT_DECL_START,\n\tcut(sequenceConsumed(S, Name, S, contentspec, optional(S), ANGLE_BRACKET_CLOSE))\n);\n\n// [55] StringType ::= 'CDATA'\nconst StringType = token('CDATA');\n\n// [56] TokenizedType ::= 'ID'\n//      | 'IDREF'\n//      | 'IDREFS'\n//      | 'ENTITY'\n//      | 'ENTITIES'\n//      | 'NMTOKEN'\n//      | 'NMTOKENS'\n// Ordering is important here as some tokens are prefixes of others and we want the longest match\nconst TokenizedType = or([\n\ttoken('IDREFS'),\n\ttoken('IDREF'),\n\ttoken('ID'),\n\ttoken('ENTITY'),\n\ttoken('ENTITIES'),\n\ttoken('NMTOKENS'),\n\ttoken('NMTOKEN'),\n]);\n\n// [58] NotationType ::= 'NOTATION' S '(' S? Name (S? '|' S? Name)* S? ')'\n// Namespaces spec makes this use NCName\nconst NotationType = followed(\n\tNOTATION,\n\tcut(\n\t\tsequenceConsumed(\n\t\t\tS,\n\t\t\tPARENTHESIS_OPEN,\n\t\t\toptional(S),\n\t\t\tNCName,\n\t\t\tstarConsumed(sequenceConsumed(optional(S), VERTICAL_BAR, optional(S), NCName)),\n\t\t\toptional(S),\n\t\t\tPARENTHESIS_CLOSE\n\t\t)\n\t)\n);\n\n// [59] Enumeration ::= '(' S? Nmtoken (S? '|' S? Nmtoken)* S? ')'\nconst Enumeration = followed(\n\tPARENTHESIS_OPEN,\n\tcut(\n\t\tsequenceConsumed(\n\t\t\toptional(S),\n\t\t\tNmtoken,\n\t\t\tstarConsumed(sequenceConsumed(optional(S), VERTICAL_BAR, optional(S), Nmtoken)),\n\t\t\toptional(S),\n\t\t\tPARENTHESIS_CLOSE\n\t\t)\n\t)\n);\n\n// [57] EnumeratedType ::= NotationType | Enumeration\nconst EnumeratedType = or([NotationType, Enumeration]);\n\n// [54] AttType ::= StringType | TokenizedType | EnumeratedType\n// We only need to know whether the attribute's type is 'CDATA'\nconst AttType = or([\n\tmap(StringType, () => true),\n\tmap(TokenizedType, () => false),\n\tmap(EnumeratedType, () => false),\n]);\n\n// [60] DefaultDecl ::= '#REQUIRED' | '#IMPLIED'\n//      | (('#FIXED' S)? AttValue)\nconst DefaultDecl = or<DefaultDeclEvent>([\n\tmap(REQUIRED, () => ({ type: DefaultDeclType.REQUIRED })),\n\tmap(IMPLIED, () => ({ type: DefaultDeclType.IMPLIED })),\n\tthen(\n\t\tmap(optional(followed(FIXED, S)), (v) => v !== null),\n\t\tAttValue,\n\t\t(fixed, value) => ({ type: DefaultDeclType.VALUE, fixed, value })\n\t),\n]);\n\n// [53] AttDef ::= S Name S AttType S DefaultDecl\nconst AttDef: Parser<AttDefEvent> = then(\n\tpreceded(S, NameWithPosition),\n\tcut(then(preceded(S, AttType), preceded(S, DefaultDecl), (isCData, def) => ({ isCData, def }))),\n\t(name, { isCData, def }) => ({ name, isCData, def })\n);\n\n// [52] AttlistDecl ::= '<!ATTLIST' S Name AttDef* S? '>'\nconst AttlistDecl: Parser<AttlistDeclEvent> = delimited(\n\tfollowed(ATTLIST_DECL_START, S),\n\tthen(Name, cut(star(AttDef)), (name, attdefs) => ({\n\t\ttype: MarkupdeclEventType.AttlistDecl,\n\t\tname,\n\t\tattdefs,\n\t})),\n\tpreceded(optional(S), ANGLE_BRACKET_CLOSE),\n\ttrue\n);\n\n// [62] includeSect ::= '<![' S? 'INCLUDE' S? '[' extSubsetDecl ']]>'\n// const includeSect = delimited(\n// \tdelimited(\n// \t\tCONDITIONAL_SECT_START,\n// \t\tdelimited(optional(S), INCLUDE, optional(S)),\n// \t\tSQUARE_BRACKET_OPEN\n// \t),\n// \textSubsetDeclIndirect,\n// \tSECT_END\n// );\n\n// [65] Ignore ::= Char* - (Char* ('<![' | ']]>') Char*)\n// const Ignore = star(except(Char, or([CONDITIONAL_SECT_START, SECT_END]), ['ignore sect contents']));\n\n// [64] ignoreSectContents ::= Ignore ('<![' ignoreSectContents ']]>' Ignore)*\n// const ignoreSectContents = then(\n// \tIgnore,\n// \tstar(\n// \t\tthen(\n// \t\t\tdelimited(CONDITIONAL_SECT_START, ignoreSectContentsIndirect, SECT_END),\n// \t\t\tIgnore,\n// \t\t\t() => undefined\n// \t\t)\n// \t),\n// \t() => undefined\n// );\n\n// function ignoreSectContentsIndirect(input: string, offset: number): ParseResult<void> {\n// \treturn ignoreSectContents(input, offset);\n// }\n\n// [63] ignoreSect ::= '<![' S? 'IGNORE' S? '[' ignoreSectContents* ']]>'\n// const ignoreSect = delimited(\n// \tdelimited(\n// \t\tCONDITIONAL_SECT_START,\n// \t\tdelimited(optional(S), IGNORE, optional(S)),\n// \t\tSQUARE_BRACKET_OPEN\n// \t),\n// \tstar(ignoreSectContents),\n// \tSECT_END\n// );\n\n// [61] conditionalSect ::= includeSect | ignoreSect\n// const conditionalSect = or([consume(includeSect), consume(ignoreSect)]);\n\n// [75] ExternalID ::= 'SYSTEM' S SystemLiteral\n//      | 'PUBLIC' S PubidLiteral S SystemLiteral\nconst ExternalID: Parser<ExternalIDEvent> = or<ExternalIDEvent>([\n\tmap(preceded(SYSTEM, cut(preceded(S, SystemLiteral))), (systemId) => ({\n\t\tpublicId: null,\n\t\tsystemId,\n\t})),\n\tpreceded(\n\t\tPUBLIC,\n\t\tthen(cut(preceded(S, PubidLiteral)), preceded(S, SystemLiteral), (publicId, systemId) => ({\n\t\t\tpublicId,\n\t\t\tsystemId,\n\t\t}))\n\t),\n]);\n\n// [76] NDataDecl ::= S 'NDATA' S Name\n// Namespaces spec makes this an NCName\nconst NDataDecl = preceded(delimited(S, NDATA, S), NCName);\n\n// [73] EntityDef ::= EntityValue | (ExternalID NDataDecl?)\nconst EntityDef = or<EntityValueEvent[] | ExternalEntityEvent>([\n\tEntityValue,\n\tthen(ExternalID, optional(NDataDecl), (ids, ndata) => ({\n\t\tids,\n\t\tndata,\n\t})),\n]);\n\n// [71] GEDecl ::= '<!ENTITY' S Name S EntityDef S? '>'\n// Namespaces spec makes this an NCName\nconst GEDecl: Parser<EntityDeclEvent | void> = delimited(\n\tENTITY_DECL_START,\n\tthen(preceded(S, NCName), cut(preceded(S, EntityDef)), (name, value) => ({\n\t\ttype: MarkupdeclEventType.GEDecl,\n\t\tname,\n\t\tvalue,\n\t})),\n\tpreceded(optional(S), ANGLE_BRACKET_CLOSE)\n);\n\n// [74] PEDef ::= EntityValue | ExternalID\nconst PEDef = or<EntityValueEvent[] | void>([EntityValue, consume(ExternalID)]);\n\n// [72] PEDecl ::= '<!ENTITY' S '%' S Name S PEDef S? '>'\n// Namespaces spec makes this an NCName\nconst PEDecl: Parser<EntityDeclEvent | void> = delimited(\n\tfollowed(ENTITY_DECL_START, preceded(S, PERCENT)),\n\tthen(preceded(S, NCName), cut(preceded(S, PEDef)), (name, value) =>\n\t\tvalue\n\t\t\t? {\n\t\t\t\t\ttype: MarkupdeclEventType.PEDecl,\n\t\t\t\t\tname,\n\t\t\t\t\tvalue,\n\t\t\t  }\n\t\t\t: undefined\n\t),\n\tpreceded(optional(S), ANGLE_BRACKET_CLOSE),\n\ttrue\n);\n\n// [70] EntityDecl ::= GEDecl | PEDecl\nconst EntityDecl = preceded(peek(ENTITY_DECL_START), cut(or([GEDecl, PEDecl])));\n\n// [77] TextDecl ::= '<?xml' VersionInfo? EncodingDecl S? '?>'\nconst TextDecl: Parser<XMLDeclEvent> = delimited(\n\t// PIs may also start with <?xml, but may never have their target be just 'xml'\n\t// We can therefore consider it a fatal error if parsing fails after the space\n\tfollowed(XML_DECL_START, peek(S)),\n\tfollowed(\n\t\tthen(optional(VersionInfo), EncodingDecl, (version, encoding) => ({\n\t\t\ttype: ParserEventType.XMLDecl,\n\t\t\tversion,\n\t\t\tencoding,\n\t\t\tstandalone: null,\n\t\t})),\n\t\toptional(S)\n\t),\n\tPI_END,\n\ttrue\n);\n\n// [83] PublicID ::= 'PUBLIC' S PubidLiteral\nconst PublicID: Parser<ExternalIDEvent> = map(\n\tfollowed(followed(PUBLIC, S), cut(PubidLiteral)),\n\t(publicId) => ({ publicId, systemId: null })\n);\n\n// [82] NotationDecl ::= '<!NOTATION' S Name S (ExternalID | PublicID) S? '>'\n// Namespaces spec makes this an NCName\nconst NotationDecl = delimited(\n\tNOTATION_DECL_START,\n\tthen(delimited(S, NCName, S), or([consume(ExternalID), consume(PublicID)]), () => undefined),\n\tpreceded(optional(S), ANGLE_BRACKET_CLOSE),\n\ttrue\n);\n\n// [29] markupdecl ::= elementdecl | AttlistDecl | EntityDecl | NotationDecl | PI | Comment\nconst markupdecl = or<MarkupdeclEvent | void>([\n\tconsume(elementdecl),\n\tAttlistDecl,\n\tEntityDecl,\n\tconsume(NotationDecl),\n\tconsume(PI),\n\tconsume(Comment),\n]);\n\n// [28a] DeclSep ::= PEReference | S\nconst DeclSep = or([consume(PEReference), consume(S)]);\n\n// [28b] intSubset ::= (markupdecl | DeclSep)*\nconst intSubset: Parser<MarkupdeclEvent[]> = filterUndefined(\n\tstar(or<MarkupdeclEvent | void>([markupdecl, DeclSep]))\n);\n\n// [31] extSubsetDecl ::= ( markupdecl | conditionalSect | DeclSep)*\n// const extSubsetDecl = star(or([consume(markupdecl), consume(conditionalSect), consume(DeclSep)]));\n\n// function extSubsetDeclIndirect(input: string, offset: number): ParseResult<void> {\n// \treturn extSubset(input, offset);\n// }\n\n// [30] extSubset ::= TextDecl? extSubsetDecl\n// TODO: productions for the external subset apply after parameter entity references are included\n// const extSubset = then(optional(TextDecl), extSubsetDecl, () => undefined);\n\n// [28] doctypedecl ::= '<!DOCTYPE' S Name (S ExternalID)? S? ('[' intSubset ']' S?)? '>'\nconst doctypedecl: Parser<DoctypedeclEvent> = preceded(\n\tDOCTYPE_START,\n\tcut(\n\t\tmap(\n\t\t\tsequence(\n\t\t\t\tS,\n\t\t\t\tName,\n\t\t\t\toptional(preceded(S, ExternalID)),\n\t\t\t\toptional(S),\n\t\t\t\toptional(\n\t\t\t\t\tfollowed(\n\t\t\t\t\t\tdelimited(SQUARE_BRACKET_OPEN, intSubset, SQUARE_BRACKET_CLOSE, true),\n\t\t\t\t\t\toptional(S)\n\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\tANGLE_BRACKET_CLOSE\n\t\t\t),\n\t\t\t([_1, name, ids, _2, intSubset, _3]) => ({\n\t\t\t\ttype: ParserEventType.Doctypedecl,\n\t\t\t\tname,\n\t\t\t\tids,\n\t\t\t\tintSubset,\n\t\t\t})\n\t\t)\n\t)\n);\n\n// [43] content ::= CharData? ((element | Reference | CDSect | PI | Comment) CharData?)*\n// Here's where we deviate a little from the spec grammar in order to avoid the recursion around\n// elements. Instead, consider start and end tags as separate events and handle / check nesting in\n// the caller. CharData is already greedy, so we can include it into the big or.\nconst EXCLAMATION_MARK_CP = 0x21;\nconst contentEvent = dispatch<DocumentParseEvent>(\n\t{\n\t\t[ANGLE_BRACKET_OPEN_CP]: dispatch<DocumentParseEvent>(\n\t\t\t{\n\t\t\t\t[SOLIDUS_CP]: ETag,\n\t\t\t\t[EXCLAMATION_MARK_CP]: or<CommentEvent | CDSectEvent>([Comment, CDSect]),\n\t\t\t\t[QUESTION_MARK_CP]: PI,\n\t\t\t},\n\t\t\tSTagOrEmptyElemTag,\n\t\t\t1\n\t\t),\n\t\t[AMPERSAND_CP]: Reference,\n\t},\n\tCharData\n);\n\nconst content: ParserState<DocumentParseEvent> = {\n\tparser: contentEvent,\n\ttype: ParserStateType.star,\n};\n\nexport function parseContent(input: string): Iterator<DocumentParseEvent> {\n\treturn new ParserStateMachine(input, [content]);\n}\n\n// [27] Misc ::= Comment | PI | S\nconst Misc = or<CommentEvent | PIEvent | void>([Comment, PI, S]);\n\n// [22] prolog ::= XMLDecl? Misc* (doctypedecl Misc*)?\nconst prolog: ParserState<DocumentParseEvent>[] = [\n\t{ parser: XMLDecl, type: ParserStateType.optional },\n\t{ parser: Misc, type: ParserStateType.star },\n\t{ parser: doctypedecl, type: ParserStateType.optional },\n\t{ parser: Misc, type: ParserStateType.star },\n];\n\n// [39] element ::= EmptyElemTag\n//      | STag content ETag\n// Simplified a bit, balancing of tags is checked in the parse loop\nconst element: ParserState<DocumentParseEvent>[] = [\n\t{ parser: STagOrEmptyElemTag, type: ParserStateType.one },\n\tcontent,\n];\n\n// [1] document ::= prolog element Misc*\n// As element leads to content, which is a superset of Misc*, we can omit the last Misc*\nconst document: ParserState<DocumentParseEvent>[] = [...prolog, ...element];\n\nexport function parseDocument(input: string): Iterator<DocumentParseEvent> {\n\treturn new ParserStateMachine(input, document);\n}\n\n// [78] extParsedEnt ::= TextDecl? content\nconst extParsedEnt: ParserState<DocumentParseEvent>[] = [\n\t{ parser: TextDecl, type: ParserStateType.optional },\n\tcontent,\n];\n\nexport function parseFragment(input: string): Iterator<DocumentParseEvent> {\n\treturn new ParserStateMachine(input, extParsedEnt);\n}\n","import Document from '../Document';\r\nimport DocumentFragment from '../DocumentFragment';\r\nimport Node from '../Node';\r\nimport { unsafeCreateAttribute, unsafeCreateElement } from '../unsafe';\r\nimport { appendAttribute } from '../util/attrMutations';\r\nimport { insertNode } from '../util/mutationAlgorithms';\r\nimport { XMLNS_NAMESPACE, XML_NAMESPACE } from '../util/namespaceHelpers';\r\nimport { isElement } from '../util/NodeType';\r\nimport { getNodeDocument } from '../util/treeHelpers';\r\nimport EntityExpansionGuard from './EntityExpansionGuard';\r\nimport {\r\n\tCompleteChars,\r\n\tCompleteName,\r\n\tCompletePubidChars,\r\n\tCompleteWhitespace,\r\n\tEntityReplacementTextInLiteral,\r\n\tparseContent,\r\n\tparseDocument,\r\n\tparseFragment,\r\n} from './grammar';\r\nimport {\r\n\tAttDefEvent,\r\n\tAttValueEvent,\r\n\tDefaultDeclType,\r\n\tDoctypedeclEvent,\r\n\tDocumentParseEvent,\r\n\tEmptyElemTagEvent,\r\n\tEntityRefEvent,\r\n\tEntityValueEvent,\r\n\tMarkupdeclEventType,\r\n\tParserEventType,\r\n\tSTagEvent,\r\n\tWithPosition,\r\n} from './parserEvents';\r\n\r\nfunction offsetToCoords(input: string, offset: number): { line: number; char: number } {\r\n\t// Assumes normalized line endings\r\n\tlet line = 1;\r\n\tlet char = 1;\r\n\tlet i = 0;\r\n\twhile (i < offset) {\r\n\t\tconst cp = input.codePointAt(i)!;\r\n\t\tconst l = cp > 0xffff ? 2 : 1;\r\n\t\tchar++;\r\n\t\ti += l;\r\n\t\tif (cp === 0xa) {\r\n\t\t\tline++;\r\n\t\t\tchar = 1;\r\n\t\t}\r\n\t}\r\n\treturn { line, char };\r\n}\r\n\r\nfunction replaceInvalidCharacters(input: string): string {\r\n\treturn Array.from(input, (char) =>\r\n\t\tmatchesCharProduction(char) ? char : '[invalid character]'\r\n\t).join('');\r\n}\r\n\r\nconst enum TruncateSide {\r\n\tStart,\r\n\tEnd,\r\n\tInside,\r\n}\r\n\r\nfunction truncate(input: string, side: TruncateSide, max: number): string {\r\n\tconst ELLIPSIS = '\\u{2026}';\r\n\tconst chars = Array.from(input);\r\n\tif (chars.length < max) {\r\n\t\treturn input;\r\n\t}\r\n\tswitch (side) {\r\n\t\tcase TruncateSide.Start:\r\n\t\t\treturn ELLIPSIS + chars.slice(-max).join('');\r\n\t\tcase TruncateSide.End:\r\n\t\t\treturn chars.slice(0, max).join('') + ELLIPSIS;\r\n\t}\r\n\tconst halfLength = Math.min(chars.length / 2, max / 2) | 0;\r\n\treturn chars.slice(0, halfLength).join('') + ELLIPSIS + chars.slice(-halfLength).join('');\r\n}\r\n\r\nfunction highlightError(input: string, start: number, end: number): string {\r\n\tconst inside = truncate(\r\n\t\treplaceInvalidCharacters(input.substring(start, end)),\r\n\t\tTruncateSide.Inside,\r\n\t\t30\r\n\t);\r\n\tconst newlineIndexBefore = input.lastIndexOf('\\n', start);\r\n\tconst lineBefore = truncate(\r\n\t\treplaceInvalidCharacters(input.substring(newlineIndexBefore + 1, start)),\r\n\t\tTruncateSide.Start,\r\n\t\t55 - inside.length\r\n\t);\r\n\tconst newlineIndexAfter = input.indexOf('\\n', end);\r\n\tconst lineAfter = truncate(\r\n\t\treplaceInvalidCharacters(\r\n\t\t\tnewlineIndexAfter > 0 ? input.substring(end, newlineIndexAfter) : input.substring(end)\r\n\t\t),\r\n\t\tTruncateSide.End,\r\n\t\t80 - inside.length - lineBefore.length\r\n\t);\r\n\tconst indent = Array.from(lineBefore, (c) => (isWhitespace(c) ? c : ' ')).join('');\r\n\tconst squiggle = '^'.repeat(Math.max(Array.from(inside).length, 1));\r\n\treturn `${lineBefore}${inside}${lineAfter}\\n${indent}${squiggle}`;\r\n}\r\n\r\nexport function throwErrorWithContext(message: string, event: WithPosition<unknown>): never {\r\n\tconst { line, char } = offsetToCoords(event.input, event.start);\r\n\tconst location = `At line ${line}, character ${char}:`;\r\n\tthrow new Error(\r\n\t\t`${message}\\n${location}\\n\\n${highlightError(event.input, event.start, event.end)}`\r\n\t);\r\n}\r\n\r\nfunction throwParseError(what: string, input: string, expected: string[], offset: number): never {\r\n\tconst quoted = Array.from(new Set(expected), (str) =>\r\n\t\tstr.includes('\"') ? `'${str}'` : `\"${str}\"`\r\n\t);\r\n\tconst cp = input.codePointAt(offset);\r\n\tconst actual = cp ? String.fromCodePoint(cp) : '';\r\n\tthrowErrorWithContext(\r\n\t\t`Parsing ${what} failed, expected ${\r\n\t\t\tquoted.length > 1 ? 'one of ' + quoted.join(', ') : quoted[0]\r\n\t\t}`,\r\n\t\t{ input, start: offset, end: offset + Math.max(actual.length, 1) }\r\n\t);\r\n}\r\n\r\n/**\r\n * Returns true if all characters in value match the Char production.\r\n *\r\n * @param value - The string to check\r\n *\r\n * @returns true if all characters in value match Char, otherwise false\r\n */\r\nexport function matchesCharProduction(value: string): boolean {\r\n\treturn CompleteChars(value, 0).success;\r\n}\r\n\r\n/**\r\n * Returns true if name matches the Name production.\r\n *\r\n * @param name - The name to check\r\n *\r\n * @returns true if name matches Name, otherwise false\r\n */\r\nexport function matchesNameProduction(name: string): boolean {\r\n\treturn CompleteName(name, 0).success;\r\n}\r\n\r\n/**\r\n * Returns true if all characters in value match the PubidChar production.\r\n *\r\n * @param value - The string to check\r\n *\r\n * @returns true if all characters in value match PubidChar, otherwise false\r\n */\r\nexport function matchesPubidCharProduction(value: string): boolean {\r\n\treturn CompletePubidChars(value, 0).success;\r\n}\r\n\r\n/**\r\n * Returns true if all characters in value match the S production.\r\n *\r\n * @param value - The string to check\r\n *\r\n * @returns true if all characters in value match S, otherwise false\r\n */\r\nfunction isWhitespace(value: string): boolean {\r\n\treturn CompleteWhitespace(value, 0).success;\r\n}\r\n\r\nfunction constructReplacementText(value: EntityValueEvent[]): string {\r\n\tconst replacementText: string[] = [];\r\n\tfor (const event of value) {\r\n\t\tif (typeof event === 'string') {\r\n\t\t\treplacementText.push(event);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tswitch (event.type) {\r\n\t\t\tcase ParserEventType.CharRef:\r\n\t\t\t\t// Include\r\n\t\t\t\treplacementText.push(String.fromCodePoint(event.cp));\r\n\t\t\t\tbreak;\r\n\t\t\tcase ParserEventType.EntityRef:\r\n\t\t\t\t// Bypass\r\n\t\t\t\treplacementText.push(`&${event.name};`);\r\n\t\t\t\tbreak;\r\n\t\t\tcase ParserEventType.PEReference:\r\n\t\t\t\tthrowErrorWithContext(\r\n\t\t\t\t\t`reference to parameter entity \"${event.name}\" must not occur in an entity declaration in the internal subset`,\r\n\t\t\t\t\tevent\r\n\t\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\treturn replacementText.join('');\r\n}\r\n\r\nclass Dtd {\r\n\tprivate _attlistByName = new Map<string, Map<string, AttDefEvent>>();\r\n\r\n\tprivate _entityReplacementTextByName = new Map<string, string>();\r\n\r\n\tprivate _externalEntityNames = new Set<string>();\r\n\r\n\tprivate _unparsedEntityNames = new Set<string>();\r\n\r\n\tconstructor(dtd: DoctypedeclEvent) {\r\n\t\tif (!dtd.intSubset) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfor (const decl of dtd.intSubset) {\r\n\t\t\tswitch (decl.type) {\r\n\t\t\t\tcase MarkupdeclEventType.AttlistDecl: {\r\n\t\t\t\t\t// Check if no entity is referenced before it is defined\r\n\t\t\t\t\tfor (const attr of decl.attdefs) {\r\n\t\t\t\t\t\tif (attr.def.type === DefaultDeclType.VALUE) {\r\n\t\t\t\t\t\t\tfor (const event of attr.def.value) {\r\n\t\t\t\t\t\t\t\tif (typeof event === 'string') {\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (event.type === ParserEventType.EntityRef) {\r\n\t\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\t\t!this._entityReplacementTextByName.has(event.name) &&\r\n\t\t\t\t\t\t\t\t\t\t!this._externalEntityNames.has(event.name) &&\r\n\t\t\t\t\t\t\t\t\t\t!this._unparsedEntityNames.has(event.name)\r\n\t\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\t\tthrowErrorWithContext(\r\n\t\t\t\t\t\t\t\t\t\t\t`default value of attribute \"${attr.name.name}\" contains reference to undefined entity \"${event.name}\"`,\r\n\t\t\t\t\t\t\t\t\t\t\tevent\r\n\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (this._externalEntityNames.has(event.name)) {\r\n\t\t\t\t\t\t\t\t\t\tthrowErrorWithContext(\r\n\t\t\t\t\t\t\t\t\t\t\t`default value of attribute \"${attr.name.name}\" must not contain reference to external entity \"${event.name}\"`,\r\n\t\t\t\t\t\t\t\t\t\t\tevent\r\n\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Multiple attlist for the same element are merged\r\n\t\t\t\t\tlet defByName = this._attlistByName.get(decl.name);\r\n\t\t\t\t\tif (defByName === undefined) {\r\n\t\t\t\t\t\tdefByName = new Map<string, AttDefEvent>();\r\n\t\t\t\t\t\tthis._attlistByName.set(decl.name, defByName);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (const attr of decl.attdefs) {\r\n\t\t\t\t\t\t// First declaration is binding\r\n\t\t\t\t\t\tif (defByName.has(attr.name.name)) {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tdefByName.set(attr.name.name, attr);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcase MarkupdeclEventType.PEDecl: {\r\n\t\t\t\t\t// We don't support these, but still need to validate well-formedness\r\n\t\t\t\t\tif (Array.isArray(decl.value)) {\r\n\t\t\t\t\t\tfor (const event of decl.value) {\r\n\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\ttypeof event !== 'string' &&\r\n\t\t\t\t\t\t\t\tevent.type === ParserEventType.PEReference\r\n\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\tthrowErrorWithContext(\r\n\t\t\t\t\t\t\t\t\t`reference to parameter entity \"${event.name}\" must not occur in an entity declaration in the internal subset`,\r\n\t\t\t\t\t\t\t\t\tevent\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcase MarkupdeclEventType.GEDecl: {\r\n\t\t\t\t\t// First declaration is binding\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tthis._entityReplacementTextByName.has(decl.name) ||\r\n\t\t\t\t\t\tthis._externalEntityNames.has(decl.name)\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (Array.isArray(decl.value)) {\r\n\t\t\t\t\t\tthis._entityReplacementTextByName.set(\r\n\t\t\t\t\t\t\tdecl.name,\r\n\t\t\t\t\t\t\tconstructReplacementText(decl.value)\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t} else if (decl.value.ndata === null) {\r\n\t\t\t\t\t\t// External parsed entity may be skipped\r\n\t\t\t\t\t\tthis._externalEntityNames.add(decl.name);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// External unparsed entity\r\n\t\t\t\t\t\tthis._unparsedEntityNames.add(decl.name);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic getAttlist(nameEvent: { name: string }): Map<string, AttDefEvent> | undefined {\r\n\t\treturn this._attlistByName.get(nameEvent.name);\r\n\t}\r\n\r\n\tpublic getEntityReplacementText(\r\n\t\tevent: EntityRefEvent,\r\n\t\tallowExternal: boolean\r\n\t): string | undefined {\r\n\t\tconst value = this._entityReplacementTextByName.get(event.name);\r\n\t\tif (value === undefined) {\r\n\t\t\tif (this._unparsedEntityNames.has(event.name)) {\r\n\t\t\t\tthrowErrorWithContext(\r\n\t\t\t\t\t`reference to binary entity \"${event.name}\" is not allowed`,\r\n\t\t\t\t\tevent\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tif (this._externalEntityNames.has(event.name)) {\r\n\t\t\t\tif (allowExternal) {\r\n\t\t\t\t\treturn '';\r\n\t\t\t\t}\r\n\t\t\t\tthrowErrorWithContext(\r\n\t\t\t\t\t`reference to external entity \"${event.name}\" is not allowed in attribute value`,\r\n\t\t\t\t\tevent\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn value;\r\n\t}\r\n}\r\n\r\nconst predefinedEntitiesReplacementText = new Map([\r\n\t['lt', '&#60;'],\r\n\t['gt', '>'],\r\n\t['amp', '&#38;'],\r\n\t['apos', \"'\"],\r\n\t['quot', '\"'],\r\n]);\r\n\r\nfunction normalizeAndIncludeEntities(\r\n\tnormalized: string[],\r\n\tvalue: AttValueEvent[],\r\n\tdtd: Dtd | null,\r\n\tancestorEntities: string[] | null,\r\n\texpansionGuard: EntityExpansionGuard\r\n) {\r\n\tfor (const event of value) {\r\n\t\tif (typeof event === 'string') {\r\n\t\t\tnormalized.push(event.replace(/[\\r\\n\\t]/g, ' '));\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (event.type === ParserEventType.CharRef) {\r\n\t\t\tnormalized.push(String.fromCodePoint(event.cp));\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (ancestorEntities !== null && ancestorEntities.includes(event.name)) {\r\n\t\t\tthrowErrorWithContext(\r\n\t\t\t\t`reference to entity \"${event.name}\" must not be recursive`,\r\n\t\t\t\tevent\r\n\t\t\t);\r\n\t\t}\r\n\t\tlet replacementText = predefinedEntitiesReplacementText.get(event.name);\r\n\t\tif (replacementText === undefined && dtd !== null) {\r\n\t\t\treplacementText = dtd.getEntityReplacementText(event, false);\r\n\t\t}\r\n\t\tif (replacementText === undefined) {\r\n\t\t\tthrowErrorWithContext(\r\n\t\t\t\t`reference to unknown entity \"${event.name}\" in attribute value`,\r\n\t\t\t\tevent\r\n\t\t\t);\r\n\t\t}\r\n\t\texpansionGuard.enter(event, replacementText.length);\r\n\t\tconst result = EntityReplacementTextInLiteral(replacementText, 0);\r\n\t\tif (!result.success) {\r\n\t\t\tthrowParseError(\r\n\t\t\t\t`replacement text for entity \"${event.name}\"`,\r\n\t\t\t\treplacementText,\r\n\t\t\t\tresult.expected,\r\n\t\t\t\tresult.offset\r\n\t\t\t);\r\n\t\t}\r\n\t\t// Recursively normalize replacement text\r\n\t\tnormalizeAndIncludeEntities(\r\n\t\t\tnormalized,\r\n\t\t\tresult.value,\r\n\t\t\tdtd,\r\n\t\t\tancestorEntities ? [event.name, ...ancestorEntities] : [event.name],\r\n\t\t\texpansionGuard\r\n\t\t);\r\n\t\texpansionGuard.exit();\r\n\t}\r\n}\r\n\r\nfunction normalizeAttributeValue(\r\n\tvalue: AttValueEvent[],\r\n\tattDef: AttDefEvent | undefined,\r\n\tdtd: Dtd | null,\r\n\texpansionGuard: EntityExpansionGuard\r\n): string {\r\n\tconst normalized: string[] = [];\r\n\tnormalizeAndIncludeEntities(normalized, value, dtd, null, expansionGuard);\r\n\tif (attDef && !attDef.isCData) {\r\n\t\treturn normalized\r\n\t\t\t.join('')\r\n\t\t\t.replace(/[ ]+/g, ' ')\r\n\t\t\t.replace(/^[ ]+|[ ]+$/g, '');\r\n\t}\r\n\treturn normalized.join('');\r\n}\r\n\r\ntype QualifiedNameParts = { prefix: string | null; localName: string };\r\ntype QualifiedNameCache = Map<string, QualifiedNameParts>;\r\n\r\nfunction splitQualifiedName(\r\n\tevent: WithPosition<{ name: string }>,\r\n\tcache: QualifiedNameCache\r\n): QualifiedNameParts {\r\n\tconst qualifiedName = event.name;\r\n\tconst fromCache = cache.get(qualifiedName);\r\n\tif (fromCache !== undefined) {\r\n\t\treturn fromCache;\r\n\t}\r\n\r\n\t// 3. Let prefix be null.\r\n\tlet prefix: string | null = null;\r\n\r\n\t// 4.  Let localName be qualifiedName.\r\n\tlet localName = qualifiedName;\r\n\r\n\t// 5. If qualifiedName contains a \":\" (U+003A), then split the string on it and set prefix to\r\n\t// the part before and localName to the part after.\r\n\tconst index = qualifiedName.indexOf(':');\r\n\tif (index >= 0) {\r\n\t\tprefix = qualifiedName.substring(0, index);\r\n\t\tlocalName = qualifiedName.substring(index + 1);\r\n\t}\r\n\r\n\t// We already know (from the grammar) that qualifiedName is a valid Name, so only check if there\r\n\t// aren't too many colons and that both parts are not empty\r\n\tif (prefix === '' || localName === '' || localName.includes(':')) {\r\n\t\tthrowErrorWithContext(`the name \"${qualifiedName}\" is not a valid qualified name`, event);\r\n\t}\r\n\r\n\tconst parts = { prefix, localName };\r\n\tcache.set(qualifiedName, parts);\r\n\treturn parts;\r\n}\r\n\r\nclass Namespaces {\r\n\tprivate readonly _parent: Namespaces | null;\r\n\tprivate readonly _byPrefix: Map<string | null, string | null> = new Map();\r\n\tprivate readonly _resolve: ((prefix: string) => string | undefined) | null = null;\r\n\r\n\tprivate constructor(\r\n\t\tparent: Namespaces | null,\r\n\t\tresolve: ((prefix: string) => string | undefined) | null = null\r\n\t) {\r\n\t\tthis._parent = parent;\r\n\t\tthis._resolve = resolve ?? parent?._resolve ?? null;\r\n\t}\r\n\r\n\tpublic getForElement(prefix: string | null, event: WithPosition<unknown>): string | null {\r\n\t\tif (prefix === 'xmlns') {\r\n\t\t\tthrowErrorWithContext('element names must not have the prefix \"xmlns\"', event);\r\n\t\t}\r\n\t\tfor (let ns: Namespaces | null = this; ns !== null; ns = ns._parent) {\r\n\t\t\tconst namespace = ns._byPrefix.get(prefix);\r\n\t\t\tif (namespace !== undefined) {\r\n\t\t\t\treturn namespace;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (prefix !== null && this._resolve) {\r\n\t\t\tconst namespace = this._resolve(prefix);\r\n\t\t\tif (namespace !== undefined) {\r\n\t\t\t\treturn namespace;\r\n\t\t\t}\r\n\t\t}\r\n\t\tthrowErrorWithContext(`use of undeclared element prefix \"${prefix}\"`, event);\r\n\t}\r\n\r\n\tpublic getForAttribute(\r\n\t\tprefix: string | null,\r\n\t\tlocalName: string,\r\n\t\tevent: WithPosition<unknown>\r\n\t): string | null {\r\n\t\tif (prefix === null) {\r\n\t\t\t// Default namespace doesn't apply to attributes\r\n\t\t\treturn localName === 'xmlns' ? XMLNS_NAMESPACE : null;\r\n\t\t}\r\n\t\tfor (let ns: Namespaces | null = this; ns !== null; ns = ns._parent) {\r\n\t\t\tconst namespace = ns._byPrefix.get(prefix);\r\n\t\t\tif (namespace !== undefined) {\r\n\t\t\t\treturn namespace;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (this._resolve) {\r\n\t\t\tconst namespace = this._resolve(prefix);\r\n\t\t\tif (namespace !== undefined) {\r\n\t\t\t\treturn namespace;\r\n\t\t\t}\r\n\t\t}\r\n\t\tthrowErrorWithContext(`use of undeclared attribute prefix ${prefix}`, event);\r\n\t}\r\n\r\n\tpublic static fromAttrs(\r\n\t\tparent: Namespaces,\r\n\t\tevent: STagEvent | EmptyElemTagEvent,\r\n\t\tattlist: Map<string, AttDefEvent> | undefined,\r\n\t\tdtd: Dtd | null,\r\n\t\tqualifiedNameCache: QualifiedNameCache,\r\n\t\texpansionGuard: EntityExpansionGuard\r\n\t): Namespaces {\r\n\t\tlet ns = parent;\r\n\t\tlet hasDeclarations = false;\r\n\r\n\t\tconst add = (\r\n\t\t\tprefix: string | null,\r\n\t\t\tnamespace: string | null,\r\n\t\t\tevent: WithPosition<unknown>\r\n\t\t) => {\r\n\t\t\tif (prefix === null && (namespace === XML_NAMESPACE || namespace === XMLNS_NAMESPACE)) {\r\n\t\t\t\tthrowErrorWithContext(\r\n\t\t\t\t\t`the namespace \"${namespace}\" must not be used as the default namespace`,\r\n\t\t\t\t\tevent\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tif (namespace === XMLNS_NAMESPACE) {\r\n\t\t\t\tthrowErrorWithContext(\r\n\t\t\t\t\t`the namespace \"${XMLNS_NAMESPACE}\" must not be bound to a prefix`,\r\n\t\t\t\t\tevent\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tif (namespace === XML_NAMESPACE && prefix !== 'xml') {\r\n\t\t\t\tthrowErrorWithContext(\r\n\t\t\t\t\t`the namespace \"${XML_NAMESPACE}\" must be bound only to the prefix \"xml\"`,\r\n\t\t\t\t\tevent\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tif (namespace !== XML_NAMESPACE && prefix === 'xml') {\r\n\t\t\t\tthrowErrorWithContext(\r\n\t\t\t\t\t`the xml namespace prefix must not be bound to any namespace other than \"${XML_NAMESPACE}\"`,\r\n\t\t\t\t\tevent\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tif (prefix !== null && namespace === null) {\r\n\t\t\t\tthrowErrorWithContext(`the prefix \"${prefix}\" must not be undeclared`, event);\r\n\t\t\t}\r\n\t\t\tif (!hasDeclarations) {\r\n\t\t\t\tns = new Namespaces(parent);\r\n\t\t\t\thasDeclarations = true;\r\n\t\t\t}\r\n\t\t\tns._byPrefix.set(prefix, namespace);\r\n\t\t};\r\n\r\n\t\tconst checkAttr = (nameEvent: WithPosition<{ name: string }>, value: AttValueEvent[]) => {\r\n\t\t\tconst { prefix, localName } = splitQualifiedName(nameEvent, qualifiedNameCache);\r\n\t\t\tconst def = attlist?.get(nameEvent.name);\r\n\t\t\tif (\r\n\t\t\t\tprefix === null &&\r\n\t\t\t\tlocalName === 'xmlns' &&\r\n\t\t\t\t(!hasDeclarations || !ns._byPrefix.has(null))\r\n\t\t\t) {\r\n\t\t\t\tconst namespace = normalizeAttributeValue(value, def, dtd, expansionGuard) || null;\r\n\t\t\t\tadd(null, namespace, nameEvent);\r\n\t\t\t} else if (prefix === 'xmlns' && (!hasDeclarations || !ns._byPrefix.has(localName))) {\r\n\t\t\t\tif (localName === 'xmlns') {\r\n\t\t\t\t\tthrowErrorWithContext(\r\n\t\t\t\t\t\t'the \"xmlns\" namespace prefix must not be declared',\r\n\t\t\t\t\t\tnameEvent\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\tconst namespace = normalizeAttributeValue(value, def, dtd, expansionGuard) || null;\r\n\t\t\t\tadd(localName, namespace, nameEvent);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfor (const attr of event.attributes) {\r\n\t\t\tcheckAttr(attr.name, attr.value);\r\n\t\t}\r\n\t\tif (attlist) {\r\n\t\t\tfor (const attr of attlist.values()) {\r\n\t\t\t\tconst def = attr.def;\r\n\t\t\t\tif (def.type !== DefaultDeclType.VALUE) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tcheckAttr(attr.name, def.value);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn ns;\r\n\t}\r\n\r\n\tpublic static default(resolve: ((prefix: string) => string | undefined) | null): Namespaces {\r\n\t\tconst ns = new Namespaces(null, resolve);\r\n\t\tns._byPrefix.set(null, null);\r\n\t\tns._byPrefix.set('xml', XML_NAMESPACE);\r\n\t\tns._byPrefix.set('xmlns', XMLNS_NAMESPACE);\r\n\t\treturn ns;\r\n\t}\r\n}\r\n\r\nconst ROOT_NAMESPACES = Namespaces.default(null);\r\n\r\nfunction normalizeLineEndings(input: string): string {\r\n\treturn input.replace(/\\r\\n?/g, '\\n');\r\n}\r\n\r\nfunction appendParsedNode(parent: Node, child: Node): void {\r\n\t// We can bypass all of the pre-insertion checks as the parser guarantees that we won't try any\r\n\t// invalid combinations of node types here, that there is at most a single doctype and that that\r\n\t// doctype is parsed before any elements. Other constraints, such as not having text at the root\r\n\t// and not having more than one root element, are covered in the parse loop. We can also bypass\r\n\t// adoption, as all nodes are created from our document. Finally, no observers can possibly be\r\n\t// interested in our new document, so we don't need to look for those.\r\n\tinsertNode(child, parent, null, true);\r\n}\r\n\r\ntype DomContext = {\r\n\tparent: DomContext | null;\r\n\troot: Node;\r\n\tnamespaces: Namespaces;\r\n} & ({ entityRoot: true } | { entityRoot: false; event: STagEvent });\r\n\r\ntype EntityContext = {\r\n\tparent: EntityContext | null;\r\n\tentity: string | null;\r\n\titerator: Iterator<DocumentParseEvent>;\r\n};\r\n\r\n/**\r\n * Options that control parsing.\r\n *\r\n * @public\r\n */\r\nexport type ParseOptions = Partial<{\r\n\t/**\r\n\t * To guard against entity expansion attacks, this controls the maximum amplification factor\r\n\t * allowed when expanding entities. This is calculated as the ratio between the length of the\r\n\t * initial input and that of the processed input, which is the initial input plus the length of\r\n\t * the replacement text corresponding to each processed named entity reference.\r\n\t *\r\n\t * As high amplification factors may occur for normal documents, this is only enforced after the\r\n\t * length of the processed input exceeds the `entityExpansionThreshold`.\r\n\t *\r\n\t * Defaults to 100.\r\n\t *\r\n\t * Please file an issue if you ever need to adjust this value for a non-attack input.\r\n\t *\r\n\t * @public\r\n\t */\r\n\tentityExpansionMaxAmplification: number;\r\n\r\n\t/**\r\n\t * To guard against entity expansion attacks, this controls the threshold after which the\r\n\t * `entityExpansionMaxAmplification` limit is enforced. The threshold is applied against the\r\n\t * length of the processed input, which is the initial input plus the length of the replacement\r\n\t * text corresponding to each processed named entity reference.\r\n\t *\r\n\t * Defaults to 2^22 characters, which equates (assuming UCS-2 encoding) to 8MiB of input data.\r\n\t *\r\n\t * Please file an issue if you ever need to adjust this value for a non-attack input.\r\n\t *\r\n\t * @public\r\n\t */\r\n\tentityExpansionThreshold: number;\r\n\r\n\t/**\r\n\t * If set to true, any CDATA sections in the parsed document are converted to normal text.\r\n\t * Defaults to false, which means CDATA sections are represented in the DOM by CDataSection\r\n\t * nodes.\r\n\t *\r\n\t * @public\r\n\t */\r\n\ttreatCDataAsText: boolean;\r\n}>;\r\n\r\nconst DEFAULT_ENTITY_EXPANSION_MAX_AMPLIFICATION = 100.0;\r\n\r\n// 8MiB / 2 bytes per char (UCS-2) = 4MiB (2^22)\r\nconst DEFAULT_ENTITY_EXPANSION_THRESHOLD = 4_194_304;\r\n\r\nexport function parseXml(\r\n\tinput: string,\r\n\tgenerator: (input: string) => Iterator<DocumentParseEvent>,\r\n\tnamespaces: Namespaces,\r\n\tinto: Node,\r\n\t{\r\n\t\tentityExpansionMaxAmplification = DEFAULT_ENTITY_EXPANSION_MAX_AMPLIFICATION,\r\n\t\tentityExpansionThreshold = DEFAULT_ENTITY_EXPANSION_THRESHOLD,\r\n\t\ttreatCDataAsText = false,\r\n\t}: ParseOptions\r\n): void {\r\n\tconst doc = getNodeDocument(into);\r\n\tlet domContext: DomContext = {\r\n\t\tparent: null,\r\n\t\troot: into,\r\n\t\tnamespaces,\r\n\t\tentityRoot: true,\r\n\t};\r\n\tlet dtd: Dtd | null = null;\r\n\tconst qualifiedNameCache: QualifiedNameCache = new Map();\r\n\tlet collectedText: string[] = [];\r\n\r\n\tfunction flushCollectedText() {\r\n\t\tif (collectedText.length > 0) {\r\n\t\t\tconst text = collectedText.join('');\r\n\t\t\tif (domContext.root === doc) {\r\n\t\t\t\t// Ignore whitespace at document root\r\n\t\t\t\tif (!isWhitespace(text)) {\r\n\t\t\t\t\tthrow new Error('document must not contain text outside of elements');\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tappendParsedNode(domContext.root, doc.createTextNode(collectedText.join('')));\r\n\t\t\t}\r\n\t\t\tcollectedText.length = 0;\r\n\t\t}\r\n\t}\r\n\r\n\t// Remove BOM if there is one and normalize line endings to lf\r\n\tinput = input.replace(/^\\ufeff/, '');\r\n\tinput = normalizeLineEndings(input);\r\n\r\n\tconst expansionGuard = new EntityExpansionGuard(\r\n\t\tinput.length,\r\n\t\tentityExpansionThreshold,\r\n\t\tentityExpansionMaxAmplification\r\n\t);\r\n\tlet entityContext: EntityContext | null = {\r\n\t\tparent: null,\r\n\t\tentity: null,\r\n\t\titerator: generator(input),\r\n\t};\r\n\twhile (entityContext) {\r\n\t\tlet it: IteratorResult<DocumentParseEvent> = entityContext.iterator.next();\r\n\t\tfor (; !it.done; it = entityContext.iterator.next()) {\r\n\t\t\tconst event: DocumentParseEvent = it.value;\r\n\t\t\tif (typeof event === 'string') {\r\n\t\t\t\tcollectedText.push(event);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tswitch (event.type) {\r\n\t\t\t\tcase ParserEventType.CharRef:\r\n\t\t\t\t\tif (domContext.root === doc && doc.documentElement !== null) {\r\n\t\t\t\t\t\tthrowErrorWithContext(\r\n\t\t\t\t\t\t\t'character reference must not appear after the document element',\r\n\t\t\t\t\t\t\tevent\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcollectedText.push(String.fromCodePoint(event.cp));\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\tcase ParserEventType.EntityRef: {\r\n\t\t\t\t\tif (domContext.root === doc && doc.documentElement !== null) {\r\n\t\t\t\t\t\tthrowErrorWithContext(\r\n\t\t\t\t\t\t\t`reference to entity \"${event.name}\" must not appear after the document element`,\r\n\t\t\t\t\t\t\tevent\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (let ctx: EntityContext | null = entityContext; ctx; ctx = ctx.parent) {\r\n\t\t\t\t\t\tif (ctx.entity === event.name) {\r\n\t\t\t\t\t\t\tthrowErrorWithContext(\r\n\t\t\t\t\t\t\t\t`reference to entity \"${event.name}\" must not be recursive`,\r\n\t\t\t\t\t\t\t\tevent\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet replacementText = predefinedEntitiesReplacementText.get(event.name);\r\n\t\t\t\t\tif (replacementText === undefined && dtd !== null) {\r\n\t\t\t\t\t\treplacementText = dtd.getEntityReplacementText(event, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (replacementText === undefined) {\r\n\t\t\t\t\t\tthrowErrorWithContext(\r\n\t\t\t\t\t\t\t`reference to unknown entity \"${event.name}\" in content`,\r\n\t\t\t\t\t\t\tevent\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t\texpansionGuard.enter(event, replacementText.length);\r\n\t\t\t\t\tdomContext = {\r\n\t\t\t\t\t\tparent: domContext,\r\n\t\t\t\t\t\troot: domContext.root,\r\n\t\t\t\t\t\tnamespaces: domContext.namespaces,\r\n\t\t\t\t\t\tentityRoot: true,\r\n\t\t\t\t\t};\r\n\t\t\t\t\tentityContext = {\r\n\t\t\t\t\t\tparent: entityContext,\r\n\t\t\t\t\t\tentity: event.name,\r\n\t\t\t\t\t\titerator: parseContent(replacementText),\r\n\t\t\t\t\t};\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcase ParserEventType.CDSect:\r\n\t\t\t\t\tif (treatCDataAsText) {\r\n\t\t\t\t\t\tcollectedText.push(event.data);\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tflushCollectedText();\r\n\r\n\t\t\tswitch (event.type) {\r\n\t\t\t\tcase ParserEventType.CDSect:\r\n\t\t\t\t\tif (domContext.root === doc && doc.documentElement !== null) {\r\n\t\t\t\t\t\tthrowErrorWithContext(\r\n\t\t\t\t\t\t\t'CData section must not appear after the document element',\r\n\t\t\t\t\t\t\tevent\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tappendParsedNode(domContext.root, doc.createCDATASection(event.data));\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\tcase ParserEventType.Comment:\r\n\t\t\t\t\tappendParsedNode(domContext.root, doc.createComment(event.data));\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\tcase ParserEventType.Doctypedecl:\r\n\t\t\t\t\t// Grammar guarantees this happens before the document element\r\n\t\t\t\t\tdtd = new Dtd(event);\r\n\t\t\t\t\tappendParsedNode(\r\n\t\t\t\t\t\tdomContext.root,\r\n\t\t\t\t\t\tdoc.implementation.createDocumentType(\r\n\t\t\t\t\t\t\tevent.name,\r\n\t\t\t\t\t\t\tevent.ids?.publicId || '',\r\n\t\t\t\t\t\t\tevent.ids?.systemId || ''\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t);\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\tcase ParserEventType.PI:\r\n\t\t\t\t\tappendParsedNode(\r\n\t\t\t\t\t\tdomContext.root,\r\n\t\t\t\t\t\tdoc.createProcessingInstruction(event.target, event.data || '')\r\n\t\t\t\t\t);\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\tcase ParserEventType.STag:\r\n\t\t\t\tcase ParserEventType.EmptyElemTag: {\r\n\t\t\t\t\tif (domContext.root === doc && doc.documentElement !== null) {\r\n\t\t\t\t\t\tthrowErrorWithContext(\r\n\t\t\t\t\t\t\t`document must contain a single root element, but found \"${doc.documentElement.nodeName}\" and \"${event.name.name}\"`,\r\n\t\t\t\t\t\t\tevent.name\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconst attlist = dtd ? dtd.getAttlist(event.name) : undefined;\r\n\t\t\t\t\tconst namespaces = Namespaces.fromAttrs(\r\n\t\t\t\t\t\tdomContext.namespaces,\r\n\t\t\t\t\t\tevent,\r\n\t\t\t\t\t\tattlist,\r\n\t\t\t\t\t\tdtd,\r\n\t\t\t\t\t\tqualifiedNameCache,\r\n\t\t\t\t\t\texpansionGuard\r\n\t\t\t\t\t);\r\n\t\t\t\t\tconst { prefix, localName } = splitQualifiedName(\r\n\t\t\t\t\t\tevent.name,\r\n\t\t\t\t\t\tqualifiedNameCache\r\n\t\t\t\t\t);\r\n\t\t\t\t\tconst namespace = namespaces.getForElement(prefix, event.name);\r\n\t\t\t\t\t// We can skip the usual name validity checks\r\n\t\t\t\t\tconst element = unsafeCreateElement(doc, localName, namespace, prefix);\r\n\t\t\t\t\tfor (const attr of event.attributes) {\r\n\t\t\t\t\t\tconst { prefix, localName } = splitQualifiedName(\r\n\t\t\t\t\t\t\tattr.name,\r\n\t\t\t\t\t\t\tqualifiedNameCache\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tconst namespace = namespaces.getForAttribute(prefix, localName, attr.name);\r\n\t\t\t\t\t\tconst def = attlist?.get(attr.name.name);\r\n\t\t\t\t\t\tif (element.hasAttributeNS(namespace, localName)) {\r\n\t\t\t\t\t\t\tthrowErrorWithContext(\r\n\t\t\t\t\t\t\t\t`attribute \"${attr.name.name}\" must not appear multiple times on element \"${event.name.name}\"`,\r\n\t\t\t\t\t\t\t\tattr.name\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// We can skip validation of names and duplicates\r\n\t\t\t\t\t\tconst attrNode = unsafeCreateAttribute(\r\n\t\t\t\t\t\t\tnamespace,\r\n\t\t\t\t\t\t\tprefix,\r\n\t\t\t\t\t\t\tlocalName,\r\n\t\t\t\t\t\t\tnormalizeAttributeValue(attr.value, def, dtd, expansionGuard),\r\n\t\t\t\t\t\t\telement\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tappendAttribute(attrNode, element, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Add default attributes from the DTD\r\n\t\t\t\t\tif (attlist) {\r\n\t\t\t\t\t\tfor (const attr of attlist.values()) {\r\n\t\t\t\t\t\t\tconst def = attr.def;\r\n\t\t\t\t\t\t\tif (def.type !== DefaultDeclType.VALUE) {\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tconst { prefix, localName } = splitQualifiedName(\r\n\t\t\t\t\t\t\t\tattr.name,\r\n\t\t\t\t\t\t\t\tqualifiedNameCache\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tconst namespace = namespaces.getForAttribute(\r\n\t\t\t\t\t\t\t\tprefix,\r\n\t\t\t\t\t\t\t\tlocalName,\r\n\t\t\t\t\t\t\t\tattr.name\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tif (element.hasAttributeNS(namespace, localName)) {\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t// We can skip validation of names and duplicates\r\n\t\t\t\t\t\t\tconst attrNode = unsafeCreateAttribute(\r\n\t\t\t\t\t\t\t\tnamespace,\r\n\t\t\t\t\t\t\t\tprefix,\r\n\t\t\t\t\t\t\t\tlocalName,\r\n\t\t\t\t\t\t\t\tnormalizeAttributeValue(def.value, attr, dtd, expansionGuard),\r\n\t\t\t\t\t\t\t\telement\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tappendAttribute(attrNode, element, true);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tappendParsedNode(domContext.root, element);\r\n\t\t\t\t\tif (event.type === ParserEventType.STag) {\r\n\t\t\t\t\t\tdomContext = {\r\n\t\t\t\t\t\t\tparent: domContext,\r\n\t\t\t\t\t\t\troot: element,\r\n\t\t\t\t\t\t\tnamespaces,\r\n\t\t\t\t\t\t\tentityRoot: false,\r\n\t\t\t\t\t\t\tevent,\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcase ParserEventType.ETag:\r\n\t\t\t\t\tif (!isElement(domContext.root) || domContext.root.nodeName !== event.name) {\r\n\t\t\t\t\t\tthrowErrorWithContext(\r\n\t\t\t\t\t\t\t`non-well-formed element: found end tag \"${event.name}\" but expected ${\r\n\t\t\t\t\t\t\t\tisElement(domContext.root)\r\n\t\t\t\t\t\t\t\t\t? `\"${domContext.root.nodeName}\"`\r\n\t\t\t\t\t\t\t\t\t: 'no such tag'\r\n\t\t\t\t\t\t\t}`,\r\n\t\t\t\t\t\t\tevent\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// The check above means we never leave the document DomContext\r\n\t\t\t\t\tdomContext = domContext.parent!;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!it.value.success) {\r\n\t\t\tthrowParseError(\r\n\t\t\t\tentityContext.entity\r\n\t\t\t\t\t? `replacement text for entity ${entityContext.entity}`\r\n\t\t\t\t\t: into === doc\r\n\t\t\t\t\t? 'document'\r\n\t\t\t\t\t: 'fragment',\r\n\t\t\t\tinput,\r\n\t\t\t\tit.value.expected,\r\n\t\t\t\tit.value.offset\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tif (!domContext.entityRoot) {\r\n\t\t\tthrowErrorWithContext(\r\n\t\t\t\t`${\r\n\t\t\t\t\tentityContext.entity\r\n\t\t\t\t\t\t? `replacement text for entity \"${entityContext.entity}\"`\r\n\t\t\t\t\t\t: into === doc\r\n\t\t\t\t\t\t? 'document'\r\n\t\t\t\t\t\t: 'fragment'\r\n\t\t\t\t} is not well-formed - element \"${\r\n\t\t\t\t\tdomContext.root.nodeName\r\n\t\t\t\t}\" is missing a closing tag`,\r\n\t\t\t\tdomContext.event.name\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tentityContext = entityContext.parent;\r\n\t\tif (entityContext) {\r\n\t\t\texpansionGuard.exit();\r\n\t\t\tdomContext = domContext.parent!;\r\n\t\t}\r\n\t}\r\n\r\n\tflushCollectedText();\r\n}\r\n\r\n/**\r\n * Parse an XML fragment\r\n *\r\n * This accepts the same format as specified for external parsed entities, except that it does not\r\n * support parameter entities. That means it accepts an optional text declaration (similar to the\r\n * XML version declaration) followed by any content that may be found between an element's start and\r\n * end tags. That does not include doctype nodes.\r\n *\r\n * This parser is non-validating, and therefore does not support an external DTD or external parsed\r\n * entities. During parsing, any referenced entities are included, default attribute values are\r\n * materialized and the DTD internal subset is discarded. References to external entities are\r\n * replaced with nothing. References to parameter entities are also ignored.\r\n *\r\n * @public\r\n *\r\n * @param input   - the string to parse\r\n * @param options - allows specifying context missing from the fragment text\r\n */\r\nexport function parseXmlFragment(\r\n\tinput: string,\r\n\toptions: Partial<{\r\n\t\t/**\r\n\t\t * Called to resolve the namespace for any prefix that is not defined in the context of the\r\n\t\t * content currently being parsed. Should return the namespace URI, or undefined if a\r\n\t\t * namespace could not be resolved for the given prefix.\r\n\t\t *\r\n\t\t * @public\r\n\t\t *\r\n\t\t * @param prefix - the prefix that could not be resolved\r\n\t\t */\r\n\t\tresolveNamespacePrefix(prefix: string): string | undefined;\r\n\r\n\t\t/**\r\n\t\t * If set to true, any CDATA sections in the parsed document are converted to normal text.\r\n\t\t * Defaults to false, which means CDATA sections are represented in the DOM by CDataSection\r\n\t\t * nodes.\r\n\t\t *\r\n\t\t * @public\r\n\t\t */\r\n\t\ttreatCDataAsText: boolean;\r\n\t}> = {}\r\n): DocumentFragment {\r\n\tconst doc = new Document();\r\n\tconst fragment = doc.createDocumentFragment();\r\n\tparseXml(\r\n\t\tinput,\r\n\t\tparseFragment,\r\n\t\toptions.resolveNamespacePrefix\r\n\t\t\t? Namespaces.default(options.resolveNamespacePrefix)\r\n\t\t\t: ROOT_NAMESPACES,\r\n\t\tfragment,\r\n\t\toptions\r\n\t);\r\n\treturn fragment;\r\n}\r\n\r\n/**\r\n * Parse an XML document\r\n *\r\n * This parser is non-validating, and therefore does not support an external DTD or external parsed\r\n * entities. During parsing, any referenced entities are included, default attribute values are\r\n * materialized and the DTD internal subset is discarded. References to external entities are\r\n * replaced with nothing. References to parameter entities are also ignored.\r\n *\r\n * @public\r\n *\r\n * @param input   - the string to parse\r\n * @param options - optionally adjust protection against entity expansion attacks\r\n */\r\nexport function parseXmlDocument(input: string, options: ParseOptions = {}): Document {\r\n\tconst doc = new Document();\r\n\tparseXml(input, parseDocument, ROOT_NAMESPACES, doc, options);\r\n\treturn doc;\r\n}\r\n","import Attr from '../Attr';\nimport Element from '../Element';\nimport { isAttrNode } from '../util/NodeType';\nimport { XML_NAMESPACE, XMLNS_NAMESPACE } from '../util/namespaceHelpers';\n\nexport type PrefixIndex = { value: number };\n\n// 3.2.1.1.2 The Namespace Prefix Map\n\n/**\n * A namespace prefix map is a map that associates namespaceURI and namespace\n * prefix lists.\n *\n * This deviates from the specification to fix a number of bugs in the spec that\n * can cause it to otherwise produce non-well-formed markup or markup that does\n * not capture the author's intent.\n *\n * Instead of only tracking candidate prefixes by namespace, this also tracks\n * the current prefix to namespace mapping so we can properly detect when\n * prefixes have been redefined. This implementation also tracks maps as a tree\n * to avoid copying as well as the need to separately track locally defined\n * prefixes.\n */\nexport class NamespacePrefixMap {\n\tprivate _parent: NamespacePrefixMap | null;\n\n\tprivate _nsByPrefix = new Map<string | null, string | null>();\n\n\tprivate _prefixCandidatesByNs: Map<string | null, (string | null)[]> = new Map();\n\n\tprivate constructor(parent: NamespacePrefixMap | null) {\n\t\tthis._parent = parent;\n\t}\n\n\tpublic static new(): NamespacePrefixMap {\n\t\tconst map = new NamespacePrefixMap(null);\n\t\t// Register implicitly declared namespaces\n\t\tmap.add(null, null);\n\t\tmap.add('xml', XML_NAMESPACE);\n\t\tmap.add('xmlns', XMLNS_NAMESPACE);\n\t\treturn map;\n\t}\n\n\t/**\n\t * To add a prefix string prefix to the namespace prefix map map given a\n\t * namespace ns, the user agent should:\n\t *\n\t * @param prefix - The prefix to add\n\t * @param ns     - The namespace to add for prefix\n\t */\n\tpublic add(prefix: string | null, ns: string | null): void {\n\t\t// 1. Let candidates list be the result of retrieving a list from map where there exists a\n\t\t// key in map that matches the value of ns or if there is no such key, then let candidates\n\t\t// list be null.\n\t\t// (undefined used instead of null for convenience)\n\t\tconst candidatesList = this._prefixCandidatesByNs.get(ns);\n\n\t\t// 2. If candidates list is null, then create a new list with prefix as the only item in the\n\t\t// list, and associate that list with a new key ns in map.\n\t\tif (candidatesList === undefined) {\n\t\t\tthis._prefixCandidatesByNs.set(ns, [prefix]);\n\t\t} else {\n\t\t\t// 3. Otherwise, append prefix to the end of candidates list.\n\t\t\tcandidatesList.push(prefix);\n\t\t}\n\n\t\t// NOTE: The steps in retrieve a preferred prefix string use the list to track the most\n\t\t// recently used (MRU) prefix associated with a given namespace, which will be the prefix at\n\t\t// the end of the list. This list may contain duplicates of the same prefix value seen\n\t\t// earlier (and that's OK).\n\n\t\tthis._nsByPrefix.set(prefix, ns);\n\t}\n\n\tpublic recordNamespaceInformation(element: Element): NamespacePrefixMap {\n\t\tconst map = new NamespacePrefixMap(this);\n\t\tfor (const attr of element.attributes) {\n\t\t\tif (attr.namespaceURI !== XMLNS_NAMESPACE) {\n\t\t\t\t// Not a namespace declaration attribute\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst namespaceUri = attr.value === '' ? null : attr.value;\n\t\t\tconst definedPrefix = attr.prefix === null ? null : attr.localName;\n\t\t\tmap.add(definedPrefix, namespaceUri);\n\t\t}\n\t\treturn map;\n\t}\n\n\tprivate _localPrefixToNamespace(prefix: string | null): string | null | undefined {\n\t\treturn this._nsByPrefix.get(prefix);\n\t}\n\n\tprivate _inheritedPrefixToNamespace(prefix: string | null): string | null | undefined {\n\t\treturn this._parent?.prefixToNamespace(prefix);\n\t}\n\n\tpublic prefixToNamespace(prefix: string | null): string | null | undefined {\n\t\tconst ns = this._localPrefixToNamespace(prefix);\n\t\tif (ns !== undefined) {\n\t\t\treturn ns;\n\t\t}\n\t\treturn this._inheritedPrefixToNamespace(prefix);\n\t}\n\n\tpublic shouldSerializeDeclaration(prefix: string | null, ns: string | null): boolean {\n\t\t// An existing declaration attribute should be skipped if it doesn't\n\t\t// match the local scope. It can be skipped if it doesn't change the\n\t\t// inherited value.\n\t\treturn (\n\t\t\tthis.prefixToNamespace(prefix) === ns && this._inheritedPrefixToNamespace(prefix) !== ns\n\t\t);\n\t}\n\n\tprivate _getCandidatePrefix(\n\t\tnamespaceUri: string | null,\n\t\tallowDefault: boolean\n\t): string | null | undefined {\n\t\tlet ancestor: NamespacePrefixMap | null = this;\n\t\twhile (ancestor) {\n\t\t\tconst candidates = ancestor._prefixCandidatesByNs.get(namespaceUri);\n\t\t\tif (candidates !== undefined) {\n\t\t\t\tfor (let i = candidates.length - 1; i >= 0; --i) {\n\t\t\t\t\tconst candidate = candidates[i];\n\t\t\t\t\tif (!allowDefault && candidate === null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// Check if this candidate prefix is valid in the current scope\n\t\t\t\t\tif (this.prefixToNamespace(candidate) === namespaceUri) {\n\t\t\t\t\t\treturn candidate;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tancestor = ancestor._parent;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tpublic getPreferredPrefix(node: Element | Attr, prefixIndex: PrefixIndex): string | null {\n\t\t// XML namespace must use the \"xml\" prefix\n\t\tif (node.namespaceURI === XML_NAMESPACE) {\n\t\t\treturn 'xml';\n\t\t}\n\n\t\t// XMLNS namespace must use \"xmlns\", except for default namespace\n\t\t// declarations, which use no prefix\n\t\tconst isAttr = isAttrNode(node);\n\t\tif (node.namespaceURI === XMLNS_NAMESPACE) {\n\t\t\tif (isAttr && node.prefix === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn 'xmlns';\n\t\t}\n\n\t\t// attributes in the null namespace don't have a prefix\n\t\tif (isAttr && node.namespaceURI === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// elements use no prefix if their namespace is the inherited default\n\t\t// namespace\n\t\tif (!isAttr) {\n\t\t\tlet inheritedNs = this._inheritedPrefixToNamespace(null) ?? null;\n\t\t\tif (node.namespaceURI === inheritedNs) {\n\t\t\t\t// The caller should add this to the map to ensure that any\n\t\t\t\t// current default namespace declaration is ignored.\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// If the authored prefix resolves to the requested namespace in scope,\n\t\t// we can use it, except that attributes in a namespace can't use an\n\t\t// empty prefix.\n\t\tif (\n\t\t\t(!isAttr || node.prefix !== null) &&\n\t\t\tthis.prefixToNamespace(node.prefix) === node.namespaceURI\n\t\t) {\n\t\t\treturn node.prefix;\n\t\t}\n\n\t\t// If any prefixes in scope resolve to the requested namespace, use the\n\t\t// most recent one.\n\t\tconst candidatePrefix = this._getCandidatePrefix(node.namespaceURI, !isAttr);\n\t\tif (candidatePrefix !== undefined) {\n\t\t\treturn candidatePrefix;\n\t\t}\n\n\t\t// No suitable existing declaration, try to use the authored prefix\n\n\t\t// Attributes can't use the authored prefix if it is null or conflicts\n\t\t// with an existing local declaration\n\t\tif (isAttr) {\n\t\t\tconst namespaceForPrefix = this._localPrefixToNamespace(node.prefix);\n\t\t\tconst isValidPrefix =\n\t\t\t\tnode.prefix !== null &&\n\t\t\t\t(namespaceForPrefix === undefined || namespaceForPrefix === node.namespaceURI);\n\n\t\t\tif (!isValidPrefix) {\n\t\t\t\t// Collision - generate a new prefix\n\t\t\t\twhile (true) {\n\t\t\t\t\tconst generatedPrefix = `ns${prefixIndex.value}`;\n\t\t\t\t\tprefixIndex.value += 1;\n\t\t\t\t\tif (this._localPrefixToNamespace(generatedPrefix) === undefined) {\n\t\t\t\t\t\treturn generatedPrefix;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn node.prefix;\n\t}\n}\n","import CDATASection from '../CDATASection';\nimport Comment from '../Comment';\nimport Document from '../Document';\nimport DocumentType from '../DocumentType';\nimport Element from '../Element';\nimport Node from '../Node';\nimport ProcessingInstruction from '../ProcessingInstruction';\nimport Text from '../Text';\nimport {\n\tmatchesCharProduction,\n\tmatchesNameProduction,\n\tmatchesPubidCharProduction,\n} from '../dom-parsing/parsingAlgorithms';\nimport { throwInvalidStateError } from '../util/errorHelpers';\nimport { HTML_NAMESPACE, XML_NAMESPACE, XMLNS_NAMESPACE } from '../util/namespaceHelpers';\nimport { NodeType } from '../util/NodeType';\nimport { NamespacePrefixMap, PrefixIndex } from './NamespacePrefixMap';\n\nconst HTML_VOID_ELEMENTS = [\n\t'area',\n\t'base',\n\t'basefont',\n\t'bgsound',\n\t'br',\n\t'col',\n\t'embed',\n\t'frame',\n\t'hr',\n\t'img',\n\t'input',\n\t'keygen',\n\t'link',\n\t'menuitem',\n\t'meta',\n\t'param',\n\t'source',\n\t'track',\n\t'wbr',\n];\n\n// 3.2. Serializing\n\n/**\n * The following steps form the fragment serializing algorithm:\n *\n * @param node                - The node to serialize\n * @param requireWellFormed   - Determines whether the result needs to be well-formed\n * @param withFictionalParent - Whether to treat node as a fictional parent with node as its only\n *                              child\n *\n * @returns A string representing the serialization of node\n */\nexport function serializeFragment(\n\tnode: Node,\n\trequireWellFormed: boolean,\n\twithFictionalParent: boolean = false\n): string {\n\t// 1. Let context document be the value of node's node document.\n\t// 2. If context document is an HTML document, return an HTML serialization of node.\n\t// (HTML documents not implemented)\n\n\t// 3. Otherwise, context document is an XML document; return an XML serialization of node\n\t// passing the flag require well-formed.\n\t// Note: if implemented as stated in the spec, this would make innerHTML return the outerHTML\n\t// and make outerHTML trigger undefined behavior (the spec doesn't state the type of the\n\t// fictional node that acts as a parent). Instead, serialize the children only\n\tconst childNodes = withFictionalParent ? [node] : node.childNodes;\n\tconst result: string[] = [];\n\tfor (const child of childNodes) {\n\t\tproduceXmlSerialization(child, requireWellFormed, result);\n\t}\n\treturn result.join('');\n\n\t// NOTE: The XML serialization defined in this document conforms to the requirements of the XML\n\t// fragment serialization algorithm defined in [HTML5].\n}\n\n// 3.2.1. XML Serialization\n\n/**\n * To produce an XML serialization of a Node node given a flag require well-formed, run the\n * following steps:\n *\n * @param node              - The node to serialize\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n * @param result            - Array of strings in which to construct the result\n */\nexport function produceXmlSerialization(\n\tnode: Node,\n\trequireWellFormed: boolean,\n\tresult: string[]\n): void {\n\t// 2. Let prefix map be a new namespace prefix map.\n\tconst prefixMap = NamespacePrefixMap.new();\n\n\t// 3. Add the XML namespace with prefix value \"xml\" to prefix map.\n\t// (handled above)\n\n\t// 4. Let prefix index be a generated namespace prefix index with value 1. The generated\n\t// namespace prefix index is used to generate a new unique prefix value when no suitable\n\t// existing namespace prefix is available to serialize a node's namespaceURI (or the\n\t// namespaceURI of one of node's attributes). See the generate a prefix algorithm.\n\tconst prefixIndex: PrefixIndex = { value: 1 };\n\n\t// 5. Return the result of running the XML serialization algorithm on node passing the context\n\t// namespace namespace, namespace prefix map prefix map, generated namespace prefix index\n\t// reference to prefix index, and the flag require well-formed. If an exception occurs during\n\t// the execution of the algorithm, then catch that exception and throw an \"InvalidStateError\"\n\t// DOMException.\n\ttry {\n\t\trunXmlSerializationAlgorithm(node, prefixMap, prefixIndex, requireWellFormed, result);\n\t} catch (error) {\n\t\treturn throwInvalidStateError((error as Error).message);\n\t}\n}\n\n/**\n * The XML serialization algorithm produces an XML serialization of an arbitrary DOM node node based\n * on the node's interface type. Each referenced algorithm is to be passed the arguments as they\n * were recieved by the caller and return their result to the caller. Re-throw any exceptions.\n *\n * @param node              - The node to serialize\n * @param prefixMap         - The namespace prefix map\n * @param prefixIndex       - A reference to the generated namespace prefix index\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n * @param result            - Array of strings in which to construct the result\n *\n * @returns The serialization of node\n */\nfunction runXmlSerializationAlgorithm(\n\tnode: Node,\n\tprefixMap: NamespacePrefixMap,\n\tprefixIndex: PrefixIndex,\n\trequireWellFormed: boolean,\n\tresult: string[]\n): void {\n\t// If node's interface is:\n\tswitch (node.nodeType) {\n\t\t// Element: Run the algorithm for XML serializing an Element node node.\n\t\tcase NodeType.ELEMENT_NODE:\n\t\t\tserializeElementNode(node, prefixMap, prefixIndex, requireWellFormed, result);\n\t\t\treturn;\n\n\t\t// Document: Run the algorithm for XML serializing a Document node node.\n\t\tcase NodeType.DOCUMENT_NODE:\n\t\t\tserializeDocumentNode(node, prefixMap, prefixIndex, requireWellFormed, result);\n\t\t\treturn;\n\n\t\t// Comment: Run the algorithm for XML serializing a Comment node node.\n\t\tcase NodeType.COMMENT_NODE:\n\t\t\tserializeCommentNode(node, requireWellFormed, result);\n\t\t\treturn;\n\n\t\t// CDATASection: Run the algorithm for XML serializing a CDATASection node node.\n\t\t// Note: this is currently commented out in the DOM parsing spec, as it is based on the DOM4\n\t\t// spec which removed the CDATASection interface. It seems the interface has been restored\n\t\t// in the DOM living standard, so we'll implement its serialization as specced previously.\n\t\tcase NodeType.CDATA_SECTION_NODE:\n\t\t\tserializeCDATASectionNode(node, requireWellFormed, result);\n\t\t\treturn;\n\n\t\t// Text: Run the algorithm for XML serializing a Text node node.\n\t\tcase NodeType.TEXT_NODE:\n\t\t\tserializeTextNode(node, requireWellFormed, result);\n\t\t\treturn;\n\n\t\t// DocumentFragment: Run the algorithm for XML serializing a DocumentFragment node node.\n\t\tcase NodeType.DOCUMENT_FRAGMENT_NODE:\n\t\t\tserializeDocumentFragmentNode(node, prefixMap, prefixIndex, requireWellFormed, result);\n\t\t\treturn;\n\n\t\t// DocumentType: Run the algorithm for XML serializing a DocumentType node node.\n\t\tcase NodeType.DOCUMENT_TYPE_NODE:\n\t\t\tserializeDocumentTypeNode(node, requireWellFormed, result);\n\t\t\treturn;\n\n\t\t// ProcessingInstruction: Run the algorithm for XML serializing a ProcessingInstruction node\n\t\t// node.\n\t\tcase NodeType.PROCESSING_INSTRUCTION_NODE:\n\t\t\tserializeProcessingInstructionNode(node, requireWellFormed, result);\n\t\t\treturn;\n\n\t\t// An Attr object: Return an empty string.\n\t\tcase NodeType.ATTRIBUTE_NODE:\n\t\t\treturn;\n\n\t\t// Anything else: Throw a TypeError. Only Nodes and Attr objects can be serialized by this\n\t\t// algorithm.\n\t\t// (not reachable from public API)\n\t\t/* istanbul ignore next */\n\t\tdefault:\n\t\t\tthrow new TypeError('Only Nodes and Attr objects can be serialized by this algorithm.');\n\t}\n}\n\n/**\n * 3.2.1.1 XML serializing an Element node\n *\n * @param node              - The node to serialize\n * @param prefixMap         - The namespace prefix map\n * @param prefixIndex       - A reference to the generated namespace prefix index\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n * @param result            - Array of strings in which to construct the result\n */\nfunction serializeElementNode(\n\tnode: Node,\n\tprefixMap: NamespacePrefixMap,\n\tprefixIndex: PrefixIndex,\n\trequireWellFormed: boolean,\n\tresult: string[]\n): void {\n\tconst element = node as Element;\n\t// If the require well-formed flag is set (its value is true), and this node's localName\n\t// attribute contains the character \":\" (U+003A COLON) or does not match the XML Name\n\t// production, then throw an exception; the serialization of this node would not be a\n\t// well-formed element.\n\tif (\n\t\trequireWellFormed &&\n\t\t(element.localName.indexOf(':') >= 0 || !matchesNameProduction(element.localName))\n\t) {\n\t\tthrow new Error(\n\t\t\t`Can not serialize an element because the localName \"${element.localName}\" is not allowed.`\n\t\t);\n\t}\n\n\t// 2. Let markup be the string \"<\" (U+003C LESS-THAN SIGN).\n\tresult.push('<');\n\n\t// 3. Let qualified name be an empty string.\n\tlet qualifiedName = '';\n\n\t// 4. Let skip end tag be a boolean flag with value false.\n\tlet skipEndTag = false;\n\n\t// 5. Let ignore namespace definition attribute be a boolean flag with value false.\n\t// (alternate approach used to determine if declarations should be omitted)\n\n\t// 6. Given prefix map, copy a namespace prefix map and let map be the result.\n\tconst map = prefixMap.recordNamespaceInformation(element);\n\n\t// 7. Let local prefixes map be an empty map. The map has unique Node prefix strings as its\n\t// keys, with corresponding namespaceURI Node values as the map's key values (in this map, the\n\t// null namespace is represented by the empty string).\n\t// NOTE: This map is local to each element. It is used to ensure there are no conflicting\n\t// prefixes should a new namespace prefix attribute need to be generated. It is also used to\n\t// enable skipping of duplicate prefix definitions when writing an element's attributes: the map\n\t// allows the algorithm to distinguish between a prefix in the namespace prefix map that might\n\t// be locally-defined (to the current Element) and one that is not.\n\t// (local prefixes tracked in prefixMap)\n\n\t// 8. Let local default namespace be the result of recording the namespace information for node\n\t// given map and local prefixes map.\n\t// NOTE: The above step will update map with any found namespace prefix definitions, add the\n\t// found prefix definitions to the local prefixes map and return a local default namespace value\n\t// defined by a default namespace attribute if one exists. Otherwise it returns null.\n\t// (default namespace tracked in prefixMap)\n\n\t// 9. Let inherited ns be a copy of namespace.\n\t// (inherited namespace tracked in prefixMap)\n\n\t// 10. Let ns be the value of node's namespaceURI attribute.\n\t// (unnecessary alias)\n\n\t// (various branches omitted as the specification contains bugs)\n\n\t// 12.3. If the value of prefix matches \"xmlns\", then run the following steps:\n\t// 12.3.1. If the require well-formed flag is set, then throw an error. An Element with\n\t// prefix \"xmlns\" will not legally round-trip in a conforming XML parser.\n\tif (element.prefix === 'xmlns' && requireWellFormed) {\n\t\tthrow new Error(\n\t\t\t'Can not serialize an element with prefix \"xmlns\" because it will ' +\n\t\t\t\t'not legally round-trip in a conforming XML parser.'\n\t\t);\n\t}\n\n\tconst prefix = map.getPreferredPrefix(element, prefixIndex);\n\n\tif (prefix !== null) {\n\t\tqualifiedName += `${prefix}:`;\n\t}\n\tqualifiedName += element.localName;\n\tresult.push(qualifiedName);\n\n\tif (map.prefixToNamespace(prefix) !== element.namespaceURI) {\n\t\t// We may have redeclared this prefix or default namespace\n\t\tmap.add(prefix, element.namespaceURI);\n\n\t\tif (prefix === null) {\n\t\t\tresult.push(' xmlns=\"');\n\t\t} else {\n\t\t\tresult.push(' xmlns:', prefix, '=\"');\n\t\t}\n\t\tresult.push(serializeAttributeValue(element.namespaceURI, requireWellFormed), '\"');\n\t}\n\n\t// 13. Append to markup the result of the XML serialization of node's attributes given map,\n\t// prefix index, local prefixes map, ignore namespace definition attribute flag, and require\n\t// well-formed flag.\n\tserializeAttributes(element, map, prefixIndex, requireWellFormed, result);\n\n\t// 14. If ns is the HTML namespace, and the node's list of children is empty, and the node's\n\t// localName matches any one of the following void elements: \"area\", \"base\", \"basefont\",\n\t// \"bgsound\", \"br\", \"col\", \"embed\", \"frame\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"menuitem\",\n\t// \"meta\", \"param\", \"source\", \"track\", \"wbr\"; then append the following to markup, in the order\n\t// listed:\n\tif (\n\t\telement.namespaceURI === HTML_NAMESPACE &&\n\t\t!element.hasChildNodes() &&\n\t\tHTML_VOID_ELEMENTS.indexOf(element.localName) >= 0\n\t) {\n\t\t// 14.1. \" \" (U+0020 SPACE);\n\t\t// 14.2. \"/\" (U+002F SOLIDUS).\n\t\tresult.push(' /');\n\n\t\t// and set the skip end tag flag to true.\n\t\tskipEndTag = true;\n\t}\n\n\t// 15. If ns is not the HTML namespace, and the node's list of children is empty, then append\n\t// \"/\" (U+002F SOLIDUS) to markup and set the skip end tag flag to true.\n\tif (element.namespaceURI !== HTML_NAMESPACE && !element.hasChildNodes()) {\n\t\tresult.push('/');\n\t\tskipEndTag = true;\n\t}\n\n\t// 16. Append \">\" (U+003E GREATER-THAN SIGN) to markup.\n\tresult.push('>');\n\n\t// 17. If the value of skip end tag is true, then return the value of markup and skip the\n\t// remaining steps. The node is a leaf-node.\n\tif (skipEndTag) {\n\t\treturn;\n\t}\n\n\t// 18. If ns is the HTML namespace, and the node's localName matches the string \"template\", then\n\t// this is a template element. Append to markup the result of XML serializing a DocumentFragment\n\t// node given the template element's template contents (a DocumentFragment), providing inherited\n\t// ns, map, prefix index, and the require well-formed flag.\n\t// NOTE: This allows template content to round-trip , given the rules for parsing XHTML\n\t// documents.\n\t// (HTML documents not implemented)\n\n\t// 19. Otherwise, append to markup the result of running the XML serialization algorithm on each\n\t// of node's children, in tree order, providing inherited ns, map, prefix index, and the require\n\t// well-formed flag.\n\tfor (const child of node.childNodes) {\n\t\trunXmlSerializationAlgorithm(child, map, prefixIndex, requireWellFormed, result);\n\t}\n\n\t// 20. Append the following to markup, in the order listed:\n\t// 20.1. \"</\" (U+003C LESS-THAN SIGN, U+002F SOLIDUS);\n\t// 20.2. The value of qualified name;\n\t// 20.3. \">\" (U+003E GREATER-THAN SIGN).\n\tresult.push('</', qualifiedName, '>');\n\n\t// 21. Return the value of markup.\n}\n\n// 3.2.1.1.3 Serializing an Element's attributes\n\n/**\n * The XML serialization of the attributes of an Element element together with a namespace prefix\n * map map, a generated namespace prefix index prefix index reference, a local prefixes map, a\n * ignore namespace definition attribute flag, and a require well-formed flag, is the result of the\n * following algorithm:\n *\n * @param element                            - The element for which to serialize attributes\n * @param prefixMap                          - The namespace prefix map\n * @param prefixIndex                        - The generated namespace prefix index, by reference\n * @param localPrefixesMap                   - The local prefixes map\n * @param ignoreNamespaceDefinitionAttribute - The ignore namespace definition attribute flag\n * @param requireWellFormed                  - The require well-formed flag\n * @param result                             - Array of strings in which to construct the result\n */\nfunction serializeAttributes(\n\telement: Element,\n\tmap: NamespacePrefixMap,\n\tprefixIndex: PrefixIndex,\n\trequireWellFormed: boolean,\n\tresult: string[]\n): void {\n\t// 1. Let result be the empty string.\n\t// (result constructed in-place in argument)\n\n\t// 2. Let localname set be a new empty namespace localname set. This localname set will contain\n\t// tuples of unique attribute namespaceURI and localName pairs, and is populated as each attr is\n\t// processed. This set is used to [optionally] enforce the well-formed constraint that an\n\t// element cannot have two attributes with the same namespaceURI and localName. This can occur\n\t// when two otherwise identical attributes on the same element differ only by their prefix\n\t// values.\n\tconst localNameSet: { namespaceURI: string | null; localName: string }[] = [];\n\n\t// 3. Loop: For each attribute attr in element's attributes, in the order they are specified in\n\t// the element's attribute list:\n\tfor (const attr of element.attributes) {\n\t\t// (various branches omitted as the specification contains bugs)\n\t\tlet prefix = map.getPreferredPrefix(attr, prefixIndex);\n\n\t\tif (attr.namespaceURI === XMLNS_NAMESPACE) {\n\t\t\t// Namespace declaration attribute\n\t\t\tconst declaredNamespaceUri = attr.value === '' ? null : attr.value;\n\n\t\t\t// 3.5.2.2. If the require well-formed flag is set (its value is\n\t\t\t// true), and the value of attr's value attribute matches the XMLNS\n\t\t\t// namespace, then throw an exception; the serialization of this\n\t\t\t// attribute would produce invalid XML because the XMLNS namespace\n\t\t\t// is reserved and cannot be applied as an element's namespace via\n\t\t\t// XML parsing.\n\t\t\t// NOTE: DOM APIs do allow creation of elements in the XMLNS\n\t\t\t// namespace but with strict qualifications.\n\t\t\tif (requireWellFormed && declaredNamespaceUri === XMLNS_NAMESPACE) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'The serialization of this attribute would produce invalid XML because ' +\n\t\t\t\t\t\t'the XMLNS namespace is reserved and cannot be applied as an ' +\n\t\t\t\t\t\t\"element's namespace via XML parsing.\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Don't declare the XML or XMLNS namespaces\n\t\t\tif (\n\t\t\t\tdeclaredNamespaceUri === XML_NAMESPACE ||\n\t\t\t\tdeclaredNamespaceUri === XMLNS_NAMESPACE\n\t\t\t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst declaredPrefix = attr.prefix === null ? null : attr.localName;\n\t\t\t// 3.5.2.3. If the require well-formed flag is set (its value is\n\t\t\t// true), and the value of attr's value attribute is the empty\n\t\t\t// string, then throw an exception; namespace prefix declarations\n\t\t\t// cannot be used to undeclare a namespace (use a default namespace\n\t\t\t// declaration instead).\n\t\t\t// (we deviate from the spec here by only throwing for prefix\n\t\t\t// declarations, the implementations of this in browsers and the\n\t\t\t// spec text suggest that default namespace declarations should be\n\t\t\t// allowed to reset the default namespace to null)\n\t\t\tif (requireWellFormed && attr.prefix !== null && attr.value === '') {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Namespace prefix declarations cannot be used to undeclare a namespace. ' +\n\t\t\t\t\t\t'Use a default namespace declaration instead.'\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// The following does not cause an ordering issue as prefixes\n\t\t\t// determined for attributes on the current element will not cause\n\t\t\t// this to change.\n\t\t\tif (!map.shouldSerializeDeclaration(declaredPrefix, declaredNamespaceUri)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// 3.1. If the require well-formed flag is set (its value is true), and the localname set\n\t\t// contains a tuple whose values match those of a new tuple consisting of attr's\n\t\t// namespaceURI attribute and localName attribute, then throw an exception; the\n\t\t// serialization of this attr would fail to produce a well-formed element serialization.\n\t\tif (\n\t\t\trequireWellFormed &&\n\t\t\tlocalNameSet.find(\n\t\t\t\t(tuple) =>\n\t\t\t\t\ttuple.localName === attr.localName && tuple.namespaceURI === attr.namespaceURI\n\t\t\t)\n\t\t) {\n\t\t\tthrow new Error(\n\t\t\t\t`Can not serialize a duplicate attribute for namespaceURI \"${attr.namespaceURI}\", localName \"${attr.localName}\".`\n\t\t\t);\n\t\t}\n\n\t\t// 3.2. Create a new tuple consisting of attr's namespaceURI attribute and localName\n\t\t// attribute, and add it to the localname set.\n\t\tlocalNameSet.push({ namespaceURI: attr.namespaceURI, localName: attr.localName });\n\n\t\t// 3.8. If the require well-formed flag is set (its value is true), and this attr's\n\t\t// localName attribute contains the character \":\" (U+003A COLON) or does not match the XML\n\t\t// Name production or equals \"xmlns\" and attribute namespace is null, then throw an\n\t\t// exception; the serialization of this attr would not be a well-formed attribute.\n\t\tif (\n\t\t\trequireWellFormed &&\n\t\t\t(attr.localName.indexOf(':') >= 0 ||\n\t\t\t\t!matchesNameProduction(attr.localName) ||\n\t\t\t\t(attr.localName === 'xmlns' && attr.namespaceURI === null))\n\t\t) {\n\t\t\tthrow new Error(\n\t\t\t\t`Can not serialize an attribute because the localName \"${attr.localName}\" is not allowed.`\n\t\t\t);\n\t\t}\n\n\t\t// Do we need a declaration?\n\t\tif (prefix !== null && map.prefixToNamespace(prefix) !== attr.namespaceURI) {\n\t\t\tresult.push(\n\t\t\t\t' xmlns:',\n\t\t\t\tprefix,\n\t\t\t\t'=\"',\n\t\t\t\tserializeAttributeValue(attr.namespaceURI, requireWellFormed),\n\t\t\t\t'\"'\n\t\t\t);\n\t\t\tmap.add(prefix, attr.namespaceURI);\n\t\t}\n\n\t\tresult.push(' ');\n\t\tif (prefix !== null) {\n\t\t\tresult.push(prefix, ':');\n\t\t}\n\t\tresult.push(\n\t\t\tattr.localName,\n\t\t\t'=\"',\n\t\t\tserializeAttributeValue(attr.value, requireWellFormed),\n\t\t\t'\"'\n\t\t);\n\t}\n\n\t// 4. Return the value of result.\n}\n\n/**\n * When serializing an attribute value given an attribute value and require well-formed flag, the\n * user agent must run the following steps:\n *\n * @param attributeValue    - The attribute value to serialize\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n *\n * @returns The serialized attribute value\n */\nfunction serializeAttributeValue(\n\tattributeValue: string | null,\n\trequireWellFormed: boolean\n): string {\n\t// 1. If the require well-formed flag is set (its value is true), and attribute value contains\n\t// characters that are not matched by the XML Char production, then throw an exception; the\n\t// serialization of this attribute value would fail to produce a well-formed element\n\t// serialization.\n\tif (requireWellFormed && attributeValue !== null && !matchesCharProduction(attributeValue)) {\n\t\tthrow new Error(\n\t\t\t'Can not serialize an attribute value because it contains invalid characters.'\n\t\t);\n\t}\n\n\t// 2. If attribute value is null, then return the empty string.\n\tif (attributeValue === null) {\n\t\treturn '';\n\t}\n\n\t// 3. Otherwise, attribute value is a string. Return the value of attribute value, first\n\t// replacing any occurrences of the following:\n\treturn (\n\t\tattributeValue\n\t\t\t// 3.1. \"&\" with \"&amp;\"\n\t\t\t.replace(/&/g, '&amp;')\n\t\t\t// 3.2. \"\"\" with \"&quot;\"\n\t\t\t.replace(/\"/g, '&quot;')\n\t\t\t// 3.3. \"<\" with \"&lt;\"\n\t\t\t.replace(/</g, '&lt;')\n\t\t\t// 3.4. \">\" with \"&gt;\"\n\t\t\t.replace(/>/g, '&gt;')\n\t\t\t// (we deviate from the spec here to also escape whitespace characters, this matches\n\t\t\t// the behavior of Chrome, Firefox and Edge, although the specific encoding varies\n\t\t\t// between those browsers)\n\t\t\t.replace(/\\t/g, '&#9;')\n\t\t\t.replace(/\\n/g, '&#10;')\n\t\t\t.replace(/\\r/g, '&#13;')\n\t);\n\n\t// NOTE: This matches behavior present in browsers, and goes above and beyond the grammar\n\t// requirement in the XML specification's AttValue production by also replacing \">\" characters.\n}\n\n/**\n * 3.2.1.2 XML serializing a Document node\n *\n * @param node              - The node to serialize\n * @param prefixMap         - The namespace prefix map\n * @param prefixIndex       - A reference to the generated namespace prefix index\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n * @param result            - Array of strings in which to construct the result\n */\nfunction serializeDocumentNode(\n\tnode: Node,\n\tprefixMap: NamespacePrefixMap,\n\tprefixIndex: PrefixIndex,\n\trequireWellFormed: boolean,\n\tresult: string[]\n): void {\n\tconst document = node as Document;\n\t// 1. If the require well-formed flag is set (its value is true), and this node has no\n\t// documentElement (the documentElement attribute's value is null), then throw an exception; the\n\t// serialization of this node would not be a well-formed document.\n\tif (requireWellFormed && document.documentElement === null) {\n\t\tthrow new Error('Can not serialize a document with no documentElement.');\n\t}\n\n\t// 2. Otherwise, run the following steps:\n\n\t// 2.1. Let serialized document be an empty string.\n\t// (constructed in-place in result argument)\n\n\t// 2.2. For each child child of node, in tree order, run the XML serialization algorithm on the\n\t// child passing along the provided arguments, and append the result to serialized document.\n\t// NOTE: This will serialize any number of ProcessingInstruction and Comment nodes both before\n\t// and after the Document's documentElement node, including at most one DocumentType node. (Text\n\t// nodes are not allowed as children of the Document.)\n\tfor (const child of document.childNodes) {\n\t\trunXmlSerializationAlgorithm(child, prefixMap, prefixIndex, requireWellFormed, result);\n\t}\n\n\t// 2.3. Return the value of serialized document.\n}\n\n/**\n * 3.2.1.3 XML serializing a Comment node\n *\n * @param node              - The node to serialize\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n * @param result            - Array of strings in which to construct the result\n */\nfunction serializeCommentNode(node: Node, requireWellFormed: boolean, result: string[]): void {\n\tconst comment = node as Comment;\n\t// 1. If the require well-formed flag is set (its value is true), and node's data contains\n\t// characters that are not matched by the XML Char production or contains \"--\" (two adjacent\n\t// U+002D HYPHEN-MINUS characters) or that ends with a \"-\" (U+002D HYPHEN-MINUS) character, then\n\t// throw an exception; the serialization of this node's data would not be well-formed.\n\tif (\n\t\trequireWellFormed &&\n\t\t(!matchesCharProduction(comment.data) ||\n\t\t\tcomment.data.indexOf('--') >= 0 ||\n\t\t\tcomment.data.endsWith('-'))\n\t) {\n\t\tthrow new Error('Can not serialize a comment because it contains invalid characters.');\n\t}\n\n\t// 2. Otherwise, return the concatenation of \"<!--\", node's data, and \"-->\".\n\tresult.push('<!--', comment.data, '-->');\n}\n\n/**\n * (not currently in spec) XML serializing a CDATASection node\n *\n * @param node              - The node to serialize\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n * @param result            - Array of strings in which to construct the result\n */\nfunction serializeCDATASectionNode(node: Node, requireWellFormed: boolean, result: string[]): void {\n\tconst cs = node as CDATASection;\n\n\t// 1. Let markup be the concatenation of \"<![CDATA[\", node's data, and \"]]>\".\n\tresult.push('<![CDATA[', cs.data, ']]>');\n\n\t// 2. Return the value of markup.\n}\n\n/**\n * 3.2.1.4 XML serializing a Text node\n *\n * @param node              - The node to serialize\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n * @param result            - Array of strings in which to construct the result\n */\nfunction serializeTextNode(node: Node, requireWellFormed: boolean, result: string[]): void {\n\tconst text = node as Text;\n\t// 1. If the require well-formed flag is set (its value is true), and node's data contains\n\t// characters that are not matched by the XML Char production, then throw an exception; the\n\t// serialization of this node's data would not be well-formed.\n\tif (requireWellFormed && !matchesCharProduction(text.data)) {\n\t\tthrow new Error('Can not serialize a text node because it contains invalid characters.');\n\t}\n\n\t// 2. Let markup be the value of node's data.\n\tlet markup = text.data;\n\n\t// 3. Replace any occurrences of \"&\" in markup by \"&amp;\".\n\tmarkup = markup.replace(/&/g, '&amp;');\n\n\t// 4. Replace any occurrences of \"<\" in markup by \"&lt;\".\n\tmarkup = markup.replace(/</g, '&lt;');\n\n\t// 5. Replace any occurrences of \">\" in markup by \"&gt;\".\n\tmarkup = markup.replace(/>/g, '&gt;');\n\n\t// 6. Return the value of markup.\n\tresult.push(markup);\n}\n\n/**\n * 3.2.1.5 XML serializing a DocumentFragment node\n *\n * @param node              - The node to serialize\n * @param prefixMap         - The namespace prefix map\n * @param prefixIndex       - A reference to the generated namespace prefix index\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n * @param result            - Array of strings in which to construct the result\n */\nfunction serializeDocumentFragmentNode(\n\tnode: Node,\n\tprefixMap: NamespacePrefixMap,\n\tprefixIndex: PrefixIndex,\n\trequireWellFormed: boolean,\n\tresult: string[]\n): void {\n\t// 1. Let markup the empty string.\n\t// (constructed in-place in result argument)\n\n\t// 2. For each child child of node, in tree order, run the XML serialization algorithm on the\n\t// child given namespace, prefix map, a reference to prefix index, and flag require well-formed.\n\t// Concatenate the result to markup.\n\tfor (const child of node.childNodes) {\n\t\trunXmlSerializationAlgorithm(child, prefixMap, prefixIndex, requireWellFormed, result);\n\t}\n\n\t// 3. Return the value of markup.\n}\n\n/**\n * 3.2.1.6 XML serializing a DocumentType node\n *\n * @param node              - The node to serialize\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n * @param result            - Array of strings in which to construct the result\n */\nfunction serializeDocumentTypeNode(node: Node, requireWellFormed: boolean, result: string[]): void {\n\tconst dt = node as DocumentType;\n\t// 1. If the require well-formed flag is true and the node's publicId attribute contains\n\t// characters that are not matched by the XML PubidChar production, then throw an exception; the\n\t// serialization of this node would not be a well-formed document type declaration.\n\tif (requireWellFormed && !matchesPubidCharProduction(dt.publicId)) {\n\t\tthrow new Error(\n\t\t\t'Can not serialize a document type because the publicId contains invalid characters.'\n\t\t);\n\t}\n\n\t// 2. If the require well-formed flag is true and the node's systemId attribute contains\n\t// characters that are not matched by the XML Char production or that contains both a \"\"\"\n\t// (U+0022 QUOTATION MARK) and a \"'\" (U+0027 APOSTROPHE), then throw an exception; the\n\t// serialization of this node would not be a well-formed document type declaration.\n\tif (\n\t\trequireWellFormed &&\n\t\t(!matchesCharProduction(dt.systemId) ||\n\t\t\t(dt.systemId.indexOf('\"') >= 0 && dt.systemId.indexOf(\"'\") >= 0))\n\t) {\n\t\tthrow new Error(\n\t\t\t'Can not serialize a document type because the systemId contains invalid characters.'\n\t\t);\n\t}\n\n\t// 3. Let markup be an empty string.\n\t// (constructed in-place in result argument)\n\n\t// 4. Append the string \"<!DOCTYPE\" to markup.\n\tresult.push('<!DOCTYPE');\n\n\t// 5. Append \" \" (U+0020 SPACE) to markup.\n\tresult.push(' ');\n\n\t// 6. Append the value of the node's name attribute to markup. For a node belonging to an HTML\n\t// document, the value will be all lowercase.\n\t// (HTML documents not implemented)\n\tresult.push(dt.name);\n\n\t// 7. If the node's publicId is not the empty string then append the following, in the order\n\t// listed, to markup:\n\tif (dt.publicId !== '') {\n\t\t// 7.1. \" \" (U+0020 SPACE);\n\t\t// 7.2. The string \"PUBLIC\";\n\t\t// 7.3. \" \" (U+0020 SPACE);\n\t\t// 7.4. \"\"\" (U+0022 QUOTATION MARK);\n\t\t// 7.5. The value of the node's publicId attribute;\n\t\t// 7.6. \"\"\" (U+0022 QUOTATION MARK).\n\t\tresult.push(' PUBLIC \"', dt.publicId, '\"');\n\t}\n\n\t// 8. If the node's systemId is not the empty string and the node's publicId is set to the empty\n\t// string, then append the following, in the order listed, to markup:\n\tif (dt.systemId !== '' && dt.publicId === '') {\n\t\t// 8.1. \" \" (U+0020 SPACE);\n\t\t// 8.2. The string \"SYSTEM\".\n\t\tresult.push(' SYSTEM');\n\t}\n\n\t// 9. If the node's systemId is not the empty string then append the following, in the order\n\t// listed, to markup:\n\tif (dt.systemId !== '') {\n\t\t// 9.1. \" \" (U+0020 SPACE);\n\t\t// 9.2. \"\"\" (U+0022 QUOTATION MARK);\n\t\t// 9.3. The value of the node's systemId attribute;\n\t\t// 9.4. \"\"\" (U+0022 QUOTATION MARK).\n\t\tresult.push(' \"', dt.systemId, '\"');\n\t}\n\n\t// 10. Append \">\" (U+003E GREATER-THAN SIGN) to markup.\n\tresult.push('>');\n\n\t// 11. Return the value of markup.\n}\n\n/**\n * 3.2.1.7 XML serializing a ProcessingInstruction node\n *\n * @param node              - The node to serialize\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n * @param result            - Array of strings in which to construct the result\n */\nfunction serializeProcessingInstructionNode(\n\tnode: Node,\n\trequireWellFormed: boolean,\n\tresult: string[]\n): void {\n\tconst pi = node as ProcessingInstruction;\n\t// 1. If the require well-formed flag is set (its value is true), and node's target contains a\n\t// \":\" (U+003A COLON) character or is an ASCII case-insensitive match for the string \"xml\", then\n\t// throw an exception; the serialization of this node's target would not be well-formed.\n\tif (requireWellFormed) {\n\t\tif (pi.target.indexOf(':') >= 0) {\n\t\t\tthrow new Error(\n\t\t\t\t`Can not serialize a processing instruction because the target \"${pi.target}\" may not contain \":\".`\n\t\t\t);\n\t\t}\n\t\tif (pi.target.toLowerCase() === 'xml') {\n\t\t\tthrow new Error(\n\t\t\t\t'Can not serialize a processing instruction because \"xml\" may not be used as target.'\n\t\t\t);\n\t\t}\n\t}\n\n\t// 2. If the require well-formed flag is set (its value is true), and node's data contains\n\t// characters that are not matched by the XML Char production or contains the string \"?>\"\n\t// (U+003F QUESTION MARK, U+003E GREATER-THAN SIGN), then throw an exception; the serialization\n\t// of this node's data would not be well-formed.\n\tif (requireWellFormed && (!matchesCharProduction(pi.data) || pi.data.indexOf('?>') >= 0)) {\n\t\tthrow new Error(\n\t\t\t'Can not serialize a processing instruction because the data contains invalid characters.'\n\t\t);\n\t}\n\n\t// 3. Let markup be the concatenation of the following, in the order listed:\n\t// 3.1. \"<?\" (U+003C LESS-THAN SIGN, U+003F QUESTION MARK);\n\t// 3.2. The value of node's target;\n\t// 3.3. \" \" (U+0020 SPACE);\n\t// 3.4. The value of node's data;\n\t// 3.5. \"?>\" (U+003F QUESTION MARK, U+003E GREATER-THAN SIGN).\n\tresult.push('<?', pi.target, ' ', pi.data, '?>');\n\n\t// 4. Return the value of markup.\n}\n","import { ParentNode, NonDocumentTypeChildNode, ChildNode } from './mixins';\nimport { getChildren, getPreviousElementSibling, getNextElementSibling } from './mixins';\nimport Attr from './Attr';\nimport Document from './Document';\nimport Node from './Node';\nimport { getContext } from './context/Context';\nimport { matchesNameProduction } from './dom-parsing/parsingAlgorithms';\nimport { serializeFragment } from './dom-parsing/serializationAlgorithms';\nimport {\n\tappendNodes,\n\tgetDescendantTextContent,\n\tinsertNodesAfter,\n\tinsertNodesBefore,\n\tprependNodes,\n\tremoveFromParent,\n\treplaceChildren,\n\treplaceWithNodes,\n\tstringReplaceAll,\n} from './util/mutationAlgorithms';\nimport {\n\tappendAttribute,\n\tchangeAttribute,\n\tremoveAttribute,\n\treplaceAttribute,\n} from './util/attrMutations';\nimport {\n\texpectArity,\n\tthrowInUseAttributeError,\n\tthrowInvalidCharacterError,\n\tthrowNotFoundError,\n} from './util/errorHelpers';\nimport {\n\tvalidateAndExtract,\n\tlocateNamespacePrefix,\n\tXMLNS_NAMESPACE,\n} from './util/namespaceHelpers';\nimport { NodeType } from './util/NodeType';\nimport { asNullableString, asObject, ifNullActAsIfEmptyString } from './util/typeHelpers';\nimport {\n\tgetListOfElementsWithNamespaceAndLocalName,\n\tgetListOfElementsWithQualifiedName,\n} from './util/treeHelpers';\n\n/**\n * 3.9. Interface Element\n *\n * @public\n */\nexport default class Element\n\textends Node\n\timplements ParentNode, NonDocumentTypeChildNode, ChildNode\n{\n\t// Node\n\n\tpublic get nodeType(): number {\n\t\treturn NodeType.ELEMENT_NODE;\n\t}\n\n\tpublic get nodeName(): string {\n\t\treturn this.tagName;\n\t}\n\n\tpublic get nodeValue(): string | null {\n\t\treturn null;\n\t}\n\n\tpublic set nodeValue(newValue: string | null) {\n\t\t// Do nothing.\n\t}\n\n\tpublic get textContent(): string | null {\n\t\t// Return the descendant text content of this\n\t\treturn getDescendantTextContent(this);\n\t}\n\n\tpublic set textContent(newValue: string | null) {\n\t\tnewValue = ifNullActAsIfEmptyString(newValue);\n\t\tstringReplaceAll(this, newValue);\n\t}\n\n\tpublic lookupPrefix(namespace: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\t\tnamespace = asNullableString(namespace);\n\n\t\t// 1. If namespace is null or the empty string, then return null.\n\t\tif (namespace === null || namespace === '') {\n\t\t\treturn null;\n\t\t}\n\n\t\t// 2. Switch on this:\n\t\t// Element - Return the result of locating a namespace prefix for it using namespace.\n\t\treturn locateNamespacePrefix(this, namespace);\n\t}\n\n\tpublic lookupNamespaceURI(prefix: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\t\tprefix = asNullableString(prefix);\n\n\t\t// 1. If prefix is the empty string, then set it to null.\n\t\tif (prefix === '') {\n\t\t\tprefix = null;\n\t\t}\n\n\t\t// 2. Return the result of running locate a namespace for this using prefix.\n\n\t\t// To locate a namespace for a node using prefix, switch on node: Element\n\t\t// 1. If its namespace is non-null and its namespace prefix is prefix, then return\n\t\t// namespace.\n\t\tif (this.namespaceURI !== null && this.prefix === prefix) {\n\t\t\treturn this.namespaceURI;\n\t\t}\n\n\t\t// 2. If it has an attribute whose namespace is the XMLNS namespace, namespace prefix is\n\t\t// \"xmlns\", and local name is prefix, or if prefix is null and it has an attribute whose\n\t\t// namespace is the XMLNS namespace, namespace prefix is null, and local name is \"xmlns\",\n\t\t// then return its value if it is not the empty string, and null otherwise.\n\t\tlet ns = null;\n\t\tif (prefix !== null) {\n\t\t\tconst attr = this.getAttributeNodeNS(XMLNS_NAMESPACE, prefix);\n\t\t\tif (attr && attr.prefix === 'xmlns') {\n\t\t\t\tns = attr.value;\n\t\t\t}\n\t\t} else {\n\t\t\tconst attr = this.getAttributeNodeNS(XMLNS_NAMESPACE, 'xmlns');\n\t\t\tif (attr && attr.prefix === null) {\n\t\t\t\tns = attr.value;\n\t\t\t}\n\t\t}\n\t\tif (ns !== null) {\n\t\t\treturn ns !== '' ? ns : null;\n\t\t}\n\n\t\t// 3. If its parent element is null, then return null.\n\t\tconst parentElement = this.parentElement;\n\t\tif (parentElement === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// 4. Return the result of running locate a namespace on its parent element using prefix.\n\t\treturn parentElement.lookupNamespaceURI(prefix);\n\t}\n\n\t// ChildNode\n\n\tpublic before(...nodes: (Node | string)[]): void {\n\t\tinsertNodesBefore(this, nodes);\n\t}\n\n\tpublic after(...nodes: (Node | string)[]): void {\n\t\tinsertNodesAfter(this, nodes);\n\t}\n\n\tpublic replaceWith(...nodes: (Node | string)[]): void {\n\t\treplaceWithNodes(this, nodes);\n\t}\n\n\tpublic remove(): void {\n\t\tremoveFromParent(this);\n\t}\n\n\t// ParentNode\n\n\tpublic get children(): Element[] {\n\t\treturn getChildren(this);\n\t}\n\n\tpublic firstElementChild: Element | null = null;\n\tpublic lastElementChild: Element | null = null;\n\tpublic childElementCount: number = 0;\n\n\tpublic prepend(...nodes: (Node | string)[]): void {\n\t\tprependNodes(this, nodes);\n\t}\n\n\tpublic append(...nodes: (Node | string)[]): void {\n\t\tappendNodes(this, nodes);\n\t}\n\n\tpublic replaceChildren(...nodes: (Node | string)[]): void {\n\t\treplaceChildren(this, nodes);\n\t}\n\n\t// NonDocumentTypeChildNode\n\n\tpublic get previousElementSibling(): Element | null {\n\t\treturn getPreviousElementSibling(this);\n\t}\n\n\tpublic get nextElementSibling(): Element | null {\n\t\treturn getNextElementSibling(this);\n\t}\n\n\t// Element\n\n\tpublic readonly namespaceURI: string | null;\n\tpublic readonly prefix: string | null;\n\tpublic readonly localName: string;\n\tpublic readonly tagName: string;\n\n\t/**\n\t * (non-standard) Use Document#createElement or Document#createElementNS to create an Element.\n\t *\n\t * @param namespace - Namespace for the element\n\t * @param prefix    - Prefix for the element\n\t * @param localName - Local name for the element\n\t */\n\tconstructor(namespace: string | null, prefix: string | null, localName: string) {\n\t\tsuper();\n\n\t\tthis.namespaceURI = namespace;\n\t\tthis.prefix = prefix;\n\t\tthis.localName = localName;\n\t\tthis.tagName = prefix === null ? localName : `${prefix}:${localName}`;\n\t}\n\n\t/**\n\t * Returns whether the element has any attributes.\n\t *\n\t * @returns True if the element has attributes, otherwise false\n\t */\n\tpublic hasAttributes(): boolean {\n\t\treturn this.attributes.length > 0;\n\t}\n\n\t/**\n\t * The attributes for the element.\n\t *\n\t * Non-standard: the spec defines this as a NamedNodeMap, while this implementation uses an\n\t * array.\n\t */\n\tpublic readonly attributes: Attr[] = [];\n\n\t/**\n\t * Get the value of the specified attribute.\n\t *\n\t * @param qualifiedName - The qualified name of the attribute\n\t *\n\t * @returns The value of the attribute, or null if no such attribute exists\n\t */\n\tpublic getAttribute(qualifiedName: string): string | null {\n\t\texpectArity(arguments, 1);\n\t\tqualifiedName = String(qualifiedName);\n\n\t\t// 1. Let attr be the result of getting an attribute given qualifiedName and the context\n\t\t// object.\n\t\tconst attr = getAttributeByName(qualifiedName, this);\n\n\t\t// 2. If attr is null, return null.\n\t\tif (attr === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// 3. Return attr’s value.\n\t\treturn attr.value;\n\t}\n\n\t/**\n\t * Get the value of the specified attribute.\n\t *\n\t * @param namespace - The namespace of the attribute\n\t * @param localName - The local name of the attribute\n\t *\n\t * @returns The value of the attribute, or null if no such attribute exists\n\t */\n\tpublic getAttributeNS(namespace: string | null, localName: string): string | null {\n\t\texpectArity(arguments, 2);\n\t\tnamespace = asNullableString(namespace);\n\t\tlocalName = String(localName);\n\n\t\t// 1. Let attr be the result of getting an attribute given namespace, localName, and the\n\t\t// this.\n\t\tconst attr = getAttributeByNamespaceAndLocalName(namespace, localName, this);\n\n\t\t// 2. If attr is null, return null.\n\t\tif (attr === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// 3. Return attr’s value.\n\t\treturn attr.value;\n\t}\n\n\t/**\n\t * Sets the value of the specified attribute.\n\t *\n\t * @param qualifiedName - The qualified name of the attribute\n\t * @param value         - The new value for the attribute\n\t */\n\tpublic setAttribute(qualifiedName: string, value: string): void {\n\t\texpectArity(arguments, 2);\n\t\tqualifiedName = String(qualifiedName);\n\t\tvalue = String(value);\n\n\t\t// 1. If qualifiedName does not match the Name production in XML, then throw an\n\t\t// InvalidCharacterError.\n\t\tif (!matchesNameProduction(qualifiedName)) {\n\t\t\tthrowInvalidCharacterError('The qualified name does not match the Name production');\n\t\t}\n\n\t\t// 2. If this is in the HTML namespace and its node document is an HTML\n\t\t// document, then set qualifiedName to qualifiedName in ASCII lowercase.\n\t\t// (html documents not implemented)\n\n\t\t// 3. Let attribute be the first attribute in this’s attribute list whose\n\t\t// qualified name is qualifiedName, and null otherwise.\n\t\tconst attribute = getAttributeByName(qualifiedName, this);\n\n\t\t// 4. If attribute is null, create an attribute whose local name is qualifiedName, value is\n\t\t// value, and node document is this’s node document, then append this attribute to\n\t\t// this, and then return.\n\t\tif (attribute === null) {\n\t\t\tconst context = getContext(this);\n\t\t\tconst attribute = new context.Attr(null, null, qualifiedName, value, this);\n\t\t\tattribute.ownerDocument = this.ownerDocument;\n\t\t\tappendAttribute(attribute, this);\n\t\t\treturn;\n\t\t}\n\n\t\t// 5. Change attribute to value.\n\t\tchangeAttribute(attribute, value);\n\t}\n\n\t/**\n\t * Sets the value of the specified attribute.\n\t *\n\t * @param namespace     - The namespace of the attribute\n\t * @param qualifiedName - The qualified name of the attribute\n\t * @param value         - The value for the attribute\n\t */\n\tpublic setAttributeNS(namespace: string | null, qualifiedName: string, value: string): void {\n\t\texpectArity(arguments, 3);\n\t\tnamespace = asNullableString(namespace);\n\t\tqualifiedName = String(qualifiedName);\n\t\tvalue = String(value);\n\n\t\t// 1. Let namespace, prefix, and localName be the result of passing namespace and\n\t\t// qualifiedName to validate and extract.\n\t\tconst {\n\t\t\tnamespace: validatedNamespace,\n\t\t\tprefix,\n\t\t\tlocalName,\n\t\t} = validateAndExtract(namespace, qualifiedName);\n\n\t\t// 2. Set an attribute value for this using localName, value, and also prefix\n\t\t// and namespace.\n\t\tsetAttributeValue(this, localName, value, prefix, validatedNamespace);\n\t}\n\n\t/**\n\t * Removes the specified attribute.\n\t *\n\t * @param qualifiedName - The qualified name of the attribute\n\t */\n\tpublic removeAttribute(qualifiedName: string): void {\n\t\texpectArity(arguments, 1);\n\t\tqualifiedName = String(qualifiedName);\n\n\t\tremoveAttributeByName(qualifiedName, this);\n\t}\n\n\t/**\n\t * Removes the specified attribute.\n\t *\n\t * @param namespace - The namespace of the attribute\n\t * @param localName - The local name of the attribute\n\t */\n\tpublic removeAttributeNS(namespace: string | null, localName: string): void {\n\t\texpectArity(arguments, 2);\n\t\tnamespace = asNullableString(namespace);\n\t\tlocalName = String(localName);\n\n\t\tremoveAttributeByNamespaceAndLocalName(namespace, localName, this);\n\t}\n\n\t/**\n\t * If force is not given, \"toggles\" qualifiedName, removing it if it is present and adding it if\n\t * it is not present. If force is true, adds qualifiedName. If force is false, removes\n\t * qualifiedName.\n\t *\n\t * Returns true if qualifiedName is now present, and false otherwise.\n\t *\n\t * @param qualifiedName - The qualified name of the attribute to toggle\n\t * @param force         - If true, adds the attribute, if false removes it\n\t */\n\tpublic toggleAttribute(qualifiedName: string, force?: boolean): boolean {\n\t\t// 1. If qualifiedName does not match the Name production in XML, then throw an\n\t\t// \"InvalidCharacterError\" DOMException.\n\t\tif (!matchesNameProduction(qualifiedName)) {\n\t\t\tthrowInvalidCharacterError('The qualified name does not match the Name production');\n\t\t}\n\n\t\t// 2. If this is in the HTML namespace and its node document is an HTML\n\t\t// document, then set qualifiedName to qualifiedName in ASCII lowercase.\n\t\t// (html documents not implemented)\n\n\t\t// 3. Let attribute be the first attribute in this’s attribute list whose\n\t\t// qualified name is qualifiedName, and null otherwise.\n\t\tconst attribute = getAttributeByName(qualifiedName, this);\n\n\t\t// 4. If attribute is null, then:\n\t\tif (attribute === null) {\n\t\t\t// 4.1. If force is not given or is true,\n\t\t\tif (force === undefined || force === true) {\n\t\t\t\t// ...create an attribute whose local name is qualifiedName, value is the empty\n\t\t\t\t// string, and node document is this’s node document,\n\t\t\t\tconst context = getContext(this);\n\t\t\t\tconst attribute = new context.Attr(null, null, qualifiedName, '', this);\n\t\t\t\tattribute.ownerDocument = this.ownerDocument;\n\t\t\t\t// ...then append this attribute to this,\n\t\t\t\tappendAttribute(attribute, this);\n\t\t\t\t// ...and then return true.\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// 4.2. Return false.\n\t\t\treturn false;\n\t\t}\n\n\t\t// 5. Otherwise, if force is not given or is false,\n\t\tif (force === undefined || force === false) {\n\t\t\t// ...remove an attribute given qualifiedName and this,\n\t\t\tremoveAttributeByName(qualifiedName, this);\n\t\t\t// ...and then return false.\n\t\t\treturn false;\n\t\t}\n\n\t\t// 6. Return true.\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns true if the specified attribute exists and false otherwise.\n\t *\n\t * @param qualifiedName - The qualified name of the attribute\n\t */\n\tpublic hasAttribute(qualifiedName: string): boolean {\n\t\texpectArity(arguments, 1);\n\t\tqualifiedName = String(qualifiedName);\n\n\t\t// 1. If this is in the HTML namespace and its node document is an HTML\n\t\t// document, then set qualifiedName to qualifiedName in ASCII lowercase.\n\t\t// (html documents not implemented)\n\n\t\t// 2. Return true if this has an attribute whose qualified name is\n\t\t// qualifiedName, and false otherwise.\n\t\treturn getAttributeByName(qualifiedName, this) !== null;\n\t}\n\n\t/**\n\t * Returns true if the specified attribute exists and false otherwise.\n\t *\n\t * @param namespace - The namespace of the attribute\n\t * @param localName - The local name of the attribute\n\t */\n\tpublic hasAttributeNS(namespace: string | null, localName: string): boolean {\n\t\texpectArity(arguments, 2);\n\t\tnamespace = asNullableString(namespace);\n\t\tlocalName = String(localName);\n\n\t\t// 1. If namespace is the empty string, set it to null.\n\t\t// (handled by getAttributeByNamespaceAndLocalName, called below)\n\t\t// 2. Return true if this has an attribute whose namespace is namespace and\n\t\t// local name is localName, and false otherwise.\n\t\treturn getAttributeByNamespaceAndLocalName(namespace, localName, this) !== null;\n\t}\n\n\t/**\n\t * Returns the specified attribute node, or null if no such attribute exists.\n\t *\n\t * @param qualifiedName - The qualified name of the attribute\n\t *\n\t * @returns The attribute, or null if no such attribute exists\n\t */\n\tpublic getAttributeNode(qualifiedName: string): Attr | null {\n\t\texpectArity(arguments, 1);\n\t\tqualifiedName = String(qualifiedName);\n\n\t\treturn getAttributeByName(qualifiedName, this);\n\t}\n\n\t/**\n\t * Returns the specified attribute node, or null if no such attribute exists.\n\t *\n\t * @param namespace - The namespace of the attribute\n\t * @param localName - The local name of the attribute\n\t *\n\t * @returns The attribute, or null if no such attribute exists\n\t */\n\tpublic getAttributeNodeNS(namespace: string | null, localName: string): Attr | null {\n\t\texpectArity(arguments, 2);\n\t\tnamespace = asNullableString(namespace);\n\t\tlocalName = String(localName);\n\n\t\treturn getAttributeByNamespaceAndLocalName(namespace, localName, this);\n\t}\n\n\t/**\n\t * Sets an attribute given its node\n\t *\n\t * @param attr - The attribute node to set\n\t *\n\t * @returns The previous attribute node for the attribute\n\t */\n\tpublic setAttributeNode(attr: Attr): Attr | null {\n\t\texpectArity(arguments, 1);\n\t\tattr = asObject(attr, Attr);\n\n\t\treturn setAttribute(attr, this);\n\t}\n\n\t/**\n\t * Sets an attribute given its node\n\t *\n\t * @param attr - The attribute node to set\n\t *\n\t * @returns The previous attribute node for the attribute\n\t */\n\tpublic setAttributeNodeNS(attr: Attr): Attr | null {\n\t\texpectArity(arguments, 1);\n\t\tattr = asObject(attr, Attr);\n\n\t\treturn setAttribute(attr, this);\n\t}\n\n\t/**\n\t * Removes an attribute given its node\n\t *\n\t * @param attr - The attribute node to remove\n\t *\n\t * @returns The removed attribute node\n\t */\n\tpublic removeAttributeNode(attr: Attr): Attr {\n\t\texpectArity(arguments, 1);\n\t\tattr = asObject(attr, Attr);\n\n\t\t// 1. If this’s attribute list does not contain attr, then throw a NotFoundError.\n\t\tif (this.attributes.indexOf(attr) < 0) {\n\t\t\tthrowNotFoundError('the specified attribute does not exist');\n\t\t}\n\n\t\t// 2. Remove attr.\n\t\tremoveAttribute(attr);\n\n\t\t// 3. Return attr.\n\t\treturn attr;\n\t}\n\n\t/**\n\t * Returns the list of elements with the given qualified name.\n\t *\n\t * @param qualifiedName - Qualified name of the elements to collect.\n\t *\n\t * @returns  The list of elements with matching qualified name.\n\t */\n\tpublic getElementsByTagName(qualifiedName: string): Element[] {\n\t\texpectArity(arguments, 1);\n\t\tqualifiedName = String(qualifiedName);\n\n\t\treturn getListOfElementsWithQualifiedName(qualifiedName, this);\n\t}\n\n\t/**\n\t * Returns the list of elements with the given namespace and local name.\n\t *\n\t * @param namespace - Namespace URI of the elements to collect.\n\t * @param localName - Local name of the elements to collect\n\t *\n\t * @returns  The list of elements with matching namespace and local name.\n\t */\n\tpublic getElementsByTagNameNS(namespace: string | null, localName: string): Element[] {\n\t\texpectArity(arguments, 2);\n\t\tnamespace = asNullableString(namespace);\n\t\tlocalName = String(localName);\n\n\t\treturn getListOfElementsWithNamespaceAndLocalName(namespace, localName, this);\n\t}\n\n\t/**\n\t * (non-standard) Creates a copy of the given node\n\t *\n\t * @param document - The node document to associate with the copy\n\t * @param other    - The node to copy\n\t *\n\t * @returns A shallow copy of the node\n\t */\n\tpublic _copy(document: Document): Element {\n\t\t// 2.1. Let copy be the result of creating an element, given document, node’s local name,\n\t\t// node’s namespace, node’s namespace prefix, and the value of node’s is attribute if\n\t\t// present (or null if not). The synchronous custom elements flag should be unset.\n\t\tconst copyElement = createElement(document, this.localName, this.namespaceURI, this.prefix);\n\n\t\t// 2.2. For each attribute in node’s attribute list:\n\t\tfor (const attr of this.attributes) {\n\t\t\t// 2.2.1. Let copyAttribute be a clone of attribute.\n\t\t\tconst copyAttribute = attr._copy(document);\n\n\t\t\t// 2.2.2. Append copyAttribute to copy.\n\t\t\tcopyElement.setAttributeNode(copyAttribute);\n\t\t}\n\n\t\treturn copyElement;\n\t}\n\n\t// From the DOM Parsing and Serialization spec\n\n\t/**\n\t * Returns a fragment of HTML or XML that represents the element's contents.\n\t */\n\tpublic get innerHTML() {\n\t\t// Return the result of invoking the fragment serializing algorithm on this\n\t\t// providing true for the require well-formed flag (this might throw an exception instead of\n\t\t// returning a string).\n\t\treturn serializeFragment(this, true);\n\t}\n\n\t/**\n\t * Returns a fragment of HTML or XML that represents the element and its contents.\n\t */\n\tpublic get outerHTML() {\n\t\t// Return the result of invoking the fragment serializing algorithm on a fictional node\n\t\t// whose only child is this providing true for the require well-formed flag\n\t\t// (this might throw an exception instead of returning a string).\n\t\treturn serializeFragment(this, true, true);\n\t}\n}\n\n/**\n * To create an element, given a document, localName, namespace, and optional prefix, is, and\n * synchronous custom elements flag, run these steps:\n *\n * @param document  - The node document for the new element\n * @param localName - The local name for the new element\n * @param namespace - The namespace URI for the new element, or null for the null namespace\n * @param prefix    - The prefix for the new element, or null for no prefix\n *\n * @returns The new element\n */\nexport function createElement(\n\tdocument: Document,\n\tlocalName: string,\n\tnamespace: string | null,\n\tprefix: string | null = null\n): Element {\n\t// 1. If prefix was not given, let prefix be null.\n\t// (handled by default)\n\n\t// 2. If is was not given, let is be null.\n\t// (custom elements not implemented)\n\n\t// 3. Let result be null.\n\tlet result = null;\n\n\t// 4. Let definition be the result of looking up a custom element definition given document,\n\t// namespace, localName, and is.\n\t// (custom elements not implemented)\n\n\t// 5. If definition is non-null, and definition’s name is not equal to its local name (i.e.,\n\t// definition represents a customized built-in element), then:\n\t// 5.1. Let interface be the element interface for localName and the HTML namespace.\n\t// 5.2. Set result to a new element that implements interface, with no attributes, namespace set\n\t// to the HTML namespace, namespace prefix set to prefix, local name set to localName, custom\n\t// element state set to \"undefined\", custom element definition set to null, is value set to is,\n\t// and node document set to document.\n\t// 5.3. If the synchronous custom elements flag is set, then run this step while catching any\n\t// exceptions:\n\t// 5.3.1. Upgrade element using definition.\n\t// 5.3.catch. If this step threw an exception, then:\n\t// 5.3.catch.1. Report the exception.\n\t// 5.3.catch.2. Set result's custom element state to \"failed\".\n\t// 5.4. Otherwise, enqueue a custom element upgrade reaction given result and definition.\n\t// (custom elements not implemented)\n\n\t// 6. Otherwise, if definition is non-null, then:\n\t// 6.1. If the synchronous custom elements flag is set, then run these steps while catching any\n\t// exceptions:\n\t// 6.1.1. Let C be definition’s constructor.\n\t// 6.1.2. Set result to the result of constructing C, with no arguments.\n\t// 6.1.3. Assert: result’s custom element state and custom element definition are initialized.\n\t// 6.1.4. Assert: result’s namespace is the HTML namespace.\n\t// IDL enforces that result is an HTMLElement object, which all use the HTML namespace.\n\t// 6.1.5. If result’s attribute list is not empty, then throw a NotSupportedError.\n\t// 6.1.6. If result has children, then throw a NotSupportedError.\n\t// 6.1.7. If result’s parent is non-null, then throw a NotSupportedError.\n\t// 6.1.8. If result’s node document is not document, then throw a NotSupportedError.\n\t// 6.1.9. If result’s local name is not equal to localName, then throw a NotSupportedError.\n\t// 6.1.10. Set result’s namespace prefix to prefix.\n\t// 6.1.11. Set result’s is value to null.\n\t// If any of these steps threw an exception, then:\n\t// 6.1.catch.1. Report the exception.\n\t// 6.1.catch.2. Set result to a new element that implements the HTMLUnknownElement interface,\n\t// with no attributes, namespace set to the HTML namespace, namespace prefix set to prefix,\n\t// local name set to localName, custom element state set to \"failed\", custom element definition\n\t// set to null, is value set to null, and node document set to document.\n\t// 6.2. Otherwise:\n\t// 6.2.1. Set result to a new element that implements the HTMLElement interface, with no\n\t// attributes, namespace set to the HTML namespace, namespace prefix set to prefix, local name\n\t// set to localName, custom element state set to \"undefined\", custom element definition set to\n\t// null, is value set to null, and node document set to document.\n\t// 6.2.2. Enqueue a custom element upgrade reaction given result and definition.\n\t// (custom elements not implemented)\n\n\t// 7. Otherwise:\n\t// 7.1. Let interface be the element interface for localName and namespace.\n\t// (interfaces other than Element not implemented)\n\n\t// 7.2. Set result to a new element that implements interface, with no attributes, namespace set\n\t// to namespace, namespace prefix set to prefix, local name set to localName, custom element\n\t// state set to \"uncustomized\", custom element definition set to null, is value set to is, and\n\t// node document set to document.\n\tconst context = getContext(document);\n\tresult = new context.Element(namespace, prefix, localName);\n\tresult.ownerDocument = document;\n\n\t// If namespace is the HTML namespace, and either localName is a valid custom element name or is\n\t// is non-null, then set result’s custom element state to \"undefined\".\n\t// (custom elements not implemented)\n\n\t// Return result.\n\treturn result;\n}\n\n/**\n * To get an attribute by name given a qualifiedName and element element, run these steps:\n *\n * @param qualifiedName - The qualified name of the attribute to get\n * @param element       - The element to get the attribute on\n *\n * @returns The first matching attribute, or null otherwise\n */\nfunction getAttributeByName(qualifiedName: string, element: Element): Attr | null {\n\t// 1. If element is in the HTML namespace and its node document is an HTML document, then set\n\t// qualifiedName to qualifiedName in ASCII lowercase.\n\t// (html documents not implemented)\n\n\t// 2. Return the first attribute in element’s attribute list whose qualified name is\n\t// qualifiedName, and null otherwise.\n\treturn element.attributes.find((attr) => attr.name === qualifiedName) || null;\n}\n\n/**\n * To get an attribute by namespace and local name given a namespace, localName, and element\n * element, run these steps:\n *\n * @param namespace - Namespace for the attribute\n * @param localName - Local name for the attribute\n * @param element   - The element to get the attribute on\n *\n * @returns The first matching attribute, or null otherwise\n */\nfunction getAttributeByNamespaceAndLocalName(\n\tnamespace: string | null,\n\tlocalName: string,\n\telement: Element\n): Attr | null {\n\t// 1. If namespace is the empty string, set it to null.\n\tif (namespace === '') {\n\t\tnamespace = null;\n\t}\n\n\t// 2. Return the attribute in element’s attribute list whose namespace is namespace and local\n\t// name is localName, if any, and null otherwise.\n\treturn (\n\t\telement.attributes.find(\n\t\t\t(attr) => attr.namespaceURI === namespace && attr.localName === localName\n\t\t) || null\n\t);\n}\n\n/**\n * To set an attribute given an attr and element, run these steps:\n *\n * @param attr    - The new attribute to set\n * @param element - The element to set attr on\n *\n * @returns The previous attribute with attr's namespace and local name, or null if there was no such\n *         attribute\n */\nfunction setAttribute(attr: Attr, element: Element): Attr | null {\n\t// 1. If attr’s element is neither null nor element, throw an InUseAttributeError.\n\tif (attr.ownerElement !== null && attr.ownerElement !== element) {\n\t\tthrowInUseAttributeError('attribute is in use by another element');\n\t}\n\n\t// 2. Let oldAttr be the result of getting an attribute given attr’s namespace, attr’s local\n\t// name, and element.\n\tconst oldAttr = getAttributeByNamespaceAndLocalName(attr.namespaceURI, attr.localName, element);\n\n\t// 3. If oldAttr is attr, return attr.\n\tif (oldAttr === attr) {\n\t\treturn attr;\n\t}\n\n\t// 4. If oldAttr is non-null, then replace oldAttr with attr.\n\tif (oldAttr !== null) {\n\t\treplaceAttribute(oldAttr, attr);\n\t} else {\n\t\t// 5. Otherwise, append attr to element.\n\t\tappendAttribute(attr, element);\n\t}\n\n\t// 6. Return oldAttr.\n\treturn oldAttr;\n}\n\n/**\n * To set an attribute value for an element element using a localName and value, and an optional\n * prefix, and namespace, run these steps:\n *\n * @param element   - Element to set the attribute value on\n * @param localName - Local name of the attribute\n * @param value     - New value of the attribute\n * @param prefix    - Prefix of the attribute\n * @param namespace - Namespace of the attribute\n */\nfunction setAttributeValue(\n\telement: Element,\n\tlocalName: string,\n\tvalue: string,\n\tprefix: string | null,\n\tnamespace: string | null\n): void {\n\t// 1. If prefix is not given, set it to null.\n\t// 2. If namespace is not given, set it to null.\n\t// (handled by default values)\n\n\t// 3. Let attribute be the result of getting an attribute given namespace, localName, and\n\t// element.\n\tconst attribute = getAttributeByNamespaceAndLocalName(namespace, localName, element);\n\n\t// 4. If attribute is null, create an attribute whose namespace is namespace, namespace prefix\n\t// is prefix, local name is localName, value is value, and node document is element’s node\n\t// document, then append this attribute to element, and then return.\n\tif (attribute === null) {\n\t\tconst context = getContext(element);\n\t\tconst attribute = new context.Attr(namespace, prefix, localName, value, element);\n\t\tattribute.ownerDocument = element.ownerDocument;\n\t\tappendAttribute(attribute, element);\n\t\treturn;\n\t}\n\n\t// 5. Change attribute to value.\n\tchangeAttribute(attribute, value);\n}\n\n/**\n * To remove an attribute by name given a qualifiedName and element element, run these steps:\n *\n * @param qualifiedName - Qualified name of the attribute\n * @param element       - The element to remove the attribute from\n *\n * @returns The removed attribute, or null if no matching attribute exists\n */\nfunction removeAttributeByName(qualifiedName: string, element: Element): Attr | null {\n\t// 1. Let attr be the result of getting an attribute given qualifiedName and element.\n\tconst attr = getAttributeByName(qualifiedName, element);\n\n\t// 2. If attr is non-null, then remove attr.\n\tif (attr !== null) {\n\t\tremoveAttribute(attr);\n\t}\n\n\t// 3. Return attr.\n\treturn attr;\n}\n\n/**\n * To remove an attribute by namespace and local name given a namespace, localName, and element\n * element, run these steps:\n *\n * @param namespace - The namespace of the attribute\n * @param localName - The local name of the attribute\n * @param element   - The element to remove the attribute from\n *\n * @returns The removed attribute, or null if no matching attribute exists\n */\nfunction removeAttributeByNamespaceAndLocalName(\n\tnamespace: string | null,\n\tlocalName: string,\n\telement: Element\n): Attr | null {\n\t// 1. Let attr be the result of getting an attribute given namespace, localName, and element.\n\tconst attr = getAttributeByNamespaceAndLocalName(namespace, localName, element);\n\n\t// 2. If attr is non-null, then remove attr.\n\tif (attr !== null) {\n\t\tremoveAttribute(attr);\n\t}\n\n\t// 3. Return attr.\n\treturn attr;\n}\n","import Document from '../Document';\nimport { createElement, default as Element } from '../Element';\nimport { validateAndExtract } from './namespaceHelpers';\n\n// 3.5. Interface Document\n\n/**\n * The internal createElementNS steps, given document, namespace, qualifiedName, and options, are as\n * follows:\n *\n * @param document      - The node document for the new element\n * @param namespace     - The namespace for the new element\n * @param qualifiedName - The qualified name for the new element\n *\n * @returns The new element\n */\nexport default function createElementNS(\n\tdocument: Document,\n\tnamespace: string | null,\n\tqualifiedName: string\n): Element {\n\t// 1. Let namespace, prefix, and localName be the result of passing namespace and qualifiedName\n\t// to validate and extract.\n\tconst {\n\t\tnamespace: validatedNamespace,\n\t\tprefix,\n\t\tlocalName,\n\t} = validateAndExtract(namespace, qualifiedName);\n\n\t// 2. Let is be the value of is member of options, or null if no such member exists.\n\t// (custom elements not implemented)\n\n\t// 3. Let element be the result of creating an element given document, localName, namespace,\n\t// prefix, is, and with the synchronous custom elements flag set.\n\tconst element = createElement(document, localName, validatedNamespace, prefix);\n\n\t// 4. If is is non-null, then set an attribute value for element using \"is\" and is.\n\t// (custom elements not implemented)\n\n\t// 5. Return element.\n\treturn element;\n}\n","import Document from './Document';\nimport DocumentType from './DocumentType';\nimport { createElement } from './Element';\nimport XMLDocument from './XMLDocument';\nimport { getContext } from './context/Context';\nimport createElementNS from './util/createElementNS';\nimport { expectArity } from './util/errorHelpers';\nimport { HTML_NAMESPACE, validateQualifiedName } from './util/namespaceHelpers';\nimport { asNullableObject, asNullableString, legacyNullToEmptyString } from './util/typeHelpers';\n\n/**\n * @public\n */\nexport default class DOMImplementation {\n\tprivate _document: Document;\n\n\t/**\n\t * (non-standard) Use Document#implementation to access instances of this class\n\t *\n\t * @param document - The document to associate with this instance\n\t */\n\tconstructor(document: Document) {\n\t\tthis._document = document;\n\t}\n\n\t/**\n\t * Returns a doctype, with the given qualifiedName, publicId, and systemId.\n\t *\n\t * @param qualifiedName - Qualified name for the doctype\n\t * @param publicId      - Public ID for the doctype\n\t * @param systemId      - System ID for the doctype\n\t *\n\t * @returns The new doctype node\n\t */\n\tcreateDocumentType(qualifiedName: string, publicId: string, systemId: string): DocumentType {\n\t\texpectArity(arguments, 3);\n\t\tqualifiedName = String(qualifiedName);\n\t\tpublicId = String(publicId);\n\t\tsystemId = String(systemId);\n\n\t\t// 1. Validate qualifiedName.\n\t\tvalidateQualifiedName(qualifiedName);\n\n\t\t// 2. Return a new doctype, with qualifiedName as its name, publicId as its public ID, and\n\t\t// systemId as its system ID, and with its node document set to the associated document of\n\t\t// this.\n\t\tconst context = getContext(this._document);\n\t\tconst doctype = new context.DocumentType(qualifiedName, publicId, systemId);\n\t\tdoctype.ownerDocument = this._document;\n\t\treturn doctype;\n\t}\n\n\t/**\n\t * Returns an XMLDocument, with a document element whose local name is qualifiedName and whose\n\t * namespace is namespace (unless qualifiedName is the empty string), and with doctype, if it is\n\t * given, as its doctype.\n\t *\n\t * @param namespace     - The namespace for the root element\n\t * @param qualifiedName - The qualified name for the root element, or empty string to not create\n\t *                        a root element\n\t * @param doctype       - The doctype for the new document, or null to not add a doctype\n\t *\n\t * @returns The new XMLDocument\n\t */\n\tcreateDocument(\n\t\tnamespace: string | null,\n\t\tqualifiedName: string | null,\n\t\tdoctype: DocumentType | null = null\n\t): XMLDocument {\n\t\texpectArity(arguments, 2);\n\t\tnamespace = asNullableString(namespace);\n\t\t// [LegacyNullToEmptyString] for qualifiedName\n\t\tqualifiedName = legacyNullToEmptyString(qualifiedName);\n\t\tdoctype = asNullableObject(doctype, DocumentType);\n\n\t\t// 1. Let document be a new XMLDocument.\n\t\tconst context = getContext(this._document);\n\t\tconst document = new context.XMLDocument();\n\n\t\t// 2. Let element be null.\n\t\tlet element = null;\n\n\t\t// 3. If qualifiedName is not the empty string, then set element to the result of running\n\t\t// the internal createElementNS steps, given document, namespace, qualifiedName, and an\n\t\t// empty dictionary.\n\t\tif (qualifiedName !== '') {\n\t\t\telement = createElementNS(document, namespace, qualifiedName);\n\t\t}\n\n\t\t// 4. If doctype is non-null, append doctype to document.\n\t\tif (doctype) {\n\t\t\tdocument.appendChild(doctype);\n\t\t}\n\n\t\t// 5. If element is non-null, append element to document.\n\t\tif (element) {\n\t\t\tdocument.appendChild(element);\n\t\t}\n\n\t\t// 6. document’s origin is this’s associated document’s origin.\n\t\t// (origin not implemented)\n\n\t\t// 7. document’s content type is determined by namespace:\n\t\t// HTML namespace: application/xhtml+xml\n\t\t// SVG namespace: image/svg+xml\n\t\t// Any other namespace: application/xml\n\t\t// (content type not implemented)\n\n\t\t// 8. Return document.\n\t\treturn document;\n\t}\n\n\t/**\n\t * Returns a HTML document with a basic tree already constructed.\n\t *\n\t * @param title - Optional title for the new HTML document\n\t *\n\t * @returns The new document\n\t */\n\tcreateHTMLDocument(title?: string | null): Document {\n\t\ttitle = asNullableString(title);\n\n\t\t// 1. Let doc be a new document that is an HTML document.\n\t\tconst context = getContext(this._document);\n\t\tconst doc = new context.Document();\n\n\t\t// 2. Set doc’s content type to \"text/html\".\n\t\t// (content type not implemented)\n\n\t\t// 3. Append a new doctype, with \"html\" as its name and with its node document set to doc,\n\t\t// to doc.\n\t\tconst doctype = new context.DocumentType('html');\n\t\tdoctype.ownerDocument = doc;\n\t\tdoc.appendChild(doctype);\n\n\t\t// 4. Append the result of creating an element given doc, html, and the HTML namespace, to\n\t\t// doc.\n\t\tconst htmlElement = createElement(doc, 'html', HTML_NAMESPACE);\n\t\tdoc.appendChild(htmlElement);\n\n\t\t// 5. Append the result of creating an element given doc, head, and the HTML namespace, to\n\t\t// the html element created earlier.\n\t\tconst headElement = createElement(doc, 'head', HTML_NAMESPACE);\n\t\thtmlElement.appendChild(headElement);\n\n\t\t// 6. If title is given:\n\t\tif (title !== null) {\n\t\t\t// 6.1. Append the result of creating an element given doc, title, and the HTML\n\t\t\t// namespace, to the head element created earlier.\n\t\t\tconst titleElement = createElement(doc, 'title', HTML_NAMESPACE);\n\t\t\theadElement.appendChild(titleElement);\n\n\t\t\t// 6.2. Append a new Text node, with its data set to title (which could be the empty\n\t\t\t// string) and its node document set to doc, to the title element created earlier.\n\t\t\ttitleElement.appendChild(doc.createTextNode(title));\n\t\t}\n\n\t\t// 7. Append the result of creating an element given doc, body, and the HTML namespace, to\n\t\t// the html element created earlier.\n\t\thtmlElement.appendChild(createElement(doc, 'body', HTML_NAMESPACE));\n\n\t\t// 8. doc’s origin is this’s associated document’s origin.\n\t\t// (origin not implemented)\n\n\t\t// 9. Return doc.\n\t\treturn doc;\n\t}\n}\n","import { NonElementParentNode, ParentNode, getChildren } from './mixins';\nimport Attr from './Attr';\nimport CDATASection from './CDATASection';\nimport Comment from './Comment';\nimport DocumentFragment from './DocumentFragment';\nimport DocumentType from './DocumentType';\nimport DOMImplementation from './DOMImplementation';\nimport { createElement, default as Element } from './Element';\nimport Node from './Node';\nimport ProcessingInstruction from './ProcessingInstruction';\nimport Text from './Text';\nimport Range from './Range';\nimport { getContext } from './context/Context';\nimport { matchesNameProduction } from './dom-parsing/parsingAlgorithms';\nimport cloneNode from './util/cloneNode';\nimport createElementNS from './util/createElementNS';\nimport {\n\texpectArity,\n\tthrowInvalidCharacterError,\n\tthrowNotSupportedError,\n} from './util/errorHelpers';\nimport { adoptNode, appendNodes, prependNodes, replaceChildren } from './util/mutationAlgorithms';\nimport { NodeType, isNodeOfType } from './util/NodeType';\nimport { validateAndExtract } from './util/namespaceHelpers';\nimport { asNullableString, asObject } from './util/typeHelpers';\nimport {\n\tgetListOfElementsWithNamespaceAndLocalName,\n\tgetListOfElementsWithQualifiedName,\n} from './util/treeHelpers';\n\n/**\n * 3.5. Interface Document\n *\n * @public\n */\nexport default class Document extends Node implements NonElementParentNode, ParentNode {\n\t// Node\n\n\tpublic get nodeType(): number {\n\t\treturn NodeType.DOCUMENT_NODE;\n\t}\n\n\tpublic get nodeName(): string {\n\t\treturn '#document';\n\t}\n\n\tpublic get nodeValue(): string | null {\n\t\treturn null;\n\t}\n\n\tpublic set nodeValue(_newValue: string | null) {\n\t\t// Do nothing.\n\t}\n\n\tpublic get textContent(): string | null {\n\t\treturn null;\n\t}\n\n\tpublic set textContent(_newValue: string | null) {\n\t\t// Do nothing.\n\t}\n\n\tpublic lookupPrefix(namespace: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\n\t\t// 1. If namespace is null or the empty string, then return null.\n\t\t// (not necessary due to recursion)\n\n\t\t// 2. Switch on this:\n\t\t// Document - Return the result of locating a namespace prefix for its document element, if\n\t\t// its document element is non-null, and null otherwise.\n\t\tif (this.documentElement !== null) {\n\t\t\treturn this.documentElement.lookupPrefix(namespace);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic lookupNamespaceURI(prefix: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\n\t\t// 1. If prefix is the empty string, then set it to null.\n\t\t// (not necessary due to recursion)\n\n\t\t// 2. Return the result of running locate a namespace for this using prefix.\n\n\t\t// To locate a namespace for a node using prefix, switch on node: Document\n\t\t// 1. If its document element is null, then return null.\n\t\tif (this.documentElement === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// 2. Return the result of running locate a namespace on its document element using prefix.\n\t\treturn this.documentElement.lookupNamespaceURI(prefix);\n\t}\n\n\t// ParentNode\n\n\tpublic get children(): Element[] {\n\t\treturn getChildren(this);\n\t}\n\n\tpublic firstElementChild: Element | null = null;\n\tpublic lastElementChild: Element | null = null;\n\tpublic childElementCount: number = 0;\n\n\tpublic prepend(...nodes: (Node | string)[]): void {\n\t\tprependNodes(this, nodes);\n\t}\n\n\tpublic append(...nodes: (Node | string)[]): void {\n\t\tappendNodes(this, nodes);\n\t}\n\n\tpublic replaceChildren(...nodes: (Node | string)[]): void {\n\t\treplaceChildren(this, nodes);\n\t}\n\n\t// Document\n\n\t/**\n\t * Returns a reference to the DOMImplementation object associated with the document.\n\t */\n\tpublic readonly implementation: DOMImplementation = new DOMImplementation(this);\n\n\t/**\n\t * The doctype, or null if there is none.\n\t */\n\tpublic doctype: DocumentType | null = null;\n\n\t/**\n\t * The document element, or null if there is none.\n\t */\n\tpublic documentElement: Element | null = null;\n\n\t/**\n\t * Creates a new Document.\n\t *\n\t * Note: Unlike DOMImplementation#createDocument(), this constructor does not return an\n\t * XMLDocument object, but a document (Document object).\n\t */\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * Returns the list of elements with the given qualified name.\n\t *\n\t * @param qualifiedName - Qualified name of the elements to collect.\n\t *\n\t * @returns  The list of elements with matching qualified name.\n\t */\n\tpublic getElementsByTagName(qualifiedName: string): Element[] {\n\t\texpectArity(arguments, 1);\n\t\tqualifiedName = String(qualifiedName);\n\n\t\treturn getListOfElementsWithQualifiedName(qualifiedName, this);\n\t}\n\n\t/**\n\t * Returns the list of elements with the given namespace and local name.\n\t *\n\t * @param namespace - Namespace URI of the elements to collect.\n\t * @param localName - Local name of the elements to collect\n\t *\n\t * @returns  The list of elements with matching namespace and local name.\n\t */\n\tpublic getElementsByTagNameNS(namespace: string | null, localName: string): Element[] {\n\t\texpectArity(arguments, 2);\n\t\tnamespace = asNullableString(namespace);\n\t\tlocalName = String(localName);\n\n\t\treturn getListOfElementsWithNamespaceAndLocalName(namespace, localName, this);\n\t}\n\n\t/**\n\t * Creates a new element in the null namespace.\n\t *\n\t * @param localName - Local name of the element\n\t *\n\t * @returns The new element\n\t */\n\tpublic createElement(localName: string): Element {\n\t\texpectArity(arguments, 1);\n\t\tlocalName = String(localName);\n\n\t\t// 1. If localName does not match the Name production, then throw an InvalidCharacterError.\n\t\tif (!matchesNameProduction(localName)) {\n\t\t\tthrowInvalidCharacterError('The local name is not a valid Name');\n\t\t}\n\n\t\t// 2. If this is an HTML document, then set localName to localName in ASCII\n\t\t// lowercase.\n\t\t// (html documents not implemented)\n\n\t\t// 3. Let is be the value of is member of options, or null if no such member exists.\n\t\t// (custom elements not implemented)\n\n\t\t// 4. Let namespace be the HTML namespace, if this is an HTML document or\n\t\t// this’s content type is \"application/xhtml+xml\", and null otherwise.\n\t\t// (html documents not implemented)\n\t\tconst namespace: string | null = null;\n\n\t\t// 5. Let element be the result of creating an element given this, localName,\n\t\t// namespace, null, is, and with the synchronous custom elements flag set.\n\t\tconst element = createElement(this, localName, namespace, null);\n\n\t\t// 6. If is is non-null, then set an attribute value for element using \"is\" and is.\n\t\t// (custom elements not implemented)\n\n\t\t// 7. Return element.\n\t\treturn element;\n\t}\n\n\t/**\n\t * Creates a new element in the given namespace.\n\t *\n\t * @param namespace     - Namespace URI for the new element\n\t * @param qualifiedName - Qualified name for the new element\n\t *\n\t * @returns The new element\n\t */\n\tpublic createElementNS(namespace: string | null, qualifiedName: string): Element {\n\t\texpectArity(arguments, 2);\n\t\tnamespace = asNullableString(namespace);\n\t\tqualifiedName = String(qualifiedName);\n\n\t\t// return the result of running the internal createElementNS steps, given this,\n\t\t// namespace, qualifiedName, and options.\n\t\treturn createElementNS(this, namespace, qualifiedName);\n\t}\n\n\t/**\n\t * Returns a new DocumentFragment node with its node document set to this.\n\t *\n\t * @returns The new document fragment\n\t */\n\tpublic createDocumentFragment(): DocumentFragment {\n\t\tconst context = getContext(this);\n\t\tconst documentFragment = new context.DocumentFragment();\n\t\tdocumentFragment.ownerDocument = this;\n\t\treturn documentFragment;\n\t}\n\n\t/**\n\t * Returns a new Text node with its data set to data and node document set to this.\n\t *\n\t * @param data - Data for the new text node\n\t *\n\t * @returns The new text node\n\t */\n\tpublic createTextNode(data: string): Text {\n\t\texpectArity(arguments, 1);\n\t\tdata = String(data);\n\n\t\tconst context = getContext(this);\n\t\tconst text = new context.Text(data);\n\t\ttext.ownerDocument = this;\n\t\treturn text;\n\t}\n\n\t/**\n\t * Returns a new CDATA section with the given data and node document set to this.\n\t *\n\t * @param data - Data for the new CDATA section\n\t *\n\t * @returns The new CDATA section\n\t */\n\tpublic createCDATASection(data: string): CDATASection {\n\t\texpectArity(arguments, 1);\n\t\tdata = String(data);\n\n\t\t// 1. If this is an HTML document, then throw a NotSupportedError.\n\t\t// (html documents not implemented)\n\n\t\t// 2. If data contains the string \"]]>\", then throw an InvalidCharacterError.\n\t\tif (data.indexOf(']]>') >= 0) {\n\t\t\tthrowInvalidCharacterError('Data must not contain the string \"]]>\"');\n\t\t}\n\n\t\t// 3. Return a new CDATASection node with its data set to data and node document set to the\n\t\t// this.\n\t\tconst context = getContext(this);\n\t\tconst cdataSection = new context.CDATASection(data);\n\t\tcdataSection.ownerDocument = this;\n\t\treturn cdataSection;\n\t}\n\n\t/**\n\t * Returns a new Comment node with its data set to data and node document set to this.\n\t *\n\t * @param data - Data for the new comment\n\t *\n\t * @returns The new comment node\n\t */\n\tpublic createComment(data: string): Comment {\n\t\texpectArity(arguments, 1);\n\t\tdata = String(data);\n\n\t\tconst context = getContext(this);\n\t\tconst comment = new context.Comment(data);\n\t\tcomment.ownerDocument = this;\n\t\treturn comment;\n\t}\n\n\t/**\n\t * Creates a new processing instruction node, with target set to target, data set to data, and\n\t * node document set to this.\n\t *\n\t * @param target - Target for the new processing instruction\n\t * @param data   - Data for the new processing instruction\n\t *\n\t * @returns The new processing instruction\n\t */\n\tpublic createProcessingInstruction(target: string, data: string): ProcessingInstruction {\n\t\texpectArity(arguments, 2);\n\t\ttarget = String(target);\n\t\tdata = String(data);\n\n\t\t// 1. If target does not match the Name production, then throw an InvalidCharacterError.\n\t\tif (!matchesNameProduction(target)) {\n\t\t\tthrowInvalidCharacterError('The target is not a valid Name');\n\t\t}\n\n\t\t// 2. If data contains the string \"?>\", then throw an InvalidCharacterError.\n\t\tif (data.indexOf('?>') >= 0) {\n\t\t\tthrowInvalidCharacterError('Data must not contain the string \"?>\"');\n\t\t}\n\n\t\t// 3. Return a new ProcessingInstruction node, with target set to target, data set to data,\n\t\t// and node document set to this.\n\t\tconst context = getContext(this);\n\t\tconst pi = new context.ProcessingInstruction(target, data);\n\t\tpi.ownerDocument = this;\n\t\treturn pi;\n\n\t\t// Note: No check is performed that target contains \"xml\" or \":\", or that data contains\n\t\t// characters that match the Char production.\n\t}\n\n\t/**\n\t * Creates a copy of a node from an external document that can be inserted into the current\n\t * document.\n\t *\n\t * @param node - The node to import\n\t * @param deep - Whether to also import node's children\n\t */\n\tpublic importNode<TNode extends Node>(node: TNode, deep: boolean = false): TNode {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\t// 1. If node is a document or shadow root, then throw a NotSupportedError.\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_NODE)) {\n\t\t\tthrowNotSupportedError('importing a Document node is not supported');\n\t\t}\n\n\t\t// 2. Return a clone of node, with this and the clone children flag set if deep is\n\t\t// true.\n\t\treturn cloneNode(node, deep, this);\n\t}\n\n\t/**\n\t * Adopts a node. The node and its subtree is removed from the document it's in (if any), and\n\t * its ownerDocument is changed to the current document. The node can then be inserted into the\n\t * current document.\n\t *\n\t * @param node - The node to adopt\n\t */\n\tpublic adoptNode<TNode extends Node>(node: TNode): TNode {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\t// 1. If node is a document, then throw a NotSupportedError.\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_NODE)) {\n\t\t\tthrowNotSupportedError('adopting a Document node is not supported');\n\t\t}\n\n\t\t// 2. If node is a shadow root, then throw a HierarchyRequestError.\n\t\t// 3. If node is a DocumentFragment node and its host is non-null, then return node.\n\t\t// Note: unfortunately this does not throw for web compatibility.\n\t\t// (shadow dom and HTML templates not implemented)\n\n\t\t// 4. Adopt node into this.\n\t\tadoptNode(node, this);\n\n\t\t// 5. Return node.\n\t\treturn node;\n\t}\n\n\t/**\n\t * Creates a new attribute node with the null namespace and given local name.\n\t *\n\t * @param localName - The local name of the attribute\n\t *\n\t * @returns The new attribute node\n\t */\n\tpublic createAttribute(localName: string): Attr {\n\t\texpectArity(arguments, 1);\n\t\tlocalName = String(localName);\n\n\t\t// 1. If localName does not match the Name production in XML, then throw an\n\t\t// InvalidCharacterError.\n\t\tif (!matchesNameProduction(localName)) {\n\t\t\tthrowInvalidCharacterError('The local name is not a valid Name');\n\t\t}\n\n\t\t// 2. If this is an HTML document, then set localName to localName in ASCII\n\t\t// lowercase.\n\t\t// (html documents not implemented)\n\n\t\t// 3. Return a new attribute whose local name is localName and node document is context\n\t\t// object.\n\t\tconst context = getContext(this);\n\t\tconst attr = new context.Attr(null, null, localName, '', null);\n\t\tattr.ownerDocument = this;\n\t\treturn attr;\n\t}\n\n\t/**\n\t * Creates a new attribute node with the given namespace and qualified name.\n\t *\n\t * @param namespace     - Namespace URI for the new attribute, or null for the null namespace\n\t * @param qualifiedName - Qualified name for the new attribute\n\t *\n\t * @returns The new attribute node\n\t */\n\tpublic createAttributeNS(namespace: string | null, qualifiedName: string): Attr {\n\t\texpectArity(arguments, 2);\n\t\tnamespace = asNullableString(namespace);\n\t\tqualifiedName = String(qualifiedName);\n\n\t\t// 1. Let namespace, prefix, and localName be the result of passing namespace and\n\t\t// qualifiedName to validate and extract.\n\t\tconst {\n\t\t\tnamespace: validatedNamespace,\n\t\t\tprefix,\n\t\t\tlocalName,\n\t\t} = validateAndExtract(namespace, qualifiedName);\n\n\t\t// 2. Return a new attribute whose namespace is namespace, namespace prefix is prefix, local\n\t\t// name is localName, and node document is this.\n\t\tconst context = getContext(this);\n\t\tconst attr = new context.Attr(validatedNamespace, prefix, localName, '', null);\n\t\tattr.ownerDocument = this;\n\t\treturn attr;\n\t}\n\n\t/**\n\t * Creates a new live Range, initially positioned at the root of this document.\n\t *\n\t * @returns The new Range\n\t */\n\tpublic createRange(): Range {\n\t\tconst context = getContext(this);\n\t\tconst range = new context.Range();\n\t\trange.startContainer = this;\n\t\trange.startOffset = 0;\n\t\trange.endContainer = this;\n\t\trange.endOffset = 0;\n\t\treturn range;\n\t}\n\n\t/**\n\t * (non-standard) Creates a copy of this, not including its children.\n\t *\n\t * @param document - The node document to associate with the copy\n\t *\n\t * @returns A shallow copy of this\n\t */\n\tpublic _copy(document: Document): Document {\n\t\t// Set copy’s encoding, content type, URL, origin, type, and mode, to those of node.\n\t\t// (properties not implemented)\n\n\t\tconst context = getContext(document);\n\t\treturn new context.Document();\n\t}\n}\n","import { NonElementParentNode, ParentNode, getChildren } from './mixins';\nimport Document from './Document';\nimport Element from './Element';\nimport Node from './Node';\nimport { getContext } from './context/Context';\nimport { expectArity } from './util/errorHelpers';\nimport {\n\tappendNodes,\n\tprependNodes,\n\tgetDescendantTextContent,\n\tstringReplaceAll,\n\treplaceChildren,\n} from './util/mutationAlgorithms';\nimport { NodeType } from './util/NodeType';\nimport { ifNullActAsIfEmptyString } from './util/typeHelpers';\n\n/**\n * @public\n */\nexport default class DocumentFragment extends Node implements NonElementParentNode, ParentNode {\n\t// Node\n\n\tpublic get nodeType(): number {\n\t\treturn NodeType.DOCUMENT_FRAGMENT_NODE;\n\t}\n\n\tpublic get nodeName(): string {\n\t\treturn '#document-fragment';\n\t}\n\n\tpublic get nodeValue(): string | null {\n\t\treturn null;\n\t}\n\n\tpublic set nodeValue(newValue: string | null) {\n\t\t// Do nothing.\n\t}\n\n\tpublic get textContent(): string | null {\n\t\t// Return the descendant text content of this\n\t\treturn getDescendantTextContent(this);\n\t}\n\n\tpublic set textContent(newValue: string | null) {\n\t\tnewValue = ifNullActAsIfEmptyString(newValue);\n\t\tstringReplaceAll(this, newValue);\n\t}\n\n\tpublic lookupPrefix(namespace: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\n\t\t// 1. If namespace is null or the empty string, then return null.\n\t\t// (not necessary due to return value)\n\n\t\t// 2. Switch on this:\n\t\t// DocumentFragment - Return null\n\t\treturn null;\n\t}\n\n\tpublic lookupNamespaceURI(prefix: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\n\t\t// 1. If prefix is the empty string, then set it to null.\n\t\t// (not necessary due to return value)\n\n\t\t// 2. Return the result of running locate a namespace for this using prefix.\n\n\t\t// To locate a namespace for a node using prefix, switch on node: DocumentFragment\n\t\t// Return null.\n\t\treturn null;\n\t}\n\n\t// ParentNode\n\n\tpublic get children(): Element[] {\n\t\treturn getChildren(this);\n\t}\n\n\tpublic firstElementChild: Element | null = null;\n\tpublic lastElementChild: Element | null = null;\n\tpublic childElementCount: number = 0;\n\n\tpublic prepend(...nodes: (Node | string)[]): void {\n\t\tprependNodes(this, nodes);\n\t}\n\n\tpublic append(...nodes: (Node | string)[]): void {\n\t\tappendNodes(this, nodes);\n\t}\n\n\tpublic replaceChildren(...nodes: (Node | string)[]): void {\n\t\treplaceChildren(this, nodes);\n\t}\n\n\t/**\n\t * Return a new DocumentFragment node whose node document is current global object’s associated\n\t * Document.\n\t */\n\tconstructor() {\n\t\tsuper();\n\n\t\tconst context = getContext(this);\n\t\tthis.ownerDocument = context.document;\n\t}\n\n\t/**\n\t * (non-standard) Creates a copy of this, not including its children.\n\t *\n\t * @param document - The node document to associate with the copy\n\t *\n\t * @returns A shallow copy of this\n\t */\n\tpublic _copy(document: Document): DocumentFragment {\n\t\tconst context = getContext(document);\n\t\tconst copy = new context.DocumentFragment();\n\t\tcopy.ownerDocument = document;\n\t\treturn copy;\n\t}\n}\n","import CharacterData from './CharacterData';\nimport Document from './Document';\nimport { getContext } from './context/Context';\nimport { NodeType } from './util/NodeType';\n\n/**\n * 3.13. Interface ProcessingInstruction\n *\n * @public\n */\nexport default class ProcessingInstruction extends CharacterData {\n\t// Node\n\n\tpublic get nodeType(): number {\n\t\treturn NodeType.PROCESSING_INSTRUCTION_NODE;\n\t}\n\n\tpublic get nodeName(): string {\n\t\treturn this.target;\n\t}\n\n\t// ProcessingInstruction\n\n\tpublic target: string;\n\n\t/**\n\t * (non-standard) Use Document#createProcessingInstruction to create a processing instruction.\n\t *\n\t * @param target - The target of the processing instruction\n\t * @param data   - The data of the processing instruction\n\t */\n\tconstructor(target: string, data: string) {\n\t\tsuper(data);\n\n\t\tthis.target = target;\n\t}\n\n\t/**\n\t * (non-standard) Creates a copy of this, not including its children.\n\t *\n\t * @param document - The node document to associate with the copy\n\t *\n\t * @returns A shallow copy of this\n\t */\n\tpublic _copy(document: Document): ProcessingInstruction {\n\t\t// Set copy’s target and data to those of node.\n\t\tconst context = getContext(document);\n\t\tconst copy = new context.ProcessingInstruction(this.target, this.data);\n\t\tcopy.ownerDocument = document;\n\t\treturn copy;\n\t}\n}\n","import DocumentFragment from './DocumentFragment';\nimport Node from './Node';\nimport { getContext } from './context/Context';\nimport {\n\texpectArity,\n\tthrowHierarchyRequestError,\n\tthrowIndexSizeError,\n\tthrowInvalidNodeTypeError,\n\tthrowInvalidStateError,\n\tthrowNotSupportedError,\n\tthrowWrongDocumentError,\n} from './util/errorHelpers';\nimport { NodeType, isNodeOfType, isTextNode, isCharacterDataNode } from './util/NodeType';\nimport {\n\tdetermineLengthOfNode,\n\tforEachInclusiveDescendant,\n\tgetInclusiveAncestors,\n\tgetNodeDocument,\n\tgetNodeIndex,\n\tgetRootOfNode,\n} from './util/treeHelpers';\nimport { asObject, asUnsignedLong } from './util/typeHelpers';\nimport {\n\tappendNode,\n\tinsertNodeIntoRange,\n\tremoveNode,\n\treplaceAllWithNode,\n} from './util/mutationAlgorithms';\n\n/**\n * Interface AbstractRange\n *\n * Objects implementing the AbstractRange interface are known as ranges.\n *\n * @public\n */\nexport interface AbstractRange {\n\treadonly startContainer: Node;\n\treadonly startOffset: number;\n\treadonly endContainer: Node;\n\treadonly endOffset: number;\n\treadonly collapsed: boolean;\n}\n\ninterface StaticRangeInit {\n\tstartContainer: Node;\n\tstartOffset: number;\n\tendContainer: Node;\n\tendOffset: number;\n}\n\n/**\n * Interface StaticRange\n *\n * Updating live ranges in response to node tree mutations can be expensive. For every node tree\n * change, all affected Range objects need to be updated. Even if the application is uninterested in\n * some live ranges, it still has to pay the cost of keeping them up-to-date when a mutation occurs.\n *\n * A StaticRange object is a lightweight range that does not update when the node tree mutates. It\n * is therefore not subject to the same maintenance cost as live ranges.\n *\n * @public\n */\nexport class StaticRange implements AbstractRange {\n\tpublic readonly startContainer: Node;\n\tpublic readonly startOffset: number;\n\tpublic readonly endContainer: Node;\n\tpublic readonly endOffset: number;\n\tpublic readonly collapsed: boolean;\n\n\t/**\n\t * The StaticRange(init) constructor, when invoked, must run these steps:\n\t *\n\t * @param init - Dictionary representing the properties to set on the StaticRange\n\t */\n\tconstructor(init: StaticRangeInit) {\n\t\t// 1. If init’s startContainer or endContainer is a DocumentType or Attr node, then throw an\n\t\t// \"InvalidNodeTypeError\" DOMException.\n\t\tif (\n\t\t\tisNodeOfType(init.startContainer, NodeType.DOCUMENT_TYPE_NODE, NodeType.ATTRIBUTE_NODE)\n\t\t) {\n\t\t\tthrowInvalidNodeTypeError(\n\t\t\t\t'StaticRange startContainer must not be a doctype or attribute node'\n\t\t\t);\n\t\t}\n\t\tif (isNodeOfType(init.endContainer, NodeType.DOCUMENT_TYPE_NODE, NodeType.ATTRIBUTE_NODE)) {\n\t\t\tthrowInvalidNodeTypeError(\n\t\t\t\t'StaticRange endContainer must not be a doctype or attribute node'\n\t\t\t);\n\t\t}\n\n\t\t// 2. Let staticRange be a new StaticRange object.\n\t\t// 3. Set staticRange’s start to (init’s startContainer, init’s startOffset) and end to\n\t\t// (init’s endContainer, init’s endOffset).\n\t\tthis.startContainer = init.startContainer;\n\t\tthis.startOffset = init.startOffset;\n\t\tthis.endContainer = init.endContainer;\n\t\tthis.endOffset = init.endOffset;\n\t\tthis.collapsed =\n\t\t\tthis.startContainer === this.endContainer && this.startOffset === this.endOffset;\n\n\t\t// 4. Return staticRange.\n\t}\n}\n\n/**\n * A range is collapsed if its start node is its end node and its start offset is its end offset.\n *\n * @param range - The range to check\n */\nfunction isCollapsed(range: AbstractRange): boolean {\n\treturn range.startContainer === range.endContainer && range.startOffset === range.endOffset;\n}\n\n/**\n * Invokes callback on each node contained in range, in tree order, omitting any node whose parent\n * is also contained in range.\n *\n * @param range    - Range to traverse\n * @param callback - Callback to invoke for each contained node, should not modify node's position\n *                   in the tree\n */\nfunction forEachNodeContainedInRange(range: AbstractRange, callback: (node: Node) => void): void {\n\tif (range.collapsed) {\n\t\treturn;\n\t}\n\t// Determine common ancestors\n\tconst ancestors1 = getInclusiveAncestors(range.startContainer);\n\tconst ancestors2 = getInclusiveAncestors(range.endContainer);\n\tlet firstDistinctAncestorIndex = 0;\n\twhile (\n\t\tfirstDistinctAncestorIndex < ancestors1.length &&\n\t\tfirstDistinctAncestorIndex < ancestors2.length\n\t) {\n\t\tif (ancestors1[firstDistinctAncestorIndex] !== ancestors2[firstDistinctAncestorIndex]) {\n\t\t\tbreak;\n\t\t}\n\n\t\t++firstDistinctAncestorIndex;\n\t}\n\tconst firstChildOutside = range.endContainer.childNodes[range.endOffset] || null;\n\t// Walk along children of startContainer\n\tfor (\n\t\tlet child: Node | null = range.startContainer.childNodes[range.startOffset] || null;\n\t\tchild && child !== firstChildOutside && child !== ancestors2[ancestors1.length];\n\t\tchild = child.nextSibling\n\t) {\n\t\tcallback(child);\n\t}\n\t// Walk along siblings from startContainer to common ancestor\n\tfor (let i = ancestors1.length - 1; i >= firstDistinctAncestorIndex; --i) {\n\t\tfor (\n\t\t\tlet sibling = ancestors1[i].nextSibling;\n\t\t\tsibling && sibling !== firstChildOutside && sibling !== ancestors2[i];\n\t\t\tsibling = sibling.nextSibling\n\t\t) {\n\t\t\tcallback(sibling);\n\t\t}\n\t}\n\t// Walk back down to the endContainer, including its children\n\tfor (let i = firstDistinctAncestorIndex; i < ancestors2.length; ++i) {\n\t\tfor (\n\t\t\tlet child = ancestors2[i].firstChild;\n\t\t\tchild && child !== firstChildOutside && child !== ancestors2[i + 1];\n\t\t\tchild = child.nextSibling\n\t\t) {\n\t\t\tcallback(child);\n\t\t}\n\t}\n}\n\n/**\n * To extract a live range range, run these steps:\n * To clone the contents of a live range range, run these steps:\n * (algorithms merged as they are very similar)\n *\n * @param range   - the live range to extract (or clone) contents of\n * @param isClone - whether to clone the contents of the range or extract them\n *\n * @returns a DocumentFragment with the extracted or cloned contents\n */\nfunction extractRange(range: Range, isClone: boolean): DocumentFragment {\n\t// 1. Let fragment be a new DocumentFragment node whose node document is range's start node's\n\t// node document.\n\tconst document = getNodeDocument(range.startContainer);\n\tconst fragment = document.createDocumentFragment();\n\n\t// 2. If range is collapsed, then return fragment.\n\tif (range.collapsed) {\n\t\treturn fragment;\n\t}\n\n\t// 3. Let original start node, original start offset, original end node, and original end offset\n\t// be range's start node, start offset, end node, and end offset, respectively.\n\tconst originalStartNode = range.startContainer;\n\tconst originalStartOffset = range.startOffset;\n\tconst originalEndNode = range.endContainer;\n\tconst originalEndOffset = range.endOffset;\n\n\t// 4. If original start node is original end node and it is a CharacterData node, then:\n\tif (originalStartNode === originalEndNode && isCharacterDataNode(originalStartNode)) {\n\t\t// 4.1. Let clone be a clone of original start node.\n\t\tconst clone = originalStartNode.cloneNode();\n\n\t\t// 4.2. Set the data of clone to the result of substringing data with node original start\n\t\t// node, offset original start offset, and count original end offset minus original start\n\t\t// offset.\n\t\tclone.data = originalStartNode.substringData(\n\t\t\toriginalStartOffset,\n\t\t\toriginalEndOffset - originalStartOffset\n\t\t);\n\n\t\t// 4.3. Append clone to fragment.\n\t\tappendNode(clone, fragment);\n\n\t\tif (!isClone) {\n\t\t\t// 4.4. Replace data with node original start node, offset original start offset, count\n\t\t\t// original end offset minus original start offset, and data the empty string.\n\t\t\t// (step not used when cloning contents)\n\t\t\toriginalStartNode.replaceData(\n\t\t\t\toriginalStartOffset,\n\t\t\t\toriginalEndOffset - originalStartOffset,\n\t\t\t\t''\n\t\t\t);\n\t\t}\n\n\t\t// 4.5. Return fragment.\n\t\treturn fragment;\n\t}\n\n\t// 5. Let common ancestor be original start node.\n\t// 6. While common ancestor is not an inclusive ancestor of original end node, set common\n\t// ancestor to its own parent.\n\t// (implemented differently for performance reasons)\n\tconst ancestors1 = getInclusiveAncestors(range.startContainer);\n\tconst ancestors2 = getInclusiveAncestors(range.endContainer);\n\tlet firstDistinctAncestorIndex = 0;\n\twhile (\n\t\tfirstDistinctAncestorIndex < ancestors1.length &&\n\t\tfirstDistinctAncestorIndex < ancestors2.length\n\t) {\n\t\tif (ancestors1[firstDistinctAncestorIndex] !== ancestors2[firstDistinctAncestorIndex]) {\n\t\t\tbreak;\n\t\t}\n\n\t\t++firstDistinctAncestorIndex;\n\t}\n\tconst startContainsEnd = firstDistinctAncestorIndex === ancestors1.length;\n\tconst endContainsStart = firstDistinctAncestorIndex === ancestors2.length;\n\n\t// 7. Let first partially contained child be null.\n\tlet firstPartiallyContainedChild: Node | null = null;\n\n\t// 8. If original start node is not an inclusive ancestor of original end node, set first\n\t// partially contained child to the first child of common ancestor that is partially contained\n\t// in range.\n\tif (!startContainsEnd) {\n\t\tfirstPartiallyContainedChild = ancestors1[firstDistinctAncestorIndex];\n\t}\n\n\t// 9. Let last partially contained child be null.\n\tlet lastPartiallyContainedChild: Node | null = null;\n\n\t// 10. If original end node is not an inclusive ancestor of original start node, set last\n\t// partially contained child to the last child of common ancestor that is partially contained in\n\t// range.\n\tif (!endContainsStart) {\n\t\tlastPartiallyContainedChild = ancestors2[firstDistinctAncestorIndex];\n\t}\n\n\t// Note: These variable assignments do actually always make sense. For instance, if original\n\t// start node is not an inclusive ancestor of original end node, original start node is itself\n\t// partially contained in range, and so are all its ancestors up until a child of common\n\t// ancestor. common ancestor cannot be original start node, because it has to be an inclusive\n\t// ancestor of original end node. The other case is similar. Also, notice that the two children\n\t// will never be equal if both are defined.\n\n\t// 11. Let contained children be a list of all children of common ancestor that are contained in\n\t// range, in tree order.\n\t// (if firstPartiallyContainedChild is null, originalStartNode contains originalEndNode, so\n\t// there has to be a child at originalStartOffset)\n\tconst containedChildren: Node[] = [];\n\tconst firstChildAfterStart = firstPartiallyContainedChild\n\t\t? firstPartiallyContainedChild.nextSibling\n\t\t: originalStartNode.childNodes[originalStartOffset];\n\tconst firstChildAfterEnd =\n\t\tlastPartiallyContainedChild || originalEndNode.childNodes[originalEndOffset] || null;\n\tfor (\n\t\tvar child = firstChildAfterStart;\n\t\tchild && child !== firstChildAfterEnd;\n\t\tchild = child!.nextSibling\n\t) {\n\t\t// 12. If any member of contained children is a doctype, then throw a \"HierarchyRequestError\"\n\t\t// DOMException.\n\t\t// Note: We do not have to worry about the first or last partially contained node, because a\n\t\t// doctype can never be partially contained. It cannot be a boundary point of a range, and\n\t\t// it cannot be the ancestor of anything.\n\t\tif (isNodeOfType(child, NodeType.DOCUMENT_TYPE_NODE)) {\n\t\t\tthrowHierarchyRequestError(\n\t\t\t\tisClone\n\t\t\t\t\t? 'Can not clone a doctype using cloneContents'\n\t\t\t\t\t: 'Can not extract a doctype using extractContents'\n\t\t\t);\n\t\t}\n\t\tcontainedChildren.push(child);\n\t}\n\n\t// 13. If original start node is an inclusive ancestor of original end node, set new node to\n\t// original start node and new offset to original start offset.\n\t// (variables not used when cloning contents, as the range does not move)\n\tlet newNode: Node;\n\tlet newOffset: number;\n\tif (startContainsEnd || isClone) {\n\t\tnewNode = originalStartNode;\n\t\tnewOffset = originalStartOffset;\n\t} else {\n\t\t// 14. Otherwise:\n\t\t// (steps not used when cloning contents)\n\n\t\t// 14.1. Let reference node equal original start node.\n\t\t// 14.2. While reference node's parent is not null and is not an inclusive ancestor of\n\t\t// original end node, set reference node to its parent.\n\t\tconst referenceNode = ancestors1[firstDistinctAncestorIndex];\n\n\t\t// 14.3. Set new node to the parent of reference node, and new offset to one plus reference\n\t\t// node’s index.\n\t\t// Note: If reference node's parent is null, it would be the root of range, so would be an\n\t\t// inclusive ancestor of original end node, and we could not reach this point.\n\t\tnewNode = referenceNode.parentNode!;\n\t\tnewOffset = 1 + getNodeIndex(referenceNode);\n\t}\n\n\t// 15. If first partially contained child is a CharacterData node, then:\n\tif (\n\t\tfirstPartiallyContainedChild !== null &&\n\t\tisCharacterDataNode(firstPartiallyContainedChild)\n\t) {\n\t\t// Note: In this case, first partially contained child is original start node.\n\t\t// 15.1. Let clone be a clone of original start node.\n\t\tconst clone = firstPartiallyContainedChild.cloneNode();\n\n\t\t// 15.2. Set the data of clone to the result of substringing data with node original start\n\t\t// node, offset original start offset, and count original start node’s length minus original\n\t\t// start offset.\n\t\tclone.data = firstPartiallyContainedChild.substringData(\n\t\t\toriginalStartOffset,\n\t\t\tfirstPartiallyContainedChild.length - originalStartOffset\n\t\t);\n\n\t\t// 15.3. Append clone to fragment.\n\t\tappendNode(clone, fragment);\n\n\t\tif (!isClone) {\n\t\t\t// 15.4 Replace data with node original start node, offset original start offset, count\n\t\t\t// original start node's length minus original start offset, and data the empty string.\n\t\t\t// (step not used when cloning contents)\n\t\t\tfirstPartiallyContainedChild.replaceData(\n\t\t\t\toriginalStartOffset,\n\t\t\t\tfirstPartiallyContainedChild.length - originalStartOffset,\n\t\t\t\t''\n\t\t\t);\n\t\t}\n\t} else if (firstPartiallyContainedChild !== null) {\n\t\t// 16. Otherwise, if first partially contained child is not null:\n\n\t\t// 16.1. Let clone be a clone of first partially contained child.\n\t\tconst clone = firstPartiallyContainedChild.cloneNode();\n\n\t\t// 16.2. Append clone to fragment.\n\t\tappendNode(clone, fragment);\n\n\t\t// 16.3. Let subrange be a new live range whose start is (original start node, original\n\t\t// start offset) and whose end is (first partially contained child, first partially\n\t\t// contained child’s length).\n\t\tconst subrange = document.createRange();\n\t\tsubrange.setStart(originalStartNode, originalStartOffset);\n\t\tsubrange.setEnd(\n\t\t\tfirstPartiallyContainedChild,\n\t\t\tdetermineLengthOfNode(firstPartiallyContainedChild)\n\t\t);\n\n\t\t// 16.4. Let subfragment be the result of extracting / cloning the contents of subrange.\n\t\tconst subfragment = extractRange(subrange, isClone);\n\t\tsubrange.detach();\n\n\t\t// 16.5. Append subfragment to clone.\n\t\tappendNode(subfragment, clone);\n\t}\n\n\t// 17. For each contained child in contained children\n\tcontainedChildren.forEach((containedChild) => {\n\t\tif (isClone) {\n\t\t\t// 17.1. Let clone be a clone of contained child with the clone children flag set.\n\t\t\tconst clone = containedChild.cloneNode(true);\n\n\t\t\t// 17.2. Append clone to fragment.\n\t\t\tappendNode(clone, fragment);\n\t\t} else {\n\t\t\t// append contained child to fragment.\n\t\t\tappendNode(containedChild, fragment);\n\t\t}\n\t});\n\n\t// 18. If last partially contained child is a CharacterData node, then:\n\tif (lastPartiallyContainedChild && isCharacterDataNode(lastPartiallyContainedChild)) {\n\t\t// Note: In this case, last partially contained child is original end node.\n\n\t\t// 18.1 Let clone be a clone of original end node.\n\t\tconst clone = lastPartiallyContainedChild.cloneNode();\n\n\t\t// 18.2. Set the data of clone to the result of substringing data with node original end\n\t\t// node, offset 0, and count original end offset.\n\t\tclone.data = lastPartiallyContainedChild.substringData(0, originalEndOffset);\n\n\t\t// 18.3. Append clone to fragment.\n\t\tappendNode(clone, fragment);\n\n\t\tif (!isClone) {\n\t\t\t// 18.4. Replace data with node original end node, offset 0, count original end offset,\n\t\t\t// and data the empty string.\n\t\t\t// (step not used when cloning contents)\n\t\t\tlastPartiallyContainedChild.replaceData(0, originalEndOffset, '');\n\t\t}\n\t} else if (lastPartiallyContainedChild !== null) {\n\t\t// 19. Otherwise, if last partially contained child is not null:\n\n\t\t// 19.1. Let clone be a clone of last partially contained child.\n\t\tconst clone = lastPartiallyContainedChild.cloneNode();\n\n\t\t// 19.2. Append clone to fragment.\n\t\tappendNode(clone, fragment);\n\n\t\t// 19.3. Let subrange be a new live range whose start is (last partially contained child, 0)\n\t\t// and whose end is (original end node, original end offset).\n\t\tconst subrange = document.createRange();\n\t\tsubrange.setStart(lastPartiallyContainedChild, 0);\n\t\tsubrange.setEnd(originalEndNode, originalEndOffset);\n\n\t\t// 19.4. Let subfragment be the result of extracting / cloning the contents of subrange.\n\t\tconst subfragment = extractRange(subrange, isClone);\n\t\tsubrange.detach();\n\n\t\t// 19.5. Append subfragment to clone.\n\t\tappendNode(subfragment, clone);\n\t}\n\n\tif (!isClone) {\n\t\t// 20. Set range’s start and end to (new node, new offset).\n\t\t// (step not used when cloning contents)\n\t\trange.setStart(newNode, newOffset);\n\t\trange.collapse(true);\n\t}\n\n\t// 21. Return fragment.\n\treturn fragment;\n}\n\n/**\n * Interface Range\n *\n * Objects implementing the Range interface are known as live ranges.\n *\n * @public\n */\nexport default class Range implements AbstractRange {\n\tpublic startContainer: Node;\n\tpublic startOffset: number;\n\tpublic endContainer: Node;\n\tpublic endOffset: number;\n\n\tpublic get collapsed(): boolean {\n\t\treturn isCollapsed(this);\n\t}\n\n\t/**\n\t * The Range() constructor, when invoked, must return a new live range with (current global\n\t * object’s associated Document, 0) as its start and end.\n\t */\n\tconstructor() {\n\t\tconst context = getContext(this);\n\t\tthis.startContainer = context.document;\n\t\tthis.startOffset = 0;\n\t\tthis.endContainer = context.document;\n\t\tthis.endOffset = 0;\n\t\tcontext.addRange(this);\n\t}\n\n\t/**\n\t * Get the common ancestor of the range's boundary position nodes.\n\t *\n\t * Note: for efficiency reasons, this implementation deviates from the algorithm given in 4.2.\n\t */\n\tpublic get commonAncestorContainer(): Node {\n\t\tconst ancestors1 = getInclusiveAncestors(this.startContainer);\n\t\tconst ancestors2 = getInclusiveAncestors(this.endContainer);\n\t\tlet commonAncestorContainer = ancestors1[0];\n\t\tlet i = 0;\n\t\twhile (i < ancestors1.length && i < ancestors2.length) {\n\t\t\tif (ancestors1[i] !== ancestors2[i]) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcommonAncestorContainer = ancestors1[i];\n\t\t\t++i;\n\t\t}\n\n\t\treturn commonAncestorContainer;\n\t}\n\n\t/**\n\t * Sets the start boundary point of the range.\n\t *\n\t * @param node   - The new start container\n\t * @param offset - The new start offset\n\t */\n\tsetStart(node: Node, offset: number): void {\n\t\texpectArity(arguments, 2);\n\t\tnode = asObject(node, Node);\n\t\toffset = asUnsignedLong(offset);\n\n\t\t// 1. If node is a doctype, then throw an InvalidNodeTypeError.\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE)) {\n\t\t\tthrowInvalidNodeTypeError('Can not set a range under a doctype node');\n\t\t}\n\n\t\t// 2. If offset is greater than node’s length, then throw an IndexSizeError.\n\t\tif (offset > determineLengthOfNode(node)) {\n\t\t\tthrowIndexSizeError('Can not set a range past the end of the node');\n\t\t}\n\n\t\t// 3. Let bp be the boundary point (node, offset).\n\t\t// 4.a. If these steps were invoked as \"set the start\"\n\t\t// 4.a.1. If range’s root is not equal to node’s root, or if bp is after the range’s end,\n\t\t// set range’s end to bp.\n\t\tconst rootOfRange = getRootOfRange(this);\n\t\tconst rootOfNode = getRootOfNode(node);\n\t\tif (\n\t\t\trootOfRange !== rootOfNode ||\n\t\t\tcompareBoundaryPointPositions(node, offset, this.endContainer, this.endOffset) ===\n\t\t\t\tPOSITION_AFTER\n\t\t) {\n\t\t\tthis.endContainer = node;\n\t\t\tthis.endOffset = offset;\n\t\t}\n\t\t// 4.a.2. Set range’s start to bp.\n\t\tthis.startContainer = node;\n\t\tthis.startOffset = offset;\n\n\t\t// 4.b. If these steps were invoked as \"set the end\"\n\t\t// 4.b.1. If range’s root is not equal to node’s root, or if bp is before the range’s start,\n\t\t// set range’s start to bp.\n\t\t// 4.b.2. Set range’s end to bp.\n\t\t// (see Range#setEnd for this branch)\n\t}\n\n\t/**\n\t * Sets the end boundary point of the range.\n\t *\n\t * @param node   - The new end container\n\t * @param offset - The new end offset\n\t */\n\tsetEnd(node: Node, offset: number): void {\n\t\texpectArity(arguments, 2);\n\t\tnode = asObject(node, Node);\n\t\toffset = asUnsignedLong(offset);\n\n\t\t// 1. If node is a doctype, then throw an InvalidNodeTypeError.\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE)) {\n\t\t\tthrowInvalidNodeTypeError('Can not set a range under a doctype node');\n\t\t}\n\n\t\t// 2. If offset is greater than node’s length, then throw an IndexSizeError.\n\t\tif (offset > determineLengthOfNode(node)) {\n\t\t\tthrowIndexSizeError('Can not set a range past the end of the node');\n\t\t}\n\n\t\t// 3. Let bp be the boundary point (node, offset).\n\t\t// 4.a. If these steps were invoked as \"set the start\"\n\t\t// 4.a.1. If range’s root is not equal to node’s root, or if bp is after the range’s end,\n\t\t// set range’s end to bp.\n\t\t// 4.a.2. Set range’s start to bp.\n\t\t// (see Range#setStart for this branch)\n\n\t\t// 4.b. If these steps were invoked as \"set the end\"\n\t\t// 4.b.1. If range’s root is not equal to node’s root, or if bp is before the range’s start,\n\t\t// set range’s start to bp.\n\t\tconst rootOfRange = getRootOfRange(this);\n\t\tconst rootOfNode = getRootOfNode(node);\n\t\tif (\n\t\t\trootOfRange !== rootOfNode ||\n\t\t\tcompareBoundaryPointPositions(node, offset, this.startContainer, this.startOffset) ===\n\t\t\t\tPOSITION_BEFORE\n\t\t) {\n\t\t\tthis.startContainer = node;\n\t\t\tthis.startOffset = offset;\n\t\t}\n\t\t// 4.b.2. Set range’s end to bp.\n\t\tthis.endContainer = node;\n\t\tthis.endOffset = offset;\n\t}\n\n\t/**\n\t * Sets the start boundary point of the range to the position just before the given node.\n\t *\n\t * @param node - The node to set the range's start before\n\t */\n\tsetStartBefore(node: Node): void {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\t// 1. Let parent be node’s parent.\n\t\tconst parent = node.parentNode;\n\n\t\t// 2. If parent is null, then throw an InvalidNodeTypeError.\n\t\tif (parent === null) {\n\t\t\treturn throwInvalidNodeTypeError('Can not set range before node without a parent');\n\t\t}\n\n\t\t// 3. Set the start of this to boundary point (parent, node’s index).\n\t\tthis.setStart(parent, getNodeIndex(node));\n\t}\n\n\t/**\n\t * Sets the start boundary point of the range to the position just after the given node.\n\t *\n\t * @param node - The node to set the range's start before\n\t */\n\tsetStartAfter(node: Node): void {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\t// 1. Let parent be node’s parent.\n\t\tconst parent = node.parentNode;\n\n\t\t// 2. If parent is null, then throw an InvalidNodeTypeError.\n\t\tif (parent === null) {\n\t\t\treturn throwInvalidNodeTypeError('Can not set range before node without a parent');\n\t\t}\n\n\t\t// 3. Set the start of this to boundary point (parent, node’s index plus one).\n\t\tthis.setStart(parent, getNodeIndex(node) + 1);\n\t}\n\n\t/**\n\t * Sets the end boundary point of the range to the position just before the given node.\n\t *\n\t * @param node - The node to set the range's end before\n\t */\n\tsetEndBefore(node: Node): void {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\t// 1. Let parent be node’s parent.\n\t\tconst parent = node.parentNode;\n\n\t\t// 2. If parent is null, then throw an InvalidNodeTypeError.\n\t\tif (parent === null) {\n\t\t\treturn throwInvalidNodeTypeError('Can not set range before node without a parent');\n\t\t}\n\n\t\t// 3. Set the end of this to boundary point (parent, node’s index).\n\t\tthis.setEnd(parent, getNodeIndex(node));\n\t}\n\n\t/**\n\t * Sets the end boundary point of the range to the position just after the given node.\n\t *\n\t * @param node - The node to set the range's end before\n\t */\n\tsetEndAfter(node: Node): void {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\t// 1. Let parent be node’s parent.\n\t\tconst parent = node.parentNode;\n\n\t\t// 2. If parent is null, then throw an InvalidNodeTypeError.\n\t\tif (parent === null) {\n\t\t\treturn throwInvalidNodeTypeError('Can not set range before node without a parent');\n\t\t}\n\n\t\t// 3. Set the end of this to boundary point (parent, node’s index plus one).\n\t\tthis.setEnd(parent, getNodeIndex(node) + 1);\n\t}\n\n\t/**\n\t * Sets the range's boundary points to the same position.\n\t *\n\t * @param toStart - If true, set both points to the start of the range, otherwise set them to\n\t *                  the end\n\t */\n\tcollapse(toStart: boolean = false): void {\n\t\tif (toStart) {\n\t\t\tthis.endContainer = this.startContainer;\n\t\t\tthis.endOffset = this.startOffset;\n\t\t} else {\n\t\t\tthis.startContainer = this.endContainer;\n\t\t\tthis.startOffset = this.endOffset;\n\t\t}\n\t}\n\n\tselectNode(node: Node): void {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\t// 1. Let parent be node’s parent.\n\t\tlet parent = node.parentNode;\n\n\t\t// 2. If parent is null, then throw an InvalidNodeTypeError.\n\t\tif (parent === null) {\n\t\t\treturn throwInvalidNodeTypeError('Can not select node with null parent');\n\t\t}\n\n\t\t// 3. Let index be node’s index.\n\t\tconst index = getNodeIndex(node);\n\n\t\t// 4. Set range’s start to boundary point (parent, index).\n\t\tthis.startContainer = parent;\n\t\tthis.startOffset = index;\n\n\t\t// 5. Set range’s end to boundary point (parent, index plus one).\n\t\tthis.endContainer = parent;\n\t\tthis.endOffset = index + 1;\n\t}\n\n\tselectNodeContents(node: Node): void {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\t// 1. If node is a doctype, then throw an InvalidNodeTypeError.\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE)) {\n\t\t\tthrowInvalidNodeTypeError('Can not place range inside a doctype node');\n\t\t}\n\n\t\t// 2. Let length be the length of node.\n\t\tconst length = determineLengthOfNode(node);\n\n\t\t// 3. Set start to the boundary point (node, 0).\n\t\tthis.startContainer = node;\n\t\tthis.startOffset = 0;\n\n\t\t// 4. Set end to the boundary point (node, length).\n\t\tthis.endContainer = node;\n\t\tthis.endOffset = length;\n\t}\n\n\tstatic START_TO_START = 0;\n\tstatic START_TO_END = 1;\n\tstatic END_TO_END = 2;\n\tstatic END_TO_START = 3;\n\n\tcompareBoundaryPoints(how: number, sourceRange: Range): number {\n\t\texpectArity(arguments, 2);\n\t\tsourceRange = asObject(sourceRange, Range);\n\n\t\t// 1. If how is not one of START_TO_START, START_TO_END, END_TO_END, and END_TO_START, then\n\t\t// throw a NotSupportedError.\n\t\tif (\n\t\t\thow !== Range.START_TO_START &&\n\t\t\thow !== Range.START_TO_END &&\n\t\t\thow !== Range.END_TO_END &&\n\t\t\thow !== Range.END_TO_START\n\t\t) {\n\t\t\tthrowNotSupportedError('Unsupported comparison type');\n\t\t}\n\n\t\t// 2. If this’s root is not the same as sourceRange’s root, then throw a\n\t\t// WrongDocumentError.\n\t\tif (getRootOfRange(this) !== getRootOfRange(sourceRange)) {\n\t\t\tthrowWrongDocumentError('Can not compare positions of ranges in different trees');\n\t\t}\n\n\t\t// 3. If how is:\n\t\tswitch (how) {\n\t\t\t// START_TO_START:\n\t\t\tcase Range.START_TO_START:\n\t\t\t\t// Let this point be this’s start. Let other point be sourceRange’s\n\t\t\t\t// start.\n\t\t\t\treturn compareBoundaryPointPositions(\n\t\t\t\t\t// this point\n\t\t\t\t\tthis.startContainer,\n\t\t\t\t\tthis.startOffset,\n\t\t\t\t\t// other point\n\t\t\t\t\tsourceRange.startContainer,\n\t\t\t\t\tsourceRange.startOffset\n\t\t\t\t);\n\n\t\t\t// START_TO_END:\n\t\t\tcase Range.START_TO_END:\n\t\t\t\t// Let this point be this’s end. Let other point be sourceRange’s\n\t\t\t\t// start.\n\t\t\t\treturn compareBoundaryPointPositions(\n\t\t\t\t\t// this point\n\t\t\t\t\tthis.endContainer,\n\t\t\t\t\tthis.endOffset,\n\t\t\t\t\t// other point\n\t\t\t\t\tsourceRange.startContainer,\n\t\t\t\t\tsourceRange.startOffset\n\t\t\t\t);\n\n\t\t\t// END_TO_END:\n\t\t\tcase Range.END_TO_END:\n\t\t\t\t// Let this point be this’s end. Let other point be sourceRange’s end.\n\t\t\t\treturn compareBoundaryPointPositions(\n\t\t\t\t\t// this point\n\t\t\t\t\tthis.endContainer,\n\t\t\t\t\tthis.endOffset,\n\t\t\t\t\t// other point\n\t\t\t\t\tsourceRange.endContainer,\n\t\t\t\t\tsourceRange.endOffset\n\t\t\t\t);\n\n\t\t\t// END_TO_START:\n\t\t\tdefault:\n\t\t\t\t// Let this point be this’s start. Let other point be sourceRange’s\n\t\t\t\t// end.\n\t\t\t\treturn compareBoundaryPointPositions(\n\t\t\t\t\t// this point\n\t\t\t\t\tthis.startContainer,\n\t\t\t\t\tthis.startOffset,\n\t\t\t\t\t// other point,\n\t\t\t\t\tsourceRange.endContainer,\n\t\t\t\t\tsourceRange.endOffset\n\t\t\t\t);\n\t\t}\n\n\t\t// 4. If the position of this point relative to other point is\n\t\t// before: Return −1.\n\t\t// equal: Return 0.\n\t\t// after: Return 1.\n\t\t// (handled in switch above)\n\t}\n\n\t/**\n\t * Removes the contents of the range\n\t */\n\tdeleteContents(): void {\n\t\t// 1.  If this is collapsed, then return.\n\t\tif (this.collapsed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// 2. Let original start node, original start offset, original end node, and original end\n\t\t// offset be this's start node, start offset, end node, and end offset, respectively.\n\t\tconst originalStartNode = this.startContainer;\n\t\tconst originalStartOffset = this.startOffset;\n\t\tconst originalEndNode = this.endContainer;\n\t\tconst originalEndOffset = this.endOffset;\n\n\t\t// 3. If original start node is original end node and it is a CharacterData node, then\n\t\t// replace data with node original start node, offset original start offset, count original\n\t\t// end offset minus original start offset, and data the empty string, and then return.\n\t\tif (originalStartNode === originalEndNode && isCharacterDataNode(originalStartNode)) {\n\t\t\toriginalStartNode.replaceData(\n\t\t\t\toriginalStartOffset,\n\t\t\t\toriginalEndOffset - originalStartOffset,\n\t\t\t\t''\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// 4. Let nodes to remove be a list of all the nodes that are contained in this, in tree\n\t\t// order, omitting any node whose parent is also contained in this.\n\t\tconst nodesToRemove: Node[] = [];\n\t\tforEachNodeContainedInRange(this, (node) => {\n\t\t\tnodesToRemove.push(node);\n\t\t});\n\n\t\t// 5. If original start node is an inclusive ancestor of original end node, set new node to\n\t\t// original start node and new offset to original start offset.\n\t\tlet newNode: Node;\n\t\tlet newOffset: number;\n\t\tif (originalStartNode.contains(originalEndNode)) {\n\t\t\tnewNode = originalStartNode;\n\t\t\tnewOffset = originalStartOffset;\n\t\t} else {\n\t\t\t// 6. Otherwise:\n\t\t\t// 6.1. Let reference node equal original start node.\n\t\t\tlet referenceNode = originalStartNode;\n\n\t\t\t// 6.2. While reference node's parent is not null and is not an inclusive ancestor of\n\t\t\t// original end node, set reference node to its parent.\n\t\t\twhile (\n\t\t\t\treferenceNode.parentNode !== null &&\n\t\t\t\t!referenceNode.parentNode.contains(originalEndNode)\n\t\t\t) {\n\t\t\t\treferenceNode = referenceNode.parentNode;\n\t\t\t}\n\n\t\t\t// 6.3. Set new node to the parent of reference node, and new offset to one plus the\n\t\t\t// index of reference node.\n\t\t\t// Note: If reference node’s parent were null, it would be the root of this, so would be\n\t\t\t// an inclusive ancestor of original end node, and we could not reach this point.\n\t\t\tnewNode = referenceNode.parentNode!;\n\t\t\tnewOffset = 1 + getNodeIndex(referenceNode);\n\t\t}\n\n\t\t// 7. If original start node is a CharacterData node, then replace data with node original\n\t\t// start node, offset original start offset, count original start node's length minus\n\t\t// original start offset, data the empty string.\n\t\tif (isCharacterDataNode(originalStartNode)) {\n\t\t\toriginalStartNode.replaceData(\n\t\t\t\toriginalStartOffset,\n\t\t\t\toriginalStartNode.length - originalStartOffset,\n\t\t\t\t''\n\t\t\t);\n\t\t}\n\n\t\t// 8. For each node in nodes to remove, in tree order, remove node.\n\t\tnodesToRemove.forEach((node) => {\n\t\t\tremoveNode(node);\n\t\t});\n\n\t\t// 9. If original end node is a CharacterData node, then replace data with node original end\n\t\t// node, offset 0, count original end offset and data the empty string.\n\t\tif (isCharacterDataNode(originalEndNode)) {\n\t\t\toriginalEndNode.replaceData(0, originalEndOffset, '');\n\t\t}\n\n\t\t// 10. Set start and end to (new node, new offset).\n\t\tthis.setStart(newNode, newOffset);\n\t\tthis.collapse(true);\n\t}\n\n\t/**\n\t * Move the contents of this range into a new DocumentFragment\n\t *\n\t * @returns DocumentFragment containing the Range's previous contents\n\t */\n\textractContents(): DocumentFragment {\n\t\treturn extractRange(this, false);\n\t}\n\n\t/**\n\t * Clone the contents of this range into a new DocumentFragment\n\t *\n\t * @returns DocumentFragment containing a copy of the Range's contents\n\t */\n\tcloneContents(): DocumentFragment {\n\t\treturn extractRange(this, true);\n\t}\n\n\t/**\n\t * Insert node at the start of this range\n\t *\n\t * @param node - Node to insert\n\t */\n\tinsertNode(node: Node): void {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\tinsertNodeIntoRange(node, this);\n\t}\n\n\t/**\n\t * Wraps the contents of this range in the given new parent\n\t *\n\t * This only works if the only partially contained nodes are text nodes. Any existing children\n\t * of newParent will be removed.\n\t *\n\t * @param newParent - Node to insert\n\t */\n\tsurroundContents(newParent: Node): void {\n\t\texpectArity(arguments, 1);\n\t\tnewParent = asObject(newParent, Node);\n\n\t\t// 1. If a non-Text node is partially contained in this, then throw an \"InvalidStateError\"\n\t\t// DOMException.\n\t\tconst startNonTextNode = isTextNode(this.startContainer)\n\t\t\t? this.startContainer.parentNode\n\t\t\t: this.startContainer;\n\t\tconst endNonTextNode = isTextNode(this.endContainer)\n\t\t\t? this.endContainer.parentNode\n\t\t\t: this.endContainer;\n\t\tif (startNonTextNode !== endNonTextNode) {\n\t\t\tthrowInvalidStateError(\n\t\t\t\t'Can not use surroundContents on a range that has partially selected a non-Text node'\n\t\t\t);\n\t\t}\n\n\t\t// 2. If newParent is a Document, DocumentType, or DocumentFragment node, then throw an\n\t\t// \"InvalidNodeTypeError\" DOMException.\n\t\t// Note: For historical reasons CharacterData nodes are not checked here and end up throwing\n\t\t// later on as a side effect.\n\t\tif (\n\t\t\tisNodeOfType(\n\t\t\t\tnewParent,\n\t\t\t\tNodeType.DOCUMENT_NODE,\n\t\t\t\tNodeType.DOCUMENT_TYPE_NODE,\n\t\t\t\tNodeType.DOCUMENT_FRAGMENT_NODE\n\t\t\t)\n\t\t) {\n\t\t\tthrowInvalidNodeTypeError(\n\t\t\t\t'Can not use Document, DocumentType, or DocumentFragment as a parent node in surroundContents'\n\t\t\t);\n\t\t}\n\n\t\t// 3. Let fragment be the result of extracting this.\n\t\tconst fragment = extractRange(this, false);\n\n\t\t// 4. If newParent has children, then replace all with null within newParent.\n\t\tif (newParent.firstChild) {\n\t\t\treplaceAllWithNode(null, newParent);\n\t\t}\n\n\t\t// 5. Insert newParent into this.\n\t\tinsertNodeIntoRange(newParent, this);\n\n\t\t// 6. Append fragment to newParent.\n\t\tappendNode(fragment, newParent);\n\n\t\t// 7. Select newParent within this.\n\t\tthis.selectNode(newParent);\n\t}\n\n\t/**\n\t * Returns a range with the same start and end as this.\n\t *\n\t * @returns A copy of this\n\t */\n\tcloneRange(): Range {\n\t\tconst context = getContext(this);\n\t\tconst range = new context.Range();\n\t\trange.startContainer = this.startContainer;\n\t\trange.startOffset = this.startOffset;\n\t\trange.endContainer = this.endContainer;\n\t\trange.endOffset = this.endOffset;\n\t\treturn range;\n\t}\n\n\t/**\n\t * Stops tracking the range.\n\t *\n\t * (non-standard) According to the spec, this method must do nothing. However, it is not yet\n\t * possible in all browsers to allow garbage collection while keeping track of active ranges to\n\t * be updated by mutations. Therefore, unless your code will only run in environments that\n\t * implement the WeakRef proposal (https://github.com/tc39/proposal-weakrefs), make sure to call\n\t * this method to stop updating the range and free up its resources.\n\t */\n\tdetach(): void {\n\t\tconst context = getContext(this);\n\t\tcontext.removeRange(this);\n\t}\n\n\t/**\n\t * Returns true if the given point is after or equal to the start point and before or equal to\n\t * the end point of this.\n\t *\n\t * @param node   - Node of point to check\n\t * @param offset - Offset of point to check\n\t *\n\t * @returns Whether the point is in the range\n\t */\n\tisPointInRange(node: Node, offset: number): boolean {\n\t\texpectArity(arguments, 2);\n\t\tnode = asObject(node, Node);\n\t\toffset = asUnsignedLong(offset);\n\n\t\t// 1. If node’s root is different from this’s root, return false.\n\t\tif (getRootOfNode(node) !== getRootOfRange(this)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// 2. If node is a doctype, then throw an InvalidNodeTypeError.\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE)) {\n\t\t\tthrowInvalidNodeTypeError('Point can not be under a doctype');\n\t\t}\n\n\t\t// 3. If offset is greater than node’s length, then throw an IndexSizeError.\n\t\tif (offset > determineLengthOfNode(node)) {\n\t\t\tthrowIndexSizeError('Offset should not be past the end of node');\n\t\t}\n\n\t\t// 4. If (node, offset) is before start or after end, return false.\n\t\tif (\n\t\t\tcompareBoundaryPointPositions(node, offset, this.startContainer, this.startOffset) ===\n\t\t\t\tPOSITION_BEFORE ||\n\t\t\tcompareBoundaryPointPositions(node, offset, this.endContainer, this.endOffset) ===\n\t\t\t\tPOSITION_AFTER\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// 5. Return true.\n\t\treturn true;\n\t}\n\n\t/**\n\t * Compares the given point to the range's boundary points.\n\t *\n\t * @param node   - Node of point to check\n\t * @param offset - Offset of point to check\n\t *\n\t * @returns -1, 0 or 1 depending on whether the point is before, inside or after the range,\n\t *         respectively\n\t */\n\tcomparePoint(node: Node, offset: number): number {\n\t\texpectArity(arguments, 2);\n\t\tnode = asObject(node, Node);\n\t\toffset = asUnsignedLong(offset);\n\n\t\t// 1. If node’s root is different from this’s root, then throw a\n\t\t// WrongDocumentError.\n\t\tif (getRootOfNode(node) !== getRootOfRange(this)) {\n\t\t\tthrowWrongDocumentError('Can not compare point to range in different trees');\n\t\t}\n\n\t\t// 2. If node is a doctype, then throw an InvalidNodeTypeError.\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE)) {\n\t\t\tthrowInvalidNodeTypeError('Point can not be under a doctype');\n\t\t}\n\n\t\t// 3. If offset is greater than node’s length, then throw an IndexSizeError.\n\t\tif (offset > determineLengthOfNode(node)) {\n\t\t\tthrowIndexSizeError('Offset should not be past the end of node');\n\t\t}\n\n\t\t// 4. If (node, offset) is before start, return −1.\n\t\tif (\n\t\t\tcompareBoundaryPointPositions(node, offset, this.startContainer, this.startOffset) ===\n\t\t\tPOSITION_BEFORE\n\t\t) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t// 5. If (node, offset) is after end, return 1.\n\t\tif (\n\t\t\tcompareBoundaryPointPositions(node, offset, this.endContainer, this.endOffset) ===\n\t\t\tPOSITION_AFTER\n\t\t) {\n\t\t\treturn 1;\n\t\t}\n\n\t\t// 6. Return 0.\n\t\treturn 0;\n\t}\n\n\t/**\n\t * Returns true if range overlaps the range from before node to after node.\n\t *\n\t * @param node - The node to check\n\t *\n\t * @returns Whether the range intersects node\n\t */\n\tintersectsNode(node: Node): boolean {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\t// 1. If node’s root is different from this’s root, return false.\n\t\tif (getRootOfNode(node) !== getRootOfRange(this)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// 2. Let parent be node’s parent.\n\t\tconst parent = node.parentNode;\n\n\t\t// 3. If parent is null, return true.\n\t\tif (parent === null) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// 4. Let offset be node’s index.\n\t\tconst offset = getNodeIndex(node);\n\n\t\t// 5. If (parent, offset) is before end and (parent, offset + 1) is after start, return\n\t\t// true.\n\t\t// 6. Return false.\n\t\treturn (\n\t\t\tcompareBoundaryPointPositions(parent, offset, this.endContainer, this.endOffset) ===\n\t\t\t\tPOSITION_BEFORE &&\n\t\t\tcompareBoundaryPointPositions(\n\t\t\t\tparent,\n\t\t\t\toffset + 1,\n\t\t\t\tthis.startContainer,\n\t\t\t\tthis.startOffset\n\t\t\t) === POSITION_AFTER\n\t\t);\n\t}\n\n\t/**\n\t * The stringification behavior must run these steps:\n\t */\n\ttoString(): string {\n\t\t// 1. Let s be the empty string.\n\t\tlet s: string[] = [];\n\n\t\t// 2. If this's start node is this's end node and it is a Text node, then return the\n\t\t// substring of that Text node's data beginning at this's start offset and ending at this's\n\t\t// end offset.\n\t\tconst startContainer = this.startContainer;\n\t\tif (isTextNode(startContainer)) {\n\t\t\tif (this.startContainer === this.endContainer) {\n\t\t\t\treturn startContainer.substringData(\n\t\t\t\t\tthis.startOffset,\n\t\t\t\t\tthis.endOffset - this.startOffset\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// 3. If this's start node is a Text node, then append the substring of that node's data\n\t\t\t// from this's start offset until the end to s.\n\t\t\ts.push(\n\t\t\t\tstartContainer.substringData(\n\t\t\t\t\tthis.startOffset,\n\t\t\t\t\tstartContainer.length - this.startOffset\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t// 4. Append the concatenation of the data of all Text nodes that are contained in this, in\n\t\t// tree order, to s.\n\t\tforEachNodeContainedInRange(this, (node) => {\n\t\t\tforEachInclusiveDescendant(node, (node) => {\n\t\t\t\tif (isTextNode(node)) {\n\t\t\t\t\ts.push(node.data);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\t// 5. If this's end node is a Text node, then append the substring of that node's data from\n\t\t// its start until this’s end offset to s.\n\t\tconst endContainer = this.endContainer;\n\t\tif (isTextNode(endContainer)) {\n\t\t\ts.push(endContainer.substringData(0, this.endOffset));\n\t\t}\n\n\t\t// 6. Return s.\n\t\treturn s.join('');\n\t}\n}\n\nconst POSITION_BEFORE = -1;\nconst POSITION_EQUAL = 0;\nconst POSITION_AFTER = 1;\n\n/**\n * If the two nodes of boundary points (node A, offset A) and (node B, offset B) have the same root,\n * the position of the first relative to the second is either before, equal, or after.\n *\n * Note: for efficiency reasons, this implementation deviates from the algorithm given in 4.2.\n *\n * This implementation assumes it is called on nodes under the same root.\n *\n * @param nodeA   - First boundary point's node\n * @param offsetA - First boundary point's offset\n * @param nodeB   - Second boundary point's node\n * @param offsetB - Second boundary point's offset\n *\n * @returns -1, 0 or 1, depending on the boundary points' relative positions\n */\nfunction compareBoundaryPointPositions(\n\tnodeA: Node,\n\toffsetA: number,\n\tnodeB: Node,\n\toffsetB: number\n): number {\n\tif (nodeA !== nodeB) {\n\t\tconst ancestors1 = getInclusiveAncestors(nodeA);\n\t\tconst ancestors2 = getInclusiveAncestors(nodeB);\n\n\t\t// Skip common parents\n\t\twhile (ancestors1[0] && ancestors2[0] && ancestors1[0] === ancestors2[0]) {\n\t\t\tancestors1.shift();\n\t\t\tancestors2.shift();\n\t\t}\n\n\t\t// Compute offsets at the level under the last common parent. Add 0.5 to bias positions\n\t\t// inside the parent vs. those before or after.\n\t\tif (ancestors1.length) {\n\t\t\toffsetA = getNodeIndex(ancestors1[0]) + 0.5;\n\t\t}\n\t\tif (ancestors2.length) {\n\t\t\toffsetB = getNodeIndex(ancestors2[0]) + 0.5;\n\t\t}\n\t}\n\n\t// Compare positions at this level\n\tif (offsetA === offsetB) {\n\t\treturn POSITION_EQUAL;\n\t}\n\treturn offsetA < offsetB ? POSITION_BEFORE : POSITION_AFTER;\n}\n\n/**\n * The root of a range is the root of its start node.\n *\n * @param range - The range to get the root of\n *\n * @returns The root of range\n */\nfunction getRootOfRange(range: Range): Node {\n\treturn getRootOfNode(range.startContainer);\n}\n","import Document from './Document';\nimport { getContext } from './context/Context';\n\n/**\n * @public\n */\nexport default class XMLDocument extends Document {\n\t/**\n\t * (non-standard) Creates a copy of this, not including its children.\n\t *\n\t * @param document - The node document to associate with the copy\n\t *\n\t * @returns A shallow copy of this\n\t */\n\tpublic _copy(document: Document): XMLDocument {\n\t\t// Set copy’s encoding, content type, URL, origin, type, and mode, to those of node.\n\t\t// (properties not implemented)\n\n\t\tconst context = getContext(document);\n\t\treturn new context.XMLDocument();\n\t}\n}\n","export { default as Attr } from './Attr';\nexport { default as CDATASection } from './CDATASection';\nexport { default as CharacterData } from './CharacterData';\nexport { default as Comment } from './Comment';\nexport { default as Document } from './Document';\nexport { default as DocumentFragment } from './DocumentFragment';\nexport { default as DocumentType } from './DocumentType';\nexport { default as DOMImplementation } from './DOMImplementation';\nexport { default as Element } from './Element';\nexport { default as Node } from './Node';\nexport { default as ProcessingInstruction } from './ProcessingInstruction';\nexport { default as Range } from './Range';\nexport { StaticRange } from './Range';\nexport { default as Text } from './Text';\nexport { default as XMLDocument } from './XMLDocument';\nexport { default as DOMParser } from './dom-parsing/DOMParser';\nexport { default as XMLSerializer } from './dom-parsing/XMLSerializer';\nexport { default as MutationObserver } from './mutation-observer/MutationObserver';\nexport { default as MutationRecord } from './mutation-observer/MutationRecord';\nexport { DOMException } from './util/errorHelpers';\n\nexport { parseXmlDocument, parseXmlFragment } from './dom-parsing/parsingAlgorithms';\nexport type { ParseOptions } from './dom-parsing/parsingAlgorithms';\n\n// Standard DOM does not expose a way to serialize arbitrary nodes as well-formed XML\nexport { serializeToWellFormedString } from './dom-parsing/XMLSerializer';\n\n// Unsafe exports, required for connecting a HTML parser\nexport { unsafeCreateAttribute, unsafeCreateElement, unsafeAppendAttribute } from './unsafe';\n\n// To avoid cyclic dependencies and enable multiple contexts with their own constructors later,\n// inject all constructors as well as the global document into the default context (i.e., global\n// object) here.\nimport { defaultContext } from './context/Context';\n\nimport Attr from './Attr';\nimport CDATASection from './CDATASection';\nimport Comment from './Comment';\nimport Document from './Document';\nimport DocumentFragment from './DocumentFragment';\nimport DocumentType from './DocumentType';\nimport DOMImplementation from './DOMImplementation';\nimport Element from './Element';\nimport ProcessingInstruction from './ProcessingInstruction';\nimport Range from './Range';\nimport Text from './Text';\nimport XMLDocument from './XMLDocument';\n\n/**\n * The document associated with the global object. Used when calling constructors directly.\n *\n * Do not mutate this instance. When possible, it is recommended to use `new slimdom.Document` to\n * create a new document, and then use the factory methods on that instance to create other nodes.\n *\n * @public\n */\nexport const document = new Document();\ndefaultContext.document = document;\n\ndefaultContext.Attr = Attr;\ndefaultContext.CDATASection = CDATASection;\ndefaultContext.Comment = Comment;\ndefaultContext.Document = Document;\ndefaultContext.DocumentFragment = DocumentFragment;\ndefaultContext.DocumentType = DocumentType;\ndefaultContext.DOMImplementation = DOMImplementation;\ndefaultContext.Element = Element;\ndefaultContext.ProcessingInstruction = ProcessingInstruction;\ndefaultContext.Range = Range;\ndefaultContext.Text = Text;\ndefaultContext.XMLDocument = XMLDocument;\n","import Document from '../Document';\nimport { parseXmlDocument } from './parsingAlgorithms';\n\n/**\n * Interface DOMParser\n *\n * @public\n */\nexport default class DOMParser {\n\t/**\n\t * Constructs a new DOMParser object.\n\t */\n\tpublic constructor() {}\n\n\t/**\n\t * Parse str using a parser that matches type's supported MIME types (either XML or HTML), and\n\t * return a Document object containing the parsed content if successful. If not successful,\n\t * returns a Document describing the error.\n\t *\n\t * @param str  - The string to parse\n\t * @param type - The mime type to parse the string as\n\t *\n\t * @returns  Either the document resulting from successfully parsing str, or a document\n\t *           describing the error.\n\t */\n\tpublic parseFromString(str: string, type: string): Document {\n\t\tswitch (type) {\n\t\t\tcase 'text/html':\n\t\t\t\t// Parse str with an HTML parser, and return the newly created Document.\n\t\t\t\t// The scripting flag must be set to \"disabled\".\n\t\t\t\t// NOTE: meta elements are not taken into account for the encoding used, as a\n\t\t\t\t// Unicode stream is passed into the parser.\n\t\t\t\t// NOTE: script elements get marked unexecutable and the contents of noscript get\n\t\t\t\t// parsed as markup.\n\t\t\t\tthrow new Error('HTML parsing is not implemented');\n\n\t\t\tcase 'text/xml':\n\t\t\tcase 'application/xml':\n\t\t\tcase 'application/xhtml+xml':\n\t\t\tcase 'image/svg+xml':\n\t\t\t\ttry {\n\t\t\t\t\t// 1. Parse str with a namespace-enabled XML parser.\n\t\t\t\t\t// NOTE: For all XHTML script elements parsed using the XML parser, the\n\t\t\t\t\t// equivalent of the scripting flag must be set to \"disabled\".\n\t\t\t\t\tconst doc = parseXmlDocument(str);\n\n\t\t\t\t\t// 2. If the previous step didn't return an error, return the newly created\n\t\t\t\t\t// Document.\n\t\t\t\t\treturn doc;\n\t\t\t\t} catch (error: unknown) {\n\t\t\t\t\t// 3. Let document be a newly-created XML Document. The document will use the\n\t\t\t\t\t// Document interface rather than the XMLDocument interface.\n\t\t\t\t\tconst document = new Document();\n\n\t\t\t\t\t// 4. Let root be a new Element, with its local name set to \"parsererror\" and\n\t\t\t\t\t// its namespace set to \"http://www.mozilla.org/newlayout/xml/parsererror.xml\".\n\t\t\t\t\tconst root = document.createElementNS(\n\t\t\t\t\t\t'http://www.mozilla.org/newlayout/xml/parsererror.xml',\n\t\t\t\t\t\t'parsererror'\n\t\t\t\t\t);\n\n\t\t\t\t\t// At this point user agents may append nodes to root, for example to describe\n\t\t\t\t\t// the nature of the error.\n\t\t\t\t\troot.appendChild(document.createTextNode(`${error}`));\n\n\t\t\t\t\t// 5. Append root to document.\n\t\t\t\t\tdocument.appendChild(root);\n\n\t\t\t\t\t// 6. Return the value of document.\n\t\t\t\t\treturn document;\n\t\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`The type \"${type}\" is not a valid value in the SupportedType enumeration.`\n\t\t\t\t);\n\t\t}\n\t}\n}\n","import MutationRecord from './MutationRecord';\nimport NotifySet from './NotifyList';\nimport RegisteredObserver from './RegisteredObserver';\nimport Node from '../Node';\nimport { expectArity } from '../util/errorHelpers';\nimport { asObject } from '../util/typeHelpers';\n\n/**\n * @public\n */\nexport interface MutationObserverInit {\n\t/**\n\t * Whether to observe childList mutations.\n\t */\n\tchildList?: boolean;\n\n\t/**\n\t * Whether to observe attribute mutations.\n\t */\n\tattributes?: boolean;\n\n\t/**\n\t * Whether to observe character data mutations.\n\t */\n\tcharacterData?: boolean;\n\n\t/**\n\t * Whether to observe mutations on any descendant in addition to those on the target.\n\t */\n\tsubtree?: boolean;\n\n\t/**\n\t * Whether to record the previous value of attributes.\n\t */\n\tattributeOldValue?: boolean;\n\n\t/**\n\t * Whether to record the previous value of character data nodes.\n\t */\n\tcharacterDataOldValue?: boolean;\n}\n\nexport type MutationCallback = (records: MutationRecord[], observer: MutationObserver) => void;\n\n/**\n * 3.3.1. Interface MutationObserver\n *\n * A MutationObserver object can be used to observe mutations to the tree of nodes.\n *\n * @public\n */\nexport default class MutationObserver {\n\t/**\n\t * The function that will be called when control returns to the event loop, if there are any\n\t * queued records. The function is passed the MutationRecords and the observer instance that\n\t * collected them.\n\t */\n\tpublic _callback: MutationCallback;\n\n\t/**\n\t * The list of nodes on which this observer is a RegisteredObserver's observer.\n\t */\n\tpublic _nodes: Node[] = [];\n\n\t/**\n\t * The list of MutationRecord objects collected so far.\n\t */\n\tpublic _recordQueue: MutationRecord[] = [];\n\n\t/**\n\t * Tracks transient registered observers created for this observer, to simplify their removal.\n\t */\n\tpublic _transients: RegisteredObserver[] = [];\n\n\t/**\n\t * Constructs a MutationObserver object and sets its callback to callback. The callback is\n\t * invoked with a list of MutationRecord objects as first argument and the constructed\n\t * MutationObserver object as second argument. It is invoked after nodes registered with the\n\t * observe() method, are mutated.\n\t *\n\t * @param callback - Function called after mutations have been observed.\n\t */\n\tconstructor(callback: MutationCallback) {\n\t\texpectArity(arguments, 1);\n\t\tcallback = asObject(callback, Function);\n\n\t\t// 1. Let mo be a new MutationObserver object whose callback is callback.\n\t\tthis._callback = callback;\n\n\t\t// 2. Append mo to mo's relevant agent's mutation observers.\n\t\t// (for efficiency, this implementation only tracks MutationObserver objects that have\n\t\t// records queued)\n\n\t\t// 3. Return mo.\n\t}\n\n\t/**\n\t * Instructs the user agent to observe a given target (a node) and report any mutations based on\n\t * the criteria given by options (an object).\n\t *\n\t * NOTE: Adding an observer to an element is just like addEventListener, if you observe the\n\t * element multiple times it does not make a difference. Meaning if you observe element twice,\n\t * the observe callback does not fire twice, nor will you have to run disconnect() twice. In\n\t * other words, once an element is observed, observing it again with the same will do nothing.\n\t * However if the callback object is different it will of course add another observer to it.\n\t *\n\t * @param target  - Node (or root of subtree) to observe\n\t * @param options - Determines which types of mutations to observe\n\t */\n\tobserve(target: Node, options: MutationObserverInit) {\n\t\texpectArity(arguments, 2);\n\t\ttarget = asObject(target, Node);\n\n\t\t// Defaults from IDL\n\t\toptions.childList = !!options.childList;\n\t\toptions.subtree = !!options.subtree;\n\n\t\t// 1. If either options[\"attributeOldValue\"] or options[\"attributeFilter\"] exists, and\n\t\t// options[\"attributes\"] does not exist, then set options[\"attributes\"] to true.\n\t\tif (options.attributeOldValue !== undefined && options.attributes === undefined) {\n\t\t\toptions.attributes = true;\n\t\t}\n\n\t\t// 2. If options[\"characterDataOldValue\"] exists and options[\"characterData\"] does not\n\t\t// exist, then set options[\"characterData\"] to true.\n\t\tif (options.characterDataOldValue !== undefined && options.characterData === undefined) {\n\t\t\toptions.characterData = true;\n\t\t}\n\t\t// 3. If none of options[\"childList\"], options[\"attributes\"], and options[\"characterData\"]\n\t\t// is true, then throw a TypeError.\n\t\tif (!(options.childList || options.attributes || options.characterData)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t'The options object must set at least one of \"attributes\", \"characterData\", or ' +\n\t\t\t\t\t'\"childList\" to true.'\n\t\t\t);\n\t\t}\n\n\t\t// 4. If options[\"attributeOldValue\"] is true and options[\"attributes\"] is false, then throw\n\t\t// a TypeError.\n\t\tif (options.attributeOldValue && !options.attributes) {\n\t\t\tthrow new TypeError(\n\t\t\t\t'The options object may only set \"attributeOldValue\" to true when \"attributes\" ' +\n\t\t\t\t\t'is true or not present.'\n\t\t\t);\n\t\t}\n\n\t\t// 5. If options[\"attributeFilter\"] exists and options[\"attributes\"] is false, then throw a\n\t\t// TypeError. (attributeFilter not yet implemented)\n\n\t\t// 6. If options[\"characterDataOldValue\"] is true and options[\"characterData\"] is false,\n\t\t// then throw a TypeError.\n\t\tif (options.characterDataOldValue && !options.characterData) {\n\t\t\tthrow new TypeError(\n\t\t\t\t'The options object may only set \"characterDataOldValue\" to true when ' +\n\t\t\t\t\t'\"characterData\" is true or not present.'\n\t\t\t);\n\t\t}\n\n\t\t// 7. For each registered registered of target’s registered observer list, if registered's\n\t\t// observer is this:\n\t\t// 7.1. For each node of this's node list, remove all transient registered\n\t\t// observers whose source is registered from node's registered observer list.\n\t\t// 7.2. Set registered’s options to options.\n\t\t// 8. Otherwise:\n\t\t// 8.1. Append a new registered observer whose observer is this and options is\n\t\t// options to target's registered observer list.\n\t\t// 8.2. Append target to this's node list.\n\t\ttarget._registeredObservers.register(this, options);\n\t}\n\n\t/**\n\t * Stops the MutationObserver instance from receiving notifications of DOM mutations. Until the\n\t * observe() method is used again, observer's callback will not be invoked.\n\t */\n\tdisconnect() {\n\t\t// 1. For each node of this’s node list, remove any registered observer from\n\t\t// node's registered observer list for which this is the observer.\n\t\tthis._nodes.forEach((node) => node._registeredObservers.removeForObserver(this));\n\t\tthis._nodes.length = 0;\n\n\t\t// 2. Empty this’s record queue.\n\t\tthis._recordQueue.length = 0;\n\t}\n\n\t/**\n\t * Empties the MutationObserver instance's record queue and returns what was in there.\n\t *\n\t * @returns An Array of MutationRecord objects that were recorded.\n\t */\n\ttakeRecords(): MutationRecord[] {\n\t\t// 1. Let records be a clone of this's record queue.\n\t\tconst records = this._recordQueue.concat();\n\t\t// 2. Empty this's record queue\n\t\tthis._recordQueue.length = 0;\n\t\t// 3. Return records\n\t\treturn records;\n\t}\n}\n","import Node from '../Node';\nimport { asObject } from '../util/typeHelpers';\nimport { produceXmlSerialization } from './serializationAlgorithms';\n\n/**\n * 2.2 The XMLSerializer interface\n *\n * @public\n */\nexport default class XMLSerializer {\n\t/**\n\t * Constructs a new XMLSerializer object.\n\t */\n\tpublic constructor() {}\n\n\t/**\n\t * Serializes root into a string using an XML serialization. Throws a TypeError exception if\n\t * root is not a Node.\n\t *\n\t * @param root - The node to serialize\n\t *\n\t * @returns The XML resulting from serialization\n\t */\n\tpublic serializeToString(root: Node): string {\n\t\troot = asObject(root, Node);\n\n\t\t// Produce an XML serialization of root passing a value of false for the require well-formed\n\t\t// parameter, and return the result.\n\t\tconst result: string[] = [];\n\t\tproduceXmlSerialization(root, false, result);\n\t\treturn result.join('');\n\t}\n}\n\n/**\n * Serializes root into a string using an XML serialization. Throws if the result would not be\n * well-formed XML.\n *\n * Non-standard: the dom-parsing spec does not provide a way to serialize arbitrary nodes while\n * enforcing well-formedness.\n *\n * @public\n *\n * @param root - The node to serialize\n *\n * @returns The XML resulting from serialization\n */\nexport function serializeToWellFormedString(root: Node): string {\n\troot = asObject(root, Node);\n\n\t// Produce an XML serialization of root passing a value of true for the require well-formed\n\t// parameter, and return the result.\n\tconst result: string[] = [];\n\tproduceXmlSerialization(root, true, result);\n\treturn result.join('');\n}\n"],"names":["RegisteredObserver","constructor","observer","node","options","source","this","_transients","push","collectInterestedObservers","type","target","data","interestedObservers","pairedStrings","subtree","attributes","characterData","childList","index","indexOf","length","undefined","attributeOldValue","characterDataOldValue","oldValue","RegisteredObservers","_registeredObservers","_node","register","registeredObservers","hasRegisteredObserverForObserver","forEach","registered","i","transientRegisteredObserver","removeTransientRegisteredObserver","splice","removeTransientRegisteredObserversForSource","_nodes","removeForObserver","write","read","l","registeredObserver","appendTransientRegisteredObservers","registerTransient","queueMicrotaskWithAppropriateApi","callback","thisArg","args","queueMicrotask","Promise","resolve","then","apply","NotifySet","_notifySet","Set","_mutationObserverMicrotaskQueued","appendRecord","record","_recordQueue","add","queueMutationObserverMicrotask","_notifyMutationObservers","notifySet","Array","from","clear","mo","records","takeRecords","_callback","FakeWeakRef","_target","deref","defaultContext","_ranges","_weakRangeSet","WeakSet","forEachRange","cb","numRanges","r","isLost","isManuallyRemoved","has","pop","addRange","range","weakref","WeakRef","removeRange","delete","getContext","_instance","isNodeOfType","types","some","t","nodeType","isAttrNode","isCharacterDataNode","isTextNode","isElement","isDocumentType","determineLengthOfNode","childNodes","getInclusiveAncestors","ancestor","ancestors","unshift","parentNode","getNodeDocument","ownerDocument","getNodeIndex","getRootOfNode","forEachInclusiveDescendant","child","firstChild","nextSibling","getListOfElementsWithQualifiedName","qualifiedName","root","elements","element","nodeName","getListOfElementsWithNamespaceAndLocalName","namespace","localName","namespaceURI","cloneNode","cloneChildren","document","copy","_copy","appendChild","expectArity","minArity","TypeError","codeByName","IndexSizeError","HierarchyRequestError","WrongDocumentError","InvalidCharacterError","NotFoundError","NotSupportedError","InUseAttributeError","InvalidStateError","NamespaceError","InvalidNodeTypeError","DOMException","Error","message","name","super","code","stack","createDOMException","throwHierarchyRequestError","throwIndexSizeError","throwInvalidCharacterError","throwInvalidNodeTypeError","throwInvalidStateError","throwNamespaceError","throwNotFoundError","throwNotSupportedError","throwWrongDocumentError","MutationRecord","addedNodes","removedNodes","previousSibling","attributeName","attributeNamespace","queueMutationRecord","context","mappedOldValue","getChildren","firstElementChild","nextElementSibling","getPreviousElementSibling","sibling","getNextElementSibling","removeFromChildren","parent","previousElementSibling","lastChild","asParentNode","lastElementChild","childElementCount","parentDocument","documentElement","doctype","ensurePreInsertionValidity","contains","fragment","preInsertNode","referenceChild","adoptNode","insertNode","suppressObservers","isFragment","isDocumentFragment","nodes","count","n","removeNode","childIndex","startContainer","startOffset","endContainer","endOffset","siblingNonDocumentTypeChildNode","isDocument","insertIntoChildren","appendNode","replaceChildWithNode","replaceAllWithNode","oldPreviousSibling","oldNextSibling","inclusiveAncestor","oldDocument","inclusiveDescendant","attr","getDescendantTextContent","descendant","join","stringReplaceAll","newValue","Text","convertNodesIntoNode","actualNodes","map","nodeOrString","Node","createTextNode","String","createDocumentFragment","prependNodes","thisObject","appendNodes","replaceChildren","insertNodesBefore","viablePreviousSibling","insertNodesAfter","viableNextSibling","replaceWithNodes","removeFromParent","insertNodeIntoRange","referenceNode","splitText","newOffset","collapsed","setEnd","asUnsignedLong","number","legacyNullToEmptyString","value","ifNullActAsIfEmptyString","asObject","Constructor","expectObject","asNullableObject","asNullableString","orderKeyByNode","WeakMap","getOrderKey","orderKey","get","Math","random","set","parentElement","hasChildNodes","normalize","nextNode","textNode","siblingsToRemove","replaceData","currentNode","currentNodeIndex","shift","deep","compareDocumentPosition","other","arguments","node1","node2","attr1","attr2","ownerElement","DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC","DOCUMENT_POSITION_PRECEDING","DOCUMENT_POSITION_FOLLOWING","DOCUMENT_POSITION_DISCONNECTED","ancestors1","ancestors2","firstDistinctAncestorIndex","node1ContainsNode2","node2ContainsNode1","DOCUMENT_POSITION_CONTAINS","DOCUMENT_POSITION_CONTAINED_BY","isDefaultNamespace","lookupNamespaceURI","insertBefore","replaceChild","removeChild","preRemoveChild","handleAttributeChanges","attribute","changeAttribute","_value","appendAttribute","removeAttribute","attributeElement","ELEMENT_NODE","ATTRIBUTE_NODE","TEXT_NODE","CDATA_SECTION_NODE","ENTITY_REFERENCE_NODE","ENTITY_NODE","PROCESSING_INSTRUCTION_NODE","COMMENT_NODE","DOCUMENT_NODE","DOCUMENT_TYPE_NODE","DOCUMENT_FRAGMENT_NODE","NOTATION_NODE","prototype","Attr","nodeValue","setExistingAttributeValue","textContent","lookupPrefix","prefix","CharacterData","_data","before","after","replaceWith","remove","substringData","offset","appendData","insertData","deleteData","nodeData","newData","substring","newNode","indexOfNodePlusOne","wholeText","allData","CDATASection","Comment","DocumentType","_newValue","publicId","systemId","unsafeCreateAttribute","unsafeCreateElement","createElement","HTML_NAMESPACE","XML_NAMESPACE","XMLNS_NAMESPACE","validateQualifiedName","parts","split","every","part","matchesNameProduction","isValidQName","validateAndExtract","locateNamespacePrefix","find","EntityExpansionGuard","initialInputLength","entityExpansionThreshold","entityExpansionMaxAmplification","_topLevelEntityRef","_depth","_initialInputLength","_expandedInputLength","_entityExpansionThreshold","_entityExpansionMaxAmplification","enter","event","replacementTextLength","topLevelEntityRef","_a","throwErrorWithContext","exit","okWithValue","success","ok","error","expected","fatal","token","input","offsetAfter","slice","codepoint","isMatch","cp","codePointAt","lengthFromCodePoint","codepoints","firstCodePoint","lastCodePoint","fromCodePoint","parser","res","consume","filter","or","parsers","lastError","concat","optional","star","ts","nextOffset","starConsumed","parser1","parser2","r1","r2","sequence","values","sequenceConsumed","first","x","y","second","plusConsumed","preceded","followed","delimited","open","inner","close","cutAfterOpen","cut","recognize","peek","not","except","match","dispatch","mapping","otherwise","extraOffset","start","end","complete","ParserStateMachine","states","_state","_offset","_input","_states","next","done","withPosition","Object","assign","UNDERSCORE","DASH","PERIOD","DOUBLE_QUOTE","SINGLE_QUOTE","ANGLE_BRACKET_OPEN","ANGLE_BRACKET_CLOSE","AMPERSAND","EQUALS","SQUARE_BRACKET_OPEN","SQUARE_BRACKET_CLOSE","SEMICOLON","PERCENT","PARENTHESIS_OPEN","PARENTHESIS_CLOSE","PLUS","COMMA","QUESTION_MARK","ASTERISK","VERTICAL_BAR","SECT_END","COMMENT_START","COMMENT_END","PI_START","PI_END","ONE_POINT","VERSION","ENCODING","STANDALONE","YES","NO","XML_DECL_START","DOCTYPE_START","SYSTEM","PUBLIC","ETAG_START","EMPTY_ELEMENT_END","CHARREF_START","CHARREF_HEX_START","ELEMENT_DECL_START","EMPTY","ANY","PCDATA","ATTLIST_DECL_START","NOTATION","REQUIRED","IMPLIED","FIXED","ENTITY_DECL_START","NDATA","NOTATION_DECL_START","UPPER_ALPHA","LOWER_ALPHA","DIGIT","HEX_DIGIT","isValidChar","CompleteChars","isValidWhitespace","S","CompleteWhitespace","isValidNameStartChar","NameStartChar","isValidNameChar","Name","CompleteName","NCName","includes","Nmtoken","CharRef","parseInt","Reference","PEReference","AMPERSAND_CP","EntityValue","DOUBLE_QUOTE_CP","SINGLE_QUOTE_CP","AttValue","ANGLE_BRACKET_OPEN_CP","EntityReplacementTextInLiteral","SystemLiteral","isValidPubidChar","CompletePubidChars","PubidLiteral","CharData","PITarget","toLowerCase","PI","CDStart","CData","CDSect","Eq","VersionNum","VersionInfo","EncName","EncodingDecl","YesOrNo","SDDecl","XMLDecl","S$1","e","s","version","encoding","standalone","NameWithPosition","Attribute","STagOrEmptyElemTag","_","isEmpty","ETag","Multiplicity","choice","seq","children","Mixed","elementdecl","StringType","TokenizedType","EnumeratedType","AttType","DefaultDecl","v","fixed","AttDef","isCData","def","AttlistDecl","attdefs","ExternalID","EntityDef","ids","ndata","GEDecl","PEDef","PEDecl","EntityDecl","TextDecl","PublicID","NotationDecl","markupdecl","DeclSep","intSubset","vs","filterUndefined","doctypedecl","_1","_2","_3","content","parseContent","Misc","parseDocument","extParsedEnt","parseFragment","replaceInvalidCharacters","char","matchesCharProduction","truncate","side","max","chars","halfLength","min","line","offsetToCoords","inside","newlineIndexBefore","lastIndexOf","lineBefore","newlineIndexAfter","lineAfter","indent","c","isWhitespace","repeat","highlightError","throwParseError","what","quoted","str","actual","constructReplacementText","replacementText","Dtd","dtd","_attlistByName","Map","_entityReplacementTextByName","_externalEntityNames","_unparsedEntityNames","decl","defByName","isArray","getAttlist","nameEvent","getEntityReplacementText","allowExternal","predefinedEntitiesReplacementText","normalizeAndIncludeEntities","normalized","ancestorEntities","expansionGuard","replace","result","normalizeAttributeValue","attDef","splitQualifiedName","cache","fromCache","Namespaces","_byPrefix","_resolve","_parent","getForElement","ns","getForAttribute","static","attlist","qualifiedNameCache","hasDeclarations","checkAttr","ROOT_NAMESPACES","default","appendParsedNode","parseXml","generator","namespaces","into","treatCDataAsText","doc","domContext","entityRoot","collectedText","flushCollectedText","text","normalizeLineEndings","entityContext","entity","iterator","it","ctx","createCDATASection","createComment","implementation","createDocumentType","_b","createProcessingInstruction","fromAttrs","hasAttributeNS","parseXmlDocument","Document","NamespacePrefixMap","_nsByPrefix","_prefixCandidatesByNs","candidatesList","recordNamespaceInformation","namespaceUri","definedPrefix","_localPrefixToNamespace","_inheritedPrefixToNamespace","prefixToNamespace","shouldSerializeDeclaration","_getCandidatePrefix","allowDefault","candidates","candidate","getPreferredPrefix","prefixIndex","isAttr","inheritedNs","candidatePrefix","namespaceForPrefix","generatedPrefix","HTML_VOID_ELEMENTS","serializeFragment","requireWellFormed","withFictionalParent","produceXmlSerialization","prefixMap","new","runXmlSerializationAlgorithm","skipEndTag","serializeAttributeValue","localNameSet","declaredNamespaceUri","declaredPrefix","tuple","serializeAttributes","serializeElementNode","serializeDocumentNode","comment","endsWith","serializeCommentNode","cs","serializeCDATASectionNode","markup","serializeTextNode","serializeDocumentFragmentNode","dt","serializeDocumentTypeNode","pi","serializeProcessingInstructionNode","attributeValue","Element","tagName","getAttributeNodeNS","prepend","append","hasAttributes","getAttribute","getAttributeByName","getAttributeNS","getAttributeByNamespaceAndLocalName","setAttribute","setAttributeNS","validatedNamespace","setAttributeValue","removeAttributeByName","removeAttributeNS","removeAttributeByNamespaceAndLocalName","toggleAttribute","force","hasAttribute","getAttributeNode","setAttributeNode","setAttributeNodeNS","removeAttributeNode","getElementsByTagName","getElementsByTagNameNS","copyElement","copyAttribute","innerHTML","outerHTML","throwInUseAttributeError","oldAttr","newAttr","oldAttrElement","replaceAttribute","createElementNS","DOMImplementation","_document","createDocument","XMLDocument","createHTMLDocument","title","htmlElement","headElement","titleElement","documentFragment","DocumentFragment","cdataSection","ProcessingInstruction","importNode","createAttribute","createAttributeNS","createRange","Range","forEachNodeContainedInRange","firstChildOutside","extractRange","isClone","originalStartNode","originalStartOffset","originalEndNode","originalEndOffset","clone","startContainsEnd","endContainsStart","firstPartiallyContainedChild","lastPartiallyContainedChild","containedChildren","firstChildAfterStart","firstChildAfterEnd","subrange","setStart","subfragment","detach","containedChild","collapse","commonAncestorContainer","getRootOfRange","compareBoundaryPointPositions","POSITION_AFTER","POSITION_BEFORE","setStartBefore","setStartAfter","setEndBefore","setEndAfter","toStart","selectNode","selectNodeContents","compareBoundaryPoints","how","sourceRange","START_TO_START","START_TO_END","END_TO_END","END_TO_START","deleteContents","nodesToRemove","extractContents","cloneContents","surroundContents","newParent","cloneRange","isPointInRange","comparePoint","intersectsNode","toString","nodeA","offsetA","nodeB","offsetB","parseFromString","Function","observe","disconnect","init","serializeToString","resolveNamespacePrefix"],"mappings":"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"}