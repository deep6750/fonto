import getOperation from './api/getOperation.js';

function recurseSteps(res, operation, isGetStateSteps) {
	const prop =
		isGetStateSteps && operation.getStateSteps ? 'getStateSteps' : 'steps';

	if (!operation[prop]) {
		return;
	}

	operation[prop].forEach((step) => {
		if (!step.type) {
			res.debug('Unspecified step type');
			return;
		}

		const type = step.type.split('/');

		res.property(type[0], type[1] || '-', 20);

		if (!step.definition) {
			return;
		}

		res.indent();
		recurseSteps(res, step.definition, isGetStateSteps);
		res.outdent();
	});
}

function echoOperationSummary(_req, res, operationSummary) {
	res.properties({
		Name: operationSummary.operationName,
		File: operationSummary.operationFile,
		Label: operationSummary.label || '-',
		Description: operationSummary.description || '-',
		Keys:
			(operationSummary.keyBinding || '-') +
			(operationSummary.keyBindingDisabled ? ' (disabled)' : ''),
		Icon: operationSummary.icon || '-',
		Critical: operationSummary.errorsAreFatal ? 'Yes' : 'No',
	});

	if (operationSummary.initialData) {
		res.caption('Initial data');
		res.indent();
		res.debug(operationSummary.initialData);
		res.outdent();
	}

	if (operationSummary.getStateSteps) {
		res.caption('State steps');
		res.indent();
		recurseSteps(res, operationSummary, true);
		res.outdent();
	}

	if (operationSummary.steps) {
		res.caption('Steps');
		res.indent();
		recurseSteps(res, operationSummary, false);
		res.outdent();
	}

	if (operationSummary.alternatives) {
		res.caption('Alternatives');
		res.list(operationSummary.alternatives);
	}
}

export default function operationCommand(req, res) {
	res.caption(req.command.getLongName());

	let destroySpinner = res.spinner('Looking up operation...');

	return getOperation(
		req.fdt.editorRepository.path,
		req.parameters.operation,
		req.options.roots.length ? req.options.roots : null
	).then((operation) => {
		destroySpinner();
		destroySpinner = null;
		res.break();
		echoOperationSummary(req, res, operation);
	});
}
