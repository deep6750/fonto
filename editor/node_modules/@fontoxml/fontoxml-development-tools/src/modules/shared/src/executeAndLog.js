import cp from 'child_process';

/** @typedef {import('child_process').ChildProcess} ChildProcess */

/**
 * @callback ProcessCreatedCallback
 *
 * @param {ChildProcess} process
 *
 * @return {void}
 */

export const VERBOSITY_LEVEL = {
	SILENT: -1,
	NORMAL: 0,
	VERBOSE: 1,
	DEBUG: 2,
};

/**
 * @param {boolean} verbose
 * @param {boolean} debug
 *
 * @returns {number}
 */
export function getVerbosityLevel(verbose, debug) {
	if (debug) {
		return VERBOSITY_LEVEL.DEBUG;
	}
	if (verbose) {
		return VERBOSITY_LEVEL.VERBOSE;
	}
	return VERBOSITY_LEVEL.NORMAL;
}

/**
 * @param {FdtResponse}            res
 * @param {string}                 command
 * @param {string[]}               args
 * @param {string}                 currentWorkingDirectoryPath
 * @param {number}                 verbosityLevel
 * @param {boolean}                showStdout
 * @param {ProcessCreatedCallback} processCreatedCallback
 * @param {number[]}               [additionalSuccessExitCodes=[]]
 *
 * @returns {Promise<void>}
 */
function executeAndLog(
	res,
	command,
	args,
	currentWorkingDirectoryPath,
	verbosityLevel,
	showStdout,
	processCreatedCallback,
	additionalSuccessExitCodes = []
) {
	return new Promise((resolve, reject) => {
		const errors = [];
		const childProcess = cp.spawn(command, args, {
			cwd: currentWorkingDirectoryPath,
		});
		const silent = verbosityLevel === VERBOSITY_LEVEL.SILENT;
		const verbose =
			verbosityLevel === VERBOSITY_LEVEL.VERBOSE ||
			verbosityLevel === verbosityLevel.DEBUG;
		const debug = verbosityLevel === VERBOSITY_LEVEL.DEBUG;

		if (processCreatedCallback) {
			processCreatedCallback(process);
		}

		childProcess.stdout.on('data', (data) => {
			if (verbose || showStdout) {
				res.raw(data);
			}
		});

		childProcess.stderr.on('data', (data) => {
			if (debug) {
				res.raw(data);
			} else {
				errors.push(data.toString());
			}
		});

		childProcess.on('error', (error) => {
			res.error(error);
		});

		childProcess.on('close', (code) => {
			if (code === 0 || additionalSuccessExitCodes.includes(code)) {
				if (verbose) {
					res.debug(
						`${command} ${args.join(' ')} exited with code ${code}`
					);
				}
				resolve();
			} else {
				if (!debug && !silent) {
					errors.forEach((error) => res.log(error));
				}
				reject(
					new Error(
						`${command} ${args.join(' ')} exited with code ${code}`
					)
				);
			}
		});
	});
}

export default executeAndLog;
