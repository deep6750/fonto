import chalk from 'chalk';
import enquirer from 'enquirer';
import fs from 'fs-extra';
import path from 'path';

import Version from '../../../../Version.js';
import setFileVisibility from '../setFileVisibility.js';

/** @typedef {import('../addBackendDockerCommands').AddBackendDockerCommandsOptions} AddBackendDockerCommandsOptions */

/**
 * @param {AddBackendDockerCommandsOptions} options
 *
 * @returns {(req: FdtRequest, res: FdtResponse) => Promise<void>}
 */
export default function backendUpgradeCommandFactory(options) {
	return async function backendUpgradeCommand(req, res) {
		res.caption(req.command.getLongName());

		const version = req.options.version
			? new Version(req.options.version)
			: req.fdt.version.isNightly
			? new Version('nightly')
			: req.fdt.version;
		if (version.compare(req.fdt.version) !== 0) {
			req.fdt.ensureCompatibilityWithFdt(
				version,
				'upgrade',
				options.licenseProductName,
				options.productLabel
			);
		}

		// Warn/confirm when downgrading.
		const currentVersion = req.fdt.backendAppRepository.sdkVersion;
		if (
			!currentVersion.isUnversioned &&
			version.compare(currentVersion) <= -1
		) {
			if (req.options['non-interactive']) {
				res.notice(
					`WARNING: You are upgrading to a ${chalk.underline(
						'lower version'
					)} of ${
						options.productLabel
					} from version "${currentVersion.format()}" to "${version.format()}".`
				);
			} else if (
				!(await enquirer
					.prompt([
						{
							type: 'confirm',
							name: 'confirm',
							message: `You are about to upgrade to a ${chalk.underline(
								'lower version'
							)} of ${
								options.productLabel
							} from version "${currentVersion.format()}" to "${version.format()}", do you want to continue?`,
							initial: true,
							format: (value) => (value ? 'Yes' : 'No'),
						},
					])
					.then((answers) => !!answers.confirm)
					.catch((error) => {
						if (!error) { return false; } throw error;
					}))
			) {
				res.break();
				res.notice('Aborted');
				return;
			}
			res.break();
		}

		// Check if the given version exist.
		const sdkVersions = await req.fdt.license.getVersionsForProduct(
			options.licenseProductName
		);
		if (
			!sdkVersions.includes(
				version.isNightly ? new Version('nightly') : version
			)
		) {
			const latestStableVersion = sdkVersions.getLatestStableForVersion(
				req.fdt.version
			);
			throw new res.ErrorWithSolution(
				`Could not upgrade to version "${version.format()}". Please check if it is a valid version.`,
				`This version of FDT is designed to upgrade to version "${req.fdt.version.format()}", and is supports upgrading to versions "${
					req.fdt.version.isUnversioned
						? req.fdt.version.format()
						: `${req.fdt.version.format('minor')}.x`
				}"${
					latestStableVersion
						? ` of which the latest version is "${latestStableVersion.format()}"`
						: ''
				}.`
			);
		}

		const destroySpinner = res.spinner(
			`Upgrading your ${
				options.productLabel
			} version ${currentVersion.format()} instance to ${
				version.isNightly ? 'nightly' : version.format()
			}...`
		);

		try {
			const directoryPath = req.fdt.backendAppRepository.path;
			const manifestFilePath = path.join(
				directoryPath,
				req.fdt.backendAppRepository.manifestFilename
			);

			await setFileVisibility(manifestFilePath, true);

			// Update the manifest file.
			await fs.writeJson(manifestFilePath, {
				[req.fdt.backendAppRepository.manifestVersionPropertyName]:
					version.isNightly ? 'nightly' : version.format(),
			});

			await setFileVisibility(manifestFilePath, false);

			// Send telemetry.
			await req.fdt.license.sendTelemetry({
				product: req.command.parent.name,
				type: 'docker',
				version: version.isNightly ? 'nightly' : version.format(),
				currentVersion: currentVersion.format(),
				action: req.command.name,
			});

			destroySpinner();
		} catch (error) {
			res.notice(
				options.documentationExecuteError
					? `See our documentation at ${options.documentationExecuteError} for help.`
					: 'See our documentation for help.'
			);

			throw error;
		}
	};
}
