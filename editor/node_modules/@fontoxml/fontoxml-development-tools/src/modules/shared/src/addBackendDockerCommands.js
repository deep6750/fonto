import path from 'path';
import { pathToFileURL } from 'url';

import BackendAppRepository from '../../../BackendAppRepository.js';

/** @typedef {import('../../../ModuleRegistrationApi').default} ModuleRegistrationApi */
/** @typedef {import('../../../request/FdtCommand').default} FdtCommand */

/**
 * @typedef AddBackendDockerCommandsOptions
 *
 * @property {string}   productLabel
 * @property {string}   commandPrefix
 * @property {string}   [commandAlias]
 * @property {string}   licenseProductName
 *
 * @property {string}   [documentationConfigurationGuide]
 * @property {string}   [documentationExecuteError]
 * @property {string}   [documentationGettingStartedGuide]
 *
 * @property {string}   defaultHttpPort
 * @property {string}   [defaultHttpsPort]
 * @property {string}   defaultImageName
 * @property {string}   defaultImageTag
 *
 * @property {string}   manifestFileName
 * @property {string}   manifestVersionPropertyName
 *
 * @property {string}   instanceBuildDockerfilePath
 * @property {string}   instanceDevBuildDirectoryPath
 * @property {string}   instanceDevBuildDockerfilePath
 * @property {string}   instanceTemplateDirectoryPath
 *
 * @property {string}   temporaryBuildDirectoryName
 * @property {string}   temporaryDirectoryName
 * @property {string[]} requiredConfiguration
 * @property {string[]} whitelist
 *
 * @property {{[key: string]: string}} debugEnvEntries
 */

/**
 * @param {ModuleRegistrationApi}           moduleRegistration
 * @param {FdtCommand}                      command
 * @param {AddBackendDockerCommandsOptions} options
 *
 * @return {FdtCommand}
 */
function addBackendDockerBuildCommand(moduleRegistration, command, options) {
	const buildCommand = command.addCommand('build', async (...args) => {
		const controllerFactory = (
			await import(
				pathToFileURL(
					path.resolve(
						moduleRegistration.getPathToModule(
							'@fontoxml/fontoxml-development-tools-module-shared',
						),
						'src',
						'controller-templates',
						'command.backend.build.controller.factory.js',
					),
				)
			)
		).default;
		return controllerFactory(options)(...args);
	});

	buildCommand
		.setRequiresBackendAppRepository(options.licenseProductName)
		.setRequiresBackendAppVersionToMatchFdt(
			options.licenseProductName,
			false,
			options.productLabel
		)

		.setDescription(
			`Build a ${options.productLabel} Docker image for production use. Requires Docker to be installed.`
		)

		.addOption(
			'image-name',
			'n',
			`The name of the Docker image which will be created. This defaults to ${options.defaultImageName}.`,
			false
		)
		.addOption(
			'image-tag',
			't',
			`The tag of the Docker image which will be created. This defaults to ${options.defaultImageTag}.`,
			false
		)
		.addOption(
			'image-platform',
			'p',
			'The target platform of the Docker image. Either "linux/amd64" or "linux/arm64". Defaults to the closest match with the build host machine.',
			false
		)
		.addOption(
			'location',
			'l',
			'The directory where the instance is located. Defaults to the current working directory.',
			false
		)
		.addOption(
			'verbose',
			null,
			'Output default stdout and stderr information.'
		)
		.addOption('debug', null, 'Output all debug information.')

		.addExample(
			`${moduleRegistration.getAppInfo().name} ${
				options.commandPrefix
			} build`,
			`Build production image "${options.defaultImageName}:${options.defaultImageTag}" using the ${options.productLabel} instance located at the current working directory.`
		)
		.addExample(
			`${moduleRegistration.getAppInfo().name} ${
				options.commandPrefix
			} build --image-name my-instance --image-tag 1.0.0 --location /opt/my-instance/`,
			`Build production image "my-instance:1.0.0" using the ${options.productLabel} instance located at "/opt/my-instance/".`
		);

	return buildCommand;
}

/**
 * @param {ModuleRegistrationApi}           moduleRegistration
 * @param {FdtCommand}                      command
 * @param {AddBackendDockerCommandsOptions} options
 *
 * @return {FdtCommand}
 */
function addBackendDockerInitCommand(moduleRegistration, command, options) {
	const initCommand = command.addCommand('init', async (...args) => {
		const controllerFactory = (
			await import(
				pathToFileURL(
					path.resolve(
						moduleRegistration.getPathToModule(
							'@fontoxml/fontoxml-development-tools-module-shared',
						),
						'src',
						'controller-templates',
						'command.backend.init.controller.factory.js',
					),
				)
			)
		).default;
		return controllerFactory(options)(...args);
	});

	initCommand
		.setDescription(
			`Initialize a ${options.productLabel} instance in an empty or nonexistent directory.`
		)

		.addOption(
			'location',
			'l',
			'The directory where to initialize the instance. If not set this defaults to the current working directory. Note that the directory has to empty or nonexistent.',
			false
		)
		.addOption(
			'version',
			null,
			`The version of ${options.productLabel} to initialize, which defaults to the same version as FDT. Can be either a specific version within the same minor range of the current FDT version, or a "nightly" version. Be warned: nightly can be unstable or may not work at all.`
		)

		.addExample(
			`${moduleRegistration.getAppInfo().name} ${
				options.commandPrefix
			} init`,
			`Initialize a new ${options.productLabel} instance in the current working directory using the version matching the current FDT version.`
		)
		.addExample(
			`${moduleRegistration.getAppInfo().name} ${
				options.commandPrefix
			} init --location /opt/my-instance/`,
			`Initialize a new ${options.productLabel} instance located at "/opt/my-instance/" using the version matching the current FDT version.`
		);

	return initCommand;
}

/**
 * @param {ModuleRegistrationApi}           moduleRegistration
 * @param {FdtCommand}                      command
 * @param {AddBackendDockerCommandsOptions} options
 *
 * @return {Command}
 */
function addBackendDockerRunCommand(moduleRegistration, command, options) {
	const hasHttps = !!options.defaultHttpsPort;

	const runCommand = command.addCommand('run', async (...args) => {
		const controllerFactory = (
			await import(
				pathToFileURL(
					path.resolve(
						moduleRegistration.getPathToModule(
							'@fontoxml/fontoxml-development-tools-module-shared',
						),
						'src',
						'controller-templates',
						'command.backend.run.controller.factory.js',
					),
				)
			)
		).default;
		return controllerFactory(options)(...args);
	});

	runCommand
		.setRequiresBackendAppRepository(options.licenseProductName)
		.setRequiresBackendAppVersionToMatchFdt(
			options.licenseProductName,
			false,
			options.productLabel
		)

		.setDescription(
			`Run a ${options.productLabel} instance${
				hasHttps ? 'with a self-signed certificate' : ''
			} for development purposes. Requires Docker to be installed.`
		);

	if (hasHttps) {
		runCommand
			.addOption(
				'http-port',
				null,
				`Listen on the specified http port instead of listening on the default port (default=${options.defaultHttpPort}).`
			)
			.addOption(
				'https-port',
				null,
				`Listen on the specified https port instead of listening on the default port (default=${options.defaultHttpsPort}).`
			);
	} else {
		runCommand.addOption(
			'port',
			'p',
			`Listen on the specified http port instead of listening on the default port (default=${options.defaultHttpPort}).`
		);
	}

	runCommand
		.addOption(
			'location',
			'l',
			'The directory where the instance is located. Defaults to the current working directory.',
			false
		)
		.addOption(
			'config-location',
			'c',
			`The path where the configuration file (.env) is located.${
				options.documentationConfigurationGuide
					? ` Information about the .env file can be found at ${options.documentationConfigurationGuide}.`
					: ''
			}`,
			false
		)

		.addOption(
			'verbose',
			null,
			'Output default stdout and stderr information.'
		)
		.addOption(
			'debug',
			null,
			`Output all debug information. This also overrides the ${Object.keys(
				options.debugEnvEntries
			).join(', ')} environment options if set.`
		)

		.addExample(
			`${moduleRegistration.getAppInfo().name} ${
				options.commandPrefix
			} run`,
			`Build and run a development image using the ${options.productLabel} instance and configuration located at the current working directory.`
		)
		.addExample(
			`${moduleRegistration.getAppInfo().name} ${
				options.commandPrefix
			} run --location /opt/my-instances/specific-instance/ --config-location /opt/my-instances/.env`,
			`Build and run a development image using the ${options.productLabel} instance located at "/opt/my-instances/specific-instance/" using the configuration located at "/opt/my-instances/.env".`
		);

	if (hasHttps) {
		runCommand.addExample(
			`${moduleRegistration.getAppInfo().name} ${
				options.commandPrefix
			} run --http-port 8080 --https-port 8443`,
			`Build and run a development image using the ${options.productLabel} instance and configuration located at the current working directory on the non-default ports 8080 and 8443.`
		);
	} else {
		runCommand.addExample(
			`${moduleRegistration.getAppInfo().name} ${
				options.commandPrefix
			} run --port 7455`,
			`Build and run a development image using the ${options.productLabel} instance and configuration located at the current working directory on the non-default port 7455.`
		);
	}

	return runCommand;
}

/**
 * @param {ModuleRegistrationApi}           moduleRegistration
 * @param {FdtCommand}                      command
 * @param {AddBackendDockerCommandsOptions} options
 *
 * @return {FdtCommand}
 */
function addBackendDockerUpgradeCommand(moduleRegistration, command, options) {
	const upgradeCommand = command.addCommand('upgrade', async (...args) => {
		const controllerFactory = (
			await import(
				pathToFileURL(
					path.resolve(
						moduleRegistration.getPathToModule(
							'@fontoxml/fontoxml-development-tools-module-shared',
						),
						'src',
						'controller-templates',
						'command.backend.upgrade.controller.factory.js',
					),
				)
			)
		).default;
		return controllerFactory(options)(...args);
	});

	upgradeCommand
		.setRequiresBackendAppRepository(options.licenseProductName)
		.setRequiresBackendAppVersionToMatchFdt(
			options.licenseProductName,
			true,
			options.productLabel
		)

		.setDescription(
			`Upgrade an existing ${options.productLabel} instance to the specified version.`
		)

		.addOption(
			'location',
			'l',
			'The directory of the instance to upgrade. If not set this defaults to the current working directory.',
			false
		)

		.addOption(
			'non-interactive',
			undefined,
			'Use input from command line options only, and skip the interactive interface.'
		)

		.addOption(
			'version',
			null,
			`The version of ${options.productLabel} to upgrade to, which defaults to the same version as FDT. Can be either a specific version within the same minor range of the current FDT version, or a "nightly" version. Be warned: nightly can be unstable or may not work at all.`
		)

		.addExample(
			`${moduleRegistration.getAppInfo().name} ${
				options.commandPrefix
			} upgrade`,
			`Upgrade the ${options.productLabel} instance located in the current working directory using the version matching the current FDT version.`
		)
		.addExample(
			`${moduleRegistration.getAppInfo().name} ${
				options.commandPrefix
			} upgrade --location /opt/my-instance/`,
			`Upgrade the ${options.productLabel} instance located at "/opt/my-instance/" using the version matching the current FDT version.`
		);

	return upgradeCommand;
}

/**
 * @param {ModuleRegistrationApi}           moduleRegistration
 * @param {FdtCommand}                      command
 * @param {AddBackendDockerCommandsOptions} options
 */
export default function addBackendDockerCommands(
	moduleRegistration,
	command,
	options
) {
	const dockerCommands = [
		addBackendDockerBuildCommand(moduleRegistration, command, options),
		addBackendDockerInitCommand(moduleRegistration, command, options),
		addBackendDockerRunCommand(moduleRegistration, command, options),
		addBackendDockerUpgradeCommand(moduleRegistration, command, options),
	];

	BackendAppRepository.registerBackendApp(
		options.licenseProductName,
		options.manifestFileName,
		options.manifestVersionPropertyName,
		dockerCommands.reduce((acc, dockerCommand) => {
			acc.set(dockerCommand, (req) => {
				const hasLocationOption = dockerCommand.options.some(
					(option) => option.name === 'location'
				);
				const hasConfigLocationOption = dockerCommand.options.some(
					(option) => option.name === 'config-location'
				);
				return {
					location: hasLocationOption
						? req.options['location']
						: undefined,
					configLocation: hasConfigLocationOption
						? req.options['config-location']
						: undefined,
				};
			});
			return acc;
		}, new Map())
	);
}
