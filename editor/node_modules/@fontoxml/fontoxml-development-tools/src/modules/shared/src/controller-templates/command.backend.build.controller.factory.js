import fs from 'fs-extra';
import path from 'path';

import ensureDockerCommands from '../ensureDockerCommands.js';
import executeAndLog, {
	getVerbosityLevel,
	VERBOSITY_LEVEL,
} from '../executeAndLog.js';
import setFileVisibility from '../setFileVisibility.js';
import copyWhitelistedFiles from './docker/copyWhitelistedFiles.js';
import dockerCleanup from './docker/dockerCleanup.js';
import tryDockerLogout from './docker/tryDockerLogout.js';
import validateBackendInstance from './docker/validateBackendInstance.js';

/** @typedef {import('../addBackendDockerCommands').AddBackendDockerCommandsOptions} AddBackendDockerCommandsOptions */

/**
 * @param {AddBackendDockerCommandsOptions} options
 *
 * @returns {(req: FdtRequest, res: FdtResponse) => Promise<void>}
 */
export default function backendBuildCommandFactory(options) {
	return async function backendBuildCommand(req, res) {
		res.caption(req.command.getLongName());

		const directoryPath = req.fdt.backendAppRepository.path;
		const temporaryDirectoryPath = path.join(
			directoryPath,
			options.temporaryBuildDirectoryName
		);
		const imageName = req.options['image-name']
			? req.options['image-name']
			: options.defaultImageName;
		const imageTag = req.options['image-tag']
			? req.options['image-tag']
			: options.defaultImageTag;
		const fullImageName = `${imageName}:${imageTag}`;
		const imagePlatform = req.options['image-platform'];
		const verbosityLevel = getVerbosityLevel(
			req.options.verbose,
			req.options.debug
		);

		// Check if the working directory path exists and is a directory.
		try {
			const stats = await fs.stat(directoryPath);
			if (!stats.isDirectory()) {
				throw new res.InputError(
					'The provided location is not a directory.'
				);
			}
		} catch (error) {
			if (error.code === 'ENOENT') {
				throw new res.InputError(
					'The provided location does not exist.'
				);
			}
			throw error;
		}

		// Ensure that the Docker commands are available.
		await ensureDockerCommands(directoryPath, res, {
			checkDocker: true,
			checkDockerCompose: false,
		});

		res.properties({
			Location: directoryPath,
			'Image name': fullImageName,
			'Image platform': imagePlatform || '<default>',
			Verbose: req.options.verbose ? 'Yes' : 'No',
		});
		res.break();

		if (!imagePlatform) {
			res.notice(
				'The target platform of the Docker image defaults to the closest match with the build host machine. If an image is required for a specific target platform, specify it with the "--image-platform" option.'
			);
			res.break();
		}

		let pidToKillOnForceExit = null;
		const setPidToKillOnForceExit = (process) => {
			pidToKillOnForceExit = process && process.pid;
		};

		// Ensure we cleanup before exiting on SIGINT.
		let stopping = false;
		process.on('SIGINT', (_code) => {
			if (stopping) {
				if (pidToKillOnForceExit) {
					process.kill(pidToKillOnForceExit);
				}
				process.exit();
				return;
			}

			stopping = true;
			res.log('Gracefully stopping... (press Ctrl+C again to force)');
			// eslint-disable-next-line consistent-return
			return dockerCleanup(
				temporaryDirectoryPath,
				undefined,
				res,
				verbosityLevel
			).then(() => {
				process.exit();
			});
		});

		try {
			await validateBackendInstance(
				req.fdt.backendAppRepository,
				options
			);

			// Cleanup possible remaining resources from a previous build or run.
			await dockerCleanup(
				temporaryDirectoryPath,
				undefined,
				res,
				verbosityLevel
			);

			const version = req.fdt.backendAppRepository.sdkVersion;
			const destroySpinner = res.spinner(
				`Building the production image for ${options.productLabel} version ${
					version.isNightly ? 'nightly' : version.format()
				}...`
			);

			// Retrieve data for the docker image
			let dockerData;
			try {
				const requestObj = {
					[options.licenseProductName]: {
						docker: {
							version: version.format(),
						},
					},
				};
				const productData = await req.fdt.license.getDataForProducts(
					requestObj
				);
				dockerData =
					productData.products[options.licenseProductName].docker;
			} catch (error) {
				if (error.statusCode === 404) {
					error.solution = `This error might be caused by requesting a nonexistent ${options.productLabel} version, please check your version.`;
				}
				throw error;
			}

			// Create a hidden temporary directory.
			await fs.mkdir(temporaryDirectoryPath);
			await setFileVisibility(temporaryDirectoryPath, false);
			// Copy the instance files into the temporary directory.
			const dockerfileContent = await fs.readFile(
				options.instanceBuildDockerfilePath,
				'utf8'
			);
			// Rewrite the image in the Dockerfile.
			const fixedDockerfileContent = dockerfileContent.replace(
				'${image}',
				dockerData.image
			);
			await fs.writeFile(
				path.join(temporaryDirectoryPath, 'Dockerfile'),
				fixedDockerfileContent,
				'utf8'
			);
			const temporaryInstanceDirectoryPath = path.join(
				temporaryDirectoryPath,
				'instance'
			);
			await fs.ensureDir(temporaryInstanceDirectoryPath);
			// Copy whitelisted files.
			await copyWhitelistedFiles(
				options.whitelist,
				directoryPath,
				temporaryInstanceDirectoryPath
			);

			// Pull the docker image.
			try {
				await executeAndLog(
					res,
					'docker',
					[
						'login',
						dockerData.registry,
						'-u',
						dockerData.login,
						'-p',
						dockerData.password,
					],
					null,
					VERBOSITY_LEVEL.NORMAL,
					false,
					setPidToKillOnForceExit
				);
				await executeAndLog(
					res,
					'docker',
					[
						'pull',
						...(imagePlatform ? ['--platform', imagePlatform] : []),
						dockerData.image,
					],
					null,
					verbosityLevel,
					false,
					setPidToKillOnForceExit
				);
			} catch (error) {
				await tryDockerLogout(
					dockerData.registry,
					res,
					setPidToKillOnForceExit
				);
				throw new res.ErrorWithSolution(
					'Failed to retrieve the image file.',
					'Please check if the command line options are correct, or try to run with --verbose to see additional output.',
					error
				);
			}

			// Build the docker image.
			try {
				await executeAndLog(
					res,
					'docker',
					[
						'build',
						...(imagePlatform ? ['--platform', imagePlatform] : []),
						'-t',
						fullImageName,
						'.',
					],
					temporaryDirectoryPath,
					verbosityLevel,
					false,
					setPidToKillOnForceExit
				);
			} finally {
				await tryDockerLogout(
					dockerData.registry,
					res,
					setPidToKillOnForceExit
				);
			}

			// Send telemetry.
			await req.fdt.license.sendTelemetry({
				product: req.command.parent.name,
				type: 'docker',
				version: version.format(),
				action: req.command.name,
				platform: imagePlatform
			});

			destroySpinner();

			// Cleanup temporary directory.
			await dockerCleanup(
				temporaryDirectoryPath,
				undefined,
				res,
				verbosityLevel
			);
		} catch (error) {
			if (!stopping) {
				res.notice(
					options.documentationExecuteError
						? `See our documentation at ${options.documentationExecuteError} for help.`
						: 'See our documentation for help.'
				);
			}

			try {
				await dockerCleanup(
					temporaryDirectoryPath,
					undefined,
					res,
					verbosityLevel
				);
			} catch (_cleanupError) {
				// Ignore cleanup error.
			}

			// Re-throw the actual error.
			throw error;
		}
	};
}
