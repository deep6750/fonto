import enquirer from 'enquirer';
import fs from 'fs-extra';
import path from 'path';

import Version from '../../../../Version.js';
import setFileVisibility from '../setFileVisibility.js';
import checkInitDestination from './checkInitDestination.js';

/** @typedef {import('../addBackendDockerCommands').AddBackendDockerCommandsOptions} AddBackendDockerCommandsOptions */

/**
 * @param {AddBackendDockerCommandsOptions} options
 *
 * @returns {(req: FdtRequest, res: FdtResponse) => Promise<void>}
 */
export default function backendInitCommandFactory(options) {
	return async function backendInitCommand(req, res) {
		res.caption(req.command.getLongName());

		// Check if the version exists.
		const version = req.options.version
			? new Version(req.options.version)
			: req.fdt.version.isNightly
			? new Version('nightly')
			: req.fdt.version;
		if (version.compare(req.fdt.version) !== 0) {
			req.fdt.ensureCompatibilityWithFdt(
				version,
				'initialize',
				options.licenseProductName,
				options.productLabel
			);
		}
		const sdkVersions = await req.fdt.license.getVersionsForProduct(
			options.licenseProductName
		);
		if (
			!sdkVersions.includes(
				version.isNightly ? new Version('nightly') : version
			)
		) {
			const latestStableVersion = sdkVersions.getLatestStableForVersion(
				req.fdt.version
			);
			throw new res.ErrorWithSolution(
				`Could not initialize for version "${version.format()}". Please check if it is a valid version.`,
				`This version of FDT is designed to work with version "${req.fdt.version.format()}", and is compatible with versions "${
					req.fdt.version.isUnversioned
						? req.fdt.version.format()
						: `${req.fdt.version.format('minor')}.x`
				}"${
					latestStableVersion
						? ` of which the latest version is "${latestStableVersion.format()}"`
						: ''
				}.`
			);
		}

		const directoryPath = path.resolve(
			req.options.location ? req.options.location : process.cwd()
		);
		// Ensure the directory exists.
		await fs.ensureDir(directoryPath);
		// Check for any potential overwrite conflicts
		const existingFilesAndDirectories = await checkInitDestination(
			directoryPath,
			options.instanceTemplateDirectoryPath,
			res
		);
		if (existingFilesAndDirectories.length) {
			if (req.options['non-interactive']) {
				res.notice(
					`WARNING: You are initializing ${options.productLabel} in a non-empty directory.`
				);
				res.break();
			} else if (
				!(await enquirer
					.prompt([
						{
							type: 'confirm',
							name: 'confirm',
							message: `You are about to initialize ${options.productLabel} in a non-empty directory, do you want to continue?`,
							initial: true,
							format: (value) => (value ? 'Yes' : 'No'),
						},
					])
					.then((answers) => !!answers.confirm)
					.catch((error) => {
						if (!error) { return false; } throw error;
					}))
			) {
				res.break();
				res.notice('Aborted');
				return;
			}
		}

		const destroySpinner = res.spinner(
			`Initializing a ${options.productLabel} version ${
				version.isNightly ? 'nightly' : version.format()
			} instance at "${directoryPath}"...`
		);
		try {
			await fs.copy(
				options.instanceTemplateDirectoryPath,
				directoryPath,
				{
					filter: (src, _dest) => {
						const filename = path.basename(src);
						// If we add package.json and/or .gitignore files to backend templates,
						// add a check here to prevent overwrite of those files if they already exist.
						// Also output a message suggesting to add the required dependencies/gitignore manually.
						return filename !== '.gitkeep';
					},
				}
			);

			const data = {
				[options.manifestVersionPropertyName]: version.isNightly
					? 'nightly'
					: version.format(),
			};
			const manifestFilePath = path.join(
				directoryPath,
				options.manifestFileName
			);
			await fs.writeJson(manifestFilePath, data);
			await setFileVisibility(manifestFilePath, false);
		} catch (error) {
			destroySpinner();
			throw error;
		}

		await req.fdt.license.sendTelemetry({
			product: req.command.parent.name,
			type: 'docker',
			version: version.isNightly ? 'nightly' : version.format(),
			action: req.command.name,
		});

		destroySpinner();

		res.log(
			'Complete the configuration before building or running the instance.'
		);
		if (options.documentationGettingStartedGuide) {
			res.log(
				`See ${options.documentationGettingStartedGuide} for more information.`
			);
		}
	};
}
