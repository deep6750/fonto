import fs from 'fs-extra';
import path from 'path';
import { request } from 'undici';
import url from 'url';

import Version from '../../../../Version.js';

/** @typedef {import('../addBackendDownloadSelfContainedCommands').AddBackendDownloadSelfContainedCommandsOptions} AddBackendDownloadSelfContainedCommandsOptions */

/**
 * @param {AddBackendDownloadSelfContainedCommandsOptions} options
 *
 * @returns {(req: FdtRequest, res: FdtResponse) => Promise<void>}
 */
export default function backendDownloadSelfContainedCommandFactory(options) {
	return async function backendDownloadSelfContainedCommand(req, res) {
		res.caption(req.command.getLongName());

		const directoryPath = path.resolve(
			req.options.location ? req.options.location : process.cwd()
		);
		const version = req.options.version
			? new Version(req.options.version)
			: req.fdt.version.isNightly
			? new Version('nightly')
			: req.fdt.version;
		if (version.compare(req.fdt.version) !== 0) {
			req.fdt.ensureCompatibilityWithFdt(
				version,
				'download',
				options.licenseProductName,
				options.productLabel
			);
		}
		const runtime = req.options.runtime;

		const destroySpinner = res.spinner(
			`Downloading self-contained build of ${
				options.productLabel
			} version ${
				version.isNightly ? 'nightly' : version.format()
			} for runtime ${runtime}...`
		);

		// Get the download URI for the self-contained build.
		let downloadUri;
		try {
			const requestObj = {
				[options.licenseProductName]: {
					selfContained: {
						runtime,
						version: version.isNightly
							? 'nightly'
							: version.format(),
					},
				},
			};
			const productData = await req.fdt.license.getDataForProducts(
				requestObj
			);
			downloadUri =
				productData.products[options.licenseProductName].selfContained
					.uri;
		} catch (error) {
			if (error.statusCode === 404) {
				try {
					const sdkVersions = await req.fdt.license.getVersionsForProduct(
						options.licenseProductName,
					);
					const latestStableVersion = sdkVersions.getLatestStableForVersion(
						req.fdt.version,
					);
					const runtimes = await req.fdt.license.getRuntimesForProduct(
						options.licenseProductName,
					);
					const runtimesForVersion = runtimes.getForVersion(version);
					// eslint-disable-next-line no-ex-assign
					error = new res.ErrorWithSolution(
						`Could not download self-contained for version "${version.format()}" and runtime environment "${runtime}". Please check if it is a valid version and runtime environment.`,
						`This version of FDT is designed to work with version "${req.fdt.version.format()}", and is compatible with versions "${req.fdt.version.format(
							'minor'
						)}.x"${
							latestStableVersion
								? ` of which the latest version is "${latestStableVersion.format()}"`
								: ''
						}. ${
							runtimesForVersion?.length
								? `The available runtimes for version "${version.format()}" are: ${runtimesForVersion.join(
										', ',
								  )}.`
								: runtimesForVersion
								  ? `No runtimes found for version "${latestStableVersion.format()}".`
								  : 'Use a valid version to check if the runtime is available.'
						}`,
						error
					);
				} catch (_error) {
					throw new res.ErrorWithSolution(
						`Could not download self-contained for version "${version.format()}" and runtime environment "${runtime}". Please check if it is a valid version and runtime environment.`,
						`This version of FDT is designed to work with version "${req.fdt.version.format()}", and is compatible with versions "${
							req.fdt.version.isUnversioned
								? req.fdt.version.format()
								: `${req.fdt.version.format('minor')}.x`
						}". Run \`fdt ${
							options.commandPrefix
						} download-self-contained --help\` to get a list of all available runtime environments.`,
						error
					);
				}
			}
			throw error;
		}

		// Download the self-contained build.
		let response;
		try {
			response = await request(downloadUri, { method: 'GET' });
		} catch (error) {
			throw new res.ErrorWithInnerError(
				'Something went wrong while trying to download the self-contained build. Please rerun the command to try again.',
				error
			);
		}
		let data;
		switch (response.statusCode) {
			case 200:
				try {
					data = Buffer.from(await response.body.arrayBuffer());
				} catch (error) {
					throw new res.ErrorWithInnerError(
						`Invalid response data from the self-contained builds server.`,
						error
					);
				}
				break;
			case 401:
			case 403:
				throw new Error(
					'You are currently not allowed to download this self-contained build, even though you might have the license for it.'
				);
			case 404:
				throw new Error(
					'The file for the requested self-contained build could not be found.'
				);
			default:
				throw new Error(
					`Invalid response from the self-contained builds server (${response.statusCode}).`
				);
		}

		// Write the self-contained build to disk.
		const parsed = url.parse(downloadUri);
		const filename = path.basename(parsed.pathname);
		const filePath = path.join(directoryPath, filename);
		try {
			await fs.outputFile(filePath, data);
		} catch (error) {
			throw new res.ErrorWithInnerError(
				'Could not save self-contained build download to disk.',
				error
			);
		}

		await req.fdt.license.sendTelemetry({
			product: req.command.parent.name,
			type: 'selfContained',
			runtime: req.options.runtime,
			version: version.isNightly ? 'nightly' : version.format(),
			action: req.command.name,
		});

		destroySpinner();
		res.break();
		const locationString = req.options.location
			? path.isAbsolute(req.options.location)
				? filePath
				: path.join(req.options.location, filename)
			: filename;
		res.notice(`Saved self-contained build to ${locationString}`);
	};
}
