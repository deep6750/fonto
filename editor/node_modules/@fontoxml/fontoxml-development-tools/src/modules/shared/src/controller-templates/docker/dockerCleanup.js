import fs from 'fs-extra';
import path from 'path';

import executeAndLog, { VERBOSITY_LEVEL } from '../../executeAndLog.js';

/**
 * @param {string}      temporaryDirectoryPath
 * @param {string}      projectName
 * @param {FdtResponse} res
 * @param {number}      verbosityLevel
 *
 * @return {Promise<void>}
 */
async function actualCleanup(
	temporaryDirectoryPath,
	projectName,
	res,
	verbosityLevel
) {
	const temporaryDirectoryExists = await fs.exists(temporaryDirectoryPath);
	if (!temporaryDirectoryExists) {
		return;
	}

	const destroySpinner = res.spinner('Removing temporary resources...');

	try {
		const dockerComposeFileExists = await fs.exists(
			path.join(temporaryDirectoryPath, 'docker-compose.yml')
		);

		const errors = [];
		const tasks = [
			async () => {
				if (dockerComposeFileExists && projectName) {
					await executeAndLog(
						res,
						'docker',
						verbosityLevel === VERBOSITY_LEVEL.DEBUG
							? [
									'compose',
									'-p',
									projectName,
									'--verbose',
									'down',
									'--rmi',
									'local',
							  ]
							: [
									'compose',
									'-p',
									projectName,
									'down',
									'--rmi',
									'local',
							  ],
						temporaryDirectoryPath,
						verbosityLevel
					);
				}
			},
			async () => {
				await fs.remove(temporaryDirectoryPath);
			},
		];

		// Run all cleanup tasks in order. Continue on errors. But collect the errors.
		for (let i = 0; i < tasks.length; i++) {
			try {
				await tasks[i]();
			} catch (error) {
				errors.push(error);
			}
		}

		// Only throw if a task have failed.
		if (errors.length > 0) {
			throw errors[0];
		}
		// eslint-disable-next-line no-useless-catch
	} catch (error) {
		throw error;
	} finally {
		destroySpinner();
	}
}

const cleanupQueuePromises = new Set();

/**
 * @param {string}      temporaryDirectoryPath
 * @param {string}      projectName
 * @param {FdtResponse} res
 * @param {number}      verbosityLevel
 *
 * @return {Promise<void>}
 */
export default async function dockerCleanup(
	temporaryDirectoryPath,
	projectName,
	res,
	verbosityLevel
) {
	// Get the existing queue promises.
	const existingCleanupQueuePromises = [...cleanupQueuePromises];

	// Create a queue entry.
	let cleanupQueuePromiseResolve = null;
	let cleanupQueuePromiseReject = null;
	const cleanupQueuePromise = new Promise((resolve, reject) => {
		cleanupQueuePromiseResolve = resolve;
		cleanupQueuePromiseReject = reject;
	});
	cleanupQueuePromises.add(cleanupQueuePromise);

	// Wait for existing cleanup queue promises.
	await Promise.all(
		existingCleanupQueuePromises.map(
			async (existingCleanupQueuePromise) => {
				try {
					await existingCleanupQueuePromise;
				} catch (_error) {
					// Ignore other cleanup errors.
				}
			}
		)
	);

	// Call actual cleanup, resolving/rejecting the queue promise when done.
	await actualCleanup(
		temporaryDirectoryPath,
		projectName,
		res,
		verbosityLevel
	)
		.then((...args) => {
			cleanupQueuePromises.delete(cleanupQueuePromise);
			cleanupQueuePromiseResolve(...args);
		})
		.catch((error) => {
			cleanupQueuePromises.delete(cleanupQueuePromise);
			cleanupQueuePromiseReject(error);
		});

	return cleanupQueuePromise;
}
