/** @typedef {import('../addBackendDownloadSelfContainedCommands.js').AddBackendDownloadSelfContainedCommandsOptions} AddBackendDownloadSelfContainedCommandsOptions */

import Version from '../../../../Version.js';

/**
 * @param {AddBackendDownloadSelfContainedCommandsOptions} options
 *
 * @returns {(req: FdtRequest, res: FdtResponse) => Promise<void>}
 */
export default function backendRuntimesCommandFactory(options) {
	return async function backendRuntimesCommand(req, res) {
		res.caption(req.command.getLongName());

		const version = req.options.version
			? new Version(req.options.version)
			: req.fdt.version.isNightly
			  ? new Version('nightly')
			  : req.fdt.version;
		const destroySpinner = res.spinner(
			`Retrieving ${
				options.productLabel
			} runtimes for version ${version.format()}...`,
		);
		const runtimes = await req.fdt.license.getRuntimesForProduct(
			options.licenseProductName,
		);
		destroySpinner();

		const runtimesForVersion = runtimes.getForVersion(version);
		if (!runtimesForVersion) {
			throw new res.ErrorWithSolution(
				`Could not get runtimes for version "${version.format()}"`,
				'Use a valid version to get the runtimes for.',
			);
		}

		res.caption(
			`${options.productLabel} runtimes for version ${version.format()}`,
		);
		if (!runtimesForVersion?.length) {
			res.log('No runtimes available for this version.');
		} else {
			res.list(runtimesForVersion, '-');
		}
	};
}
