import fs from 'fs-extra';
import path from 'path';

import Version from '../../../Version.js';
import checkIfCompiledSchemaOverwritesFiles from './api/schema/checkIfCompiledSchemaOverwritesFiles.js';
import createSchemaPackages from './api/schema/createSchemaPackages.js';
import getSchemaFontoJson from './api/schema/getSchemaFontoJson.js';
import getVersionedSchemaCompilerBaseUrl from './api/schema/getVersionedSchemaCompilerBaseUrl.js';
import schemaCompile from './api/schema/compile.js';
import zipSchemaSource from './api/schema/zipSchemaSource.js';
import { promptConfirm } from './api/enquirerPrompts.js';

const SCHEMA_COMPILE_DOCUMENTATION_URL =
	'https://documentation.fontoxml.com/latest/create-a-schema-bundle-d186eeb79200';

/**
 * Helper function to test whether to use TypeScript conditionally.
 *
 * @param {boolean} isEditorRepositoryPath    Whether the command is run from an editor repo
 * @param {boolean} editorSupportsTypeScript  Whether the editor platform directory contains tsconfig.json
 * @param {boolean} hasSchemaLocationsJs      Whether there are existing SCHEMA_LOCATIONS.js files
 * @param {boolean} hasSchemaLocationsTs      Whether there are existing SCHEMA_LOCATIONS.ts files
 *
 * @return {boolean}
 */
export function shouldUseTypeScriptForSchemaPackages(
	isEditorRepositoryPath,
	editorSupportsTypeScript,
	hasSchemaLocationsJs,
	hasSchemaLocationsTs
) {
	// If editor supports TS or if not running in editor, default to TS unless there are existing JS files and no existing TS files
	// If editor does not support TS, default to JS
	return editorSupportsTypeScript || !isEditorRepositoryPath
		? !(hasSchemaLocationsJs && !hasSchemaLocationsTs)
		: false;
}

export default async function editorSchemaCompileCommand(req, res) {
	res.caption(req.command.getLongName());

	// Get source path and check it.
	let inputPath = path.resolve(req.parameters.input || process.cwd());
	if (inputPath[inputPath.length - 1] !== path.sep) {
		inputPath += path.sep;
	}

	const isEditorRepositoryPath = !!req.fdt.editorRepository.path;
	const outputPath = isEditorRepositoryPath
		? req.fdt.editorRepository.path + path.sep
		: inputPath;

	// TODO: Move this to above the options.version get/check code.
	if (isEditorRepositoryPath) {
		// Check if the output Editor Repository is compatible with the current FDT version.
		req.fdt.ensureCompatibilityWithFdt(
			req.fdt.editorRepository.sdkVersion,
			'instance',
			'editor'
		);
	}

	const sdkVersion = req.options.version
		? new Version(req.options.version)
		: req.fdt.version.isNightly
		? new Version('nightly')
		: req.fdt.version;
	if (sdkVersion.compare(req.fdt.version) !== 0) {
		req.fdt.ensureCompatibilityWithFdt(
			sdkVersion,
			'schema-compile',
			'editor'
		);
	}

	if (req.options['editor-path'] && !isEditorRepositoryPath) {
		throw new res.InputError(
			`The specified Editor path is not an Editor repository.`
		);
	}

	let baseUrl = req.options['base-url'];
	if (baseUrl) {
		res.notice(`Using schema compiler backend at "${baseUrl}".`);
	} else {
		res.notice(
			`Using schema compiler for version "${sdkVersion.format()}".`
		);
	}
	res.break();

	// Support path to fonto.json instead of directory path.
	if (path.basename(inputPath) === 'fonto.json') {
		inputPath = path.dirname(inputPath);
	}

	// Validate the schema source.
	let destroySpinner = res.spinner('Validating the schema source...');
	let fontoJson;
	try {
		fontoJson = await getSchemaFontoJson(inputPath);
	} catch (error) {
		res.error(error.message);
		res.break();
		res.notice('See the documentation for help with compiling a schema:');
		res.log(SCHEMA_COMPILE_DOCUMENTATION_URL);
		throw error;
	} finally {
		destroySpinner();
	}

	// Send the zipped schema to the compile endpoint.
	destroySpinner = res.spinner('Compiling the schema(s)...');
	const compressedSchema = await zipSchemaSource(inputPath, res);
	if (!baseUrl) {
		baseUrl = await getVersionedSchemaCompilerBaseUrl(
			req.fdt.license,
			sdkVersion
		);
	}
	const schemaCompileResult = await schemaCompile(
		baseUrl,
		compressedSchema,
		res
	);
	destroySpinner();

	// Output schema errors.
	if (schemaCompileResult.error) {
		res.caption('Schema compilation errors');
		res.error(schemaCompileResult.error.message);
		res.indent();
		if (schemaCompileResult.error.details) {
			res.list(schemaCompileResult.error.details, '-');
		}
		res.outdent();
		throw new Error('The schema(s) failed to compile.');
	}

	// Output schema warnings.
	const schemaLocationsWithWarnings = Object.keys(schemaCompileResult).filter(
		(xsdPath) => schemaCompileResult[xsdPath].warnings.length
	);
	if (schemaLocationsWithWarnings.length) {
		res.caption('Warning(s) while compiling the schema(s)');
		Object.keys(schemaCompileResult).forEach((xsdPath) => {
			res.notice(`Schema file '${xsdPath}' contains warnings.`);
			res.indent();
			res.list(schemaCompileResult[xsdPath].warnings, '-');
			res.outdent();
		});
		res.break();
	}

	// Prompt the user if the --overwrite option is not specified and files for a schema package
	// are about to be overwritten.
	const schemaPackagesWithExistingFiles =
		await checkIfCompiledSchemaOverwritesFiles(
			outputPath,
			fontoJson.rootSchemas,
			false
		);

	let hasSchemaLocationsJs = false;
	let hasSchemaLocationsTs = false;

	if (schemaPackagesWithExistingFiles.length) {
		for (const file of schemaPackagesWithExistingFiles) {
			if (path.basename(file) === 'SCHEMA_LOCATIONS.js') {
				hasSchemaLocationsJs = true;
			}
			if (path.basename(file) === 'SCHEMA_LOCATIONS.ts') {
				hasSchemaLocationsTs = true;
			}
		}

		res.caption('Existing files to be overwritten');
		res.log(
			`In${isEditorRepositoryPath ? ' editor' : ''} path "${outputPath}".`
		);
		res.indent();
		res.list(schemaPackagesWithExistingFiles, '-');
		res.outdent();
		res.break();

		if (req.options.overwrite) {
			res.notice(
				'Overwriting existing files due to --overwrite being set.'
			);
			res.break();
		} else {
			const overwriteConfirm = await promptConfirm(
				'Schema package(s) already exist, do you want to overwrite?',
			);

			if (!overwriteConfirm) {
				res.break();
				res.notice('Aborted.');
				return;
			}

			res.break();
			res.notice('Overwriting existing files.');
			res.break();
		}
	}

	const hasTsConfig = await fs.pathExists(
		path.join(outputPath, 'platform', 'tsconfig.json')
	);
	const platformHasTsConfig = isEditorRepositoryPath && hasTsConfig;
	const useTypeScript = shouldUseTypeScriptForSchemaPackages(
		isEditorRepositoryPath,
		platformHasTsConfig,
		hasSchemaLocationsJs,
		hasSchemaLocationsTs
	);

	// Create schema packages.
	destroySpinner = res.spinner(
		'Creating package(s) for the compiled schema(s)...'
	);
	try {
		await createSchemaPackages(
			outputPath,
			fontoJson.rootSchemas,
			schemaCompileResult,
			useTypeScript
		);
	} catch (error) {
		throw new res.ErrorWithInnerError(
			'Could not create package(s) for the compiled schema(s).',
			error
		);
	}

	await req.fdt.license.sendTelemetry({
		product: req.command.parent.parent.name,
		version: sdkVersion && sdkVersion.format(),
		action: `${req.command.parent.name} ${req.command.name}`,
	});

	destroySpinner();

	// Done.
	res.break();
	if (isEditorRepositoryPath) {
		res.log(
			`Saved the compiled schema(s) to the appropriate Fonto Editor package(s) in "${outputPath}".`
		);
		res.break();
		res.notice(
			'Please update "config/fonto-manifest.json" and "config/schemaExperienceResolver.js" accordingly, if needed.'
		);
	} else {
		res.log(
			`Saved the compiled schema(s) to "${path.join(
				outputPath,
				'packages'
			)}".`
		);
	}
	res.break();
	res.notice('Done.');
}
