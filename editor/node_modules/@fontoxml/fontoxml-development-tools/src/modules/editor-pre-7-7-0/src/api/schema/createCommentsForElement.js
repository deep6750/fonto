/**
 * Compare the items of multiple arrays for equality.
 *
 * @param {Array[]} arrays An array of arrays to compare to each other for equality.
 *
 * @return {boolean}
 */
export function compareArrays(arrays) {
	const firstArray = arrays[0];
	return (
		arrays.every((array) => array.length === firstArray.length) &&
		firstArray.every((item, index) =>
			arrays.every((array) => array[index] === item)
		)
	);
}

/**
 * Join strings and wrap lines when a new item does not fit in the line width.
 *
 * @param {string[]} items                        The strings to join and line wrap.
 * @param {number}   [lineWidth=93]               The maximum line width for wrapping, not that a single item will be kept on the same line.
 * @param {string}   [seperator=', ']             The string join seperator.
 * @param {string}   [indent='  ']                The line indentation.
 * @param {string}   [wrappedLinesExtraIndent=''] The extra indentation for the wrapped lines.
 *
 * @return {string[]|null}
 */
export function convertStringsToWrappedLines(
	items,
	lineWidth = 93,
	seperator = ', ',
	indent = '  ',
	wrappedLinesExtraIndent = ''
) {
	if (!items || !items.length) {
		return null;
	}

	const seperatorLength = seperator.length;
	const lines = [''];
	let currentLine = 0;

	for (let i = 0; i < items.length; i++) {
		const item = items[i];

		// Always have at least one item on the first line.
		if (i === 0) {
			lines[currentLine] += indent + item;
			continue;
		}

		if (
			lines[currentLine].length +
				seperatorLength +
				item.length +
				(i < items.length - 1 ? seperatorLength : 0) >
			lineWidth
		) {
			// Wrap to the next line if the item does not fit on the current line.
			lines[currentLine] += seperator;
			lines[++currentLine] = indent + wrappedLinesExtraIndent + item;
			continue;
		}

		lines[currentLine] += seperator + item;
	}

	return lines.map((line) => line.trimRight());
}

/**
 * Creates comment lines for an element containing some of the element's metadata.
 *
 * @param {ElementInformation} element              The element to create the comment lines for.
 * @param {Object}             prefixByNamespaceUri The namespace URIs with their prefix.
 *
 * @return {string[]}
 */
export default function createCommentsForElement(
	element,
	prefixByNamespaceUri
) {
	const comments = [];

	// Element localName, optionally with prefix.
	const elementTag = element.namespacePrefix
		? `<${element.namespacePrefix}:${element.localName}>`
		: `<${element.localName}>`;
	comments.push(elementTag);

	// Element namespace, if present.
	if (element.namespaceUri) {
		comments.push(`Namespace: ${element.namespaceUri}`);
	}

	// Only add metadata when it is not a namespace wildcard definition.
	if (element.localName !== '*') {
		//  Number of schema definitions, if more then one.
		const numberOfDefinitions = element.schemaDefinitionCount;
		if (numberOfDefinitions > 1) {
			comments.push(
				`- Defined ${element.schemaDefinitionCount} times in this namespace.`
			);
		}

		// Element content format variant.
		const emptyAndMixedDefinitions = element.elementSummaries.map(
			(elementSummary) => [
				elementSummary.isEmpty(),
				elementSummary.isMixed,
			]
		);
		const emptyAndMixedAreEqual = compareArrays(emptyAndMixedDefinitions);
		if (emptyAndMixedAreEqual) {
			const [isEmpty, isMixed] = emptyAndMixedDefinitions[0];
			comments.push(
				`- ${
					isMixed
						? isEmpty
							? 'Contains text.'
							: 'Contains text and elements.'
						: isEmpty
						? 'Contains nothing.'
						: 'Contains elements.'
				}`
			);
		} else {
			comments.push(
				`- The content formats are not the same accross all ${numberOfDefinitions} definitions.`
			);
		}

		// Parent elements.
		const parentElementLocalNames = element.elementSummaries.map(
			(elementSummary) =>
				elementSummary
					.getParentElements()
					.map((parentElementSummary) => {
						const namespaceUri =
							parentElementSummary.getNamespace();
						const namespacePrefix =
							prefixByNamespaceUri[namespaceUri];
						return namespacePrefix
							? `${namespacePrefix}:${parentElementSummary.localName}`
							: parentElementSummary.localName;
					})
		);
		const parentElementsAreEqual = compareArrays(parentElementLocalNames);
		comments.push('', 'Parent elements:');
		if (parentElementsAreEqual) {
			const lines = convertStringsToWrappedLines(
				parentElementLocalNames[0]
			);
			comments.push(
				...(lines ? lines : ['  This element has no parent elements.'])
			);
		} else {
			comments.push(
				`  The list of parent elements is not the same across all ${numberOfDefinitions} definitions.`
			);
		}

		// Child elements.
		const childElementLocalNames = element.elementSummaries.map(
			(elementSummary) =>
				elementSummary.getChildElements().map((childElement) => {
					const namespaceUri = childElement.getNamespace();
					const namespacePrefix = prefixByNamespaceUri[namespaceUri];
					return namespacePrefix
						? `${namespacePrefix}:${childElement.localName}`
						: childElement.localName;
				})
		);
		const childElementsAreEqual = compareArrays(childElementLocalNames);
		comments.push('', 'Child elements:');
		if (childElementsAreEqual) {
			const lines = convertStringsToWrappedLines(
				childElementLocalNames[0]
			);
			comments.push(
				...(lines ? lines : ['  This element has no child elements.'])
			);
		} else {
			comments.push(
				`  The list of child elements is not the same across all ${numberOfDefinitions} definitions.`
			);
		}

		// Developer instruction comment.
		const wrappedTodoComment = convertStringsToWrappedLines(
			`TODO ðŸ‘‰: Reconfigure the element ${elementTag} with the appropriate CVK family.`.split(
				' '
			),
			undefined,
			' ',
			'',
			'         '
		);
		comments.push('', ...wrappedTodoComment);
	}

	return comments;
}
