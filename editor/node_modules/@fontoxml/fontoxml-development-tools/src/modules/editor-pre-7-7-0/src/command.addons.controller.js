import fs from 'fs-extra';
import path from 'path';
import { unzip } from 'fflate';

import Version from '../../../Version.js';
import addonsAddDependencies from './api/addonsAddDependencies.js';
import createMessageTemplate from './api/createMessageTemplate.js';
import downloadEditorSDK from './api/downloadEditorSDK.js';
import getAddonsFromEditorSDK from './api/getAddonsFromEditorSDK.js';
import { promptEditorChangeAddonsFlow } from './api/enquirerPrompts.js';
import updateManifest from './api/updateManifest.js';
import updateConfigFontoManifest from './api/upgrade/updateConfigFontoManifest.js';
import validateAddons from './api/validateAddons.js';
import validateManifest from './api/validateManifest.js';

export default async function editorAddonsCommand(req, res) {
	if (req.options['remove-backup']) {
		// DEV-9386
		res.notice(
			'The --remove-backup option is deprecated. This version of FDT never makes backups.'
		);
	}

	res.caption(req.command.getLongName());

	const editorPath = req.fdt.editorRepository.path;
	const currentVersion = req.fdt.editorRepository.sdkVersion;

	if (
		req.fdt.editorRepository.sdkVersion &&
		req.fdt.editorRepository.sdkVersion.isPre7_8_2
	) {
		res.notice(
			`Changing add-ons is not supported for pre 7.8.2 editors, please upgrade your editor with version "${currentVersion.format()}" to at least 7.8.2 first.`
		);
		return;
	}

	const isNightly = req.fdt.editorRepository.sdkVersion.isNightly;
	if (isNightly) {
		res.notice(
			`Using nightly SDK version "${currentVersion.format()}". Added add-ons are from the latest nightly, which might cause conflicts.`
		);
	}

	// Checking Fonto Editor instance.
	let destroySpinner = res.spinner('Checking Fonto Editor...');
	const currentAddons = []
		.concat(
			req.fdt.editorRepository.addonNames || [],
			req.fdt.editorRepository.legacyAddonNames || []
		)
		.filter(
			(addonName, index, allAddons) =>
				allAddons.indexOf(addonName) === index
		);
	const manifestBuffer = await fs.readFile(
		path.join(req.fdt.editorRepository.path, 'manifest.json')
	);
	validateManifest(manifestBuffer, res);
	destroySpinner();

	// Download the Fonto Editor build matching the SDK version.
	destroySpinner = res.spinner(
		`Retrieving Fonto Editor SDK version ${
			currentVersion.isNightly ? 'nightly' : currentVersion.format()
		}...`
	);
	const downloadedSDK = await downloadEditorSDK(currentVersion, req, res);
	destroySpinner();

	// Determine add-ons.
	let addons = req.options['add-ons'].length
		? req.options['add-ons']
		: currentAddons.slice(0);
	if (req.options['add'].length) {
		addons = addons
			.concat(req.options['add'])
			.filter(
				(addonName, index, enabledAddons) =>
					enabledAddons.indexOf(addonName) === index
			);
	}
	if (req.options['remove'].length) {
		addons = addons.filter(
			(addonName) => !req.options['remove'].includes(addonName)
		);
	}

	// Extract and check the SDK manifest.
	destroySpinner = res.spinner('Analyzing the SDK contents...');

	let sdkAddons;
	let sdkFiles;
	let sdkManifest;

	try {
		sdkFiles = await new Promise((resolve, reject) => {
			unzip(downloadedSDK, (error, data) => {
				if (error) {
					reject(error);
					return;
				}
				resolve(data);
			});
		});

		sdkManifest = JSON.parse(Buffer.from(sdkFiles['manifest.json']));

		if (!sdkManifest || !sdkManifest.buildDate || !sdkManifest.version) {
			throw new Error();
		}

		sdkManifest.version = new Version(sdkManifest.version);

		sdkAddons = await getAddonsFromEditorSDK(sdkManifest);
		addonsAddDependencies(addons, sdkAddons);
	} catch (error) {
		throw new res.ErrorWithInnerError(
			'Something went wrong while analyzing the SDK contents.',
			error
		);
	} finally {
		destroySpinner();
	}

	// Prepare input data.
	const data = {
		addons,
	};

	// If the command is run interactively (default), prompt for input.
	if (!req.options['non-interactive']) {
		const options = {
			currentAddons,
			data,
			fdtLicense: req.fdt.license,
			sdkAddons,
			currentVersion,
		};
		const result = await promptEditorChangeAddonsFlow(options);
		if (result === false) {
			// outputDataAsCommandLineArguments(data, res);
			res.break();
			res.notice('Aborted.');
			return;
		}
	}

	// Validate input and upgrade the Fonto Editor, or on error, prompt the user for input, if not non-interactive.
	async function changeAddonsOrReviewInput() {
		destroySpinner = res.spinner('Validating the add-ons...');
		try {
			// Validate add-ons.
			validateAddons(data.addons, sdkAddons, req.fdt.license);
		} catch (error) {
			destroySpinner();

			if (req.options['non-interactive']) {
				throw error;
			}

			res.break();
			res.error(error.message);
			if (error.solution) {
				res.break();
				res.notice(error.solution);
			}
			res.break();

			// Prompt user for corrected input.
			const options = {
				currentAddons,
				currentVersion,
				data,
				fdtLicense: req.fdt.license,
				sdkAddons,
				skipAllSteps: true,
			};
			const promptResult = await promptEditorChangeAddonsFlow(options);

			// User opted to quit.
			if (promptResult === false) {
				return false;
			}

			return changeAddonsOrReviewInput();
		}

		destroySpinner();

		return true;
	}
	const changeAddonsEditorResult = await changeAddonsOrReviewInput();
	addons = data.addons;

	// If the editor upgrade creation failed, and the user opted to quit, do so.
	if (changeAddonsEditorResult === false) {
		// outputDataAsCommandLineArguments(data, res);
		res.break();
		res.notice('Aborted.');
		return;
	}

	const sdkMessagesFiles = [];

	// Decode and extract the zipped editor upgrade.
	destroySpinner = res.spinner(
		'Extracting and/or cleaning up the add-ons...'
	);
	try {
		const platformFolder = path.join(editorPath, 'platform');

		await fs.emptyDir(platformFolder);

		for (const filePath in sdkFiles) {
			const file = sdkFiles[filePath];
			const packageName = filePath.split('/')[0];

			if (filePath === 'manifest.json') {
				continue;
			}

			if (
				sdkAddons.find(
					(sdkAddon) => sdkAddon.package === packageName
				) &&
				!addons.includes(packageName)
			) {
				continue;
			}

			if (filePath === `${packageName}/messages.json`) {
				sdkMessagesFiles.push(JSON.parse(Buffer.from(file)));
				continue;
			}

			if (file.byteLength === 0 && /[/\\]$/.test(filePath)) {
				await fs.ensureDir(path.join(platformFolder, filePath));
			} else {
				await fs.writeFile(
					path.join(platformFolder, filePath),
					Buffer.from(file)
				);
			}
		}
	} catch (error) {
		throw new res.ErrorWithInnerError(
			'Could not extract and/or cleanup the add-ons.',
			error
		);
	} finally {
		destroySpinner();
	}

	// Create message template bundle.
	destroySpinner = res.spinner(
		'Updating the messages template file for localization...'
	);
	try {
		// Update the file.
		await createMessageTemplate(
			sdkMessagesFiles,
			path.join(editorPath, 'messages-template.json')
		);
	} catch (error) {
		throw new res.ErrorWithInnerError(
			'Could not update the messages-template.json file.',
			error
		);
	} finally {
		destroySpinner();
	}

	// Update manifest.json.
	destroySpinner = res.spinner('Updating the manifest file...');
	const manifestPath = path.join(editorPath, 'manifest.json');
	try {
		// Update the file.
		await updateManifest(manifestPath, sdkManifest, addons);
	} catch (error) {
		throw new res.ErrorWithInnerError(
			'Could not update the manifest.json file, please update "manifest.json" accordingly.',
			error
		);
	} finally {
		destroySpinner();
	}

	// Update config/fonto-manifest.json.
	destroySpinner = res.spinner('Updating the config manifest file...');
	const fontoManifestPath = path.join(
		editorPath,
		'config/fonto-manifest.json'
	);
	try {
		// Update the file.
		await updateConfigFontoManifest(fontoManifestPath, addons);
	} catch (error) {
		throw new res.ErrorWithInnerError(
			'Could not update the config/fonto-manifest.json file, please update "config/fonto-manifest.json" accordingly.',
			error
		);
	}

	await req.fdt.license.sendTelemetry({
		product: req.command.parent.name,
		type: 'selfContained',
		runtime: 'web',
		version: req.fdt.editorRepository.sdkVersion.format(),
		action: req.command.name,
		addons,
	});

	destroySpinner();

	// Done.
	res.break();
	res.notice('Done.');
}
