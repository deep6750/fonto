import SchemaSummary from '../../../../schema/src/api/SchemaSummary.js';

/**
 * Creates a schema experience package name based on a schema package name.
 *
 * @param {string} schemaPackageName          The schema package name on which to base the name.
 * @param {string} [sxIdentifier='sx-module'] The identifier for the package within the schema.
 *
 * @return {string}
 */
function createSchemaExperiencePackageName(
	schemaPackageName,
	sxIdentifier = 'sx-module'
) {
	const shellRegExp = /(^.*-|^|-)(sx-shell(?:s)?)(-.*)?$/i;
	return schemaPackageName.match(shellRegExp)
		? schemaPackageName.replace(shellRegExp, `$1${sxIdentifier}$3`)
		: `${schemaPackageName}-${sxIdentifier}`;
}

/**
 * @typedef {Object} ElementInformation
 *
 * @property {ElementSummary[]} elementSummaries
 * @property {string}           localName
 * @property {string|null}      namespacePrefix
 * @property {string|null}      namespaceUri
 * @property {number}           schemaDefinitionCount
 * @property {Set<string>}      schemaPackageNames
 */

/**
 * @typedef {Object} SxPackage
 *
 * @property {ElementInformation[]} elements
 * @property {string}               sxPackageName
 * @property {string[]}             schemaPackageNames
 */

/**
 * Builds a schema experience configuration model.
 *
 * @param {Object} schemaPackagesByXsdPath        The package information by xsd path.
 * @param {Object} compiledSchemaResultsByXsdPath The compiled schema for a package by xsd path.
 * @param {Object} prefixByNamespaceUri           The namespace URIs with their prefix.
 *
 * @return {SxPackage[]} The schema experience configuration model.
 */
export default function buildSchemaExperienceConfigurationModel(
	schemaPackagesByXsdPath,
	compiledSchemaResultsByXsdPath,
	prefixByNamespaceUri
) {
	const elementsWithEmptyPrefixBySchema = new Map();
	const elementsWithPrefixByPrefix = new Map();

	// Group all items by schema and/or prefix.
	Object.keys(schemaPackagesByXsdPath).forEach((xsdPath) => {
		const schemaPackageName = schemaPackagesByXsdPath[xsdPath].packageName;
		const schemaSummary = new SchemaSummary(
			compiledSchemaResultsByXsdPath[xsdPath].schema
		);

		schemaSummary.getAllElements().forEach((elementSummary) => {
			if (elementSummary.isAbstract) {
				// Do not include CVK configuration for abstract elements.
				// The Fonto Editor does not support having abstract elements in the content.
				return;
			}

			// Get the element's prefix based on the namespace.
			const elementNamespace = elementSummary.getNamespace() || null;
			const elementPrefix =
				prefixByNamespaceUri[elementNamespace] || null;

			// Either create or add the element to the null/default set for a schema, or to a set
			// specific for a namespace/prefix.
			let elementsForPrefix;
			if (!elementNamespace || elementPrefix === null) {
				if (!elementsWithEmptyPrefixBySchema.has(schemaPackageName)) {
					elementsWithEmptyPrefixBySchema.set(schemaPackageName, []);
				}
				elementsForPrefix =
					elementsWithEmptyPrefixBySchema.get(schemaPackageName);
			} else {
				if (!elementsWithPrefixByPrefix.has(elementPrefix)) {
					elementsWithPrefixByPrefix.set(elementPrefix, []);
				}
				elementsForPrefix =
					elementsWithPrefixByPrefix.get(elementPrefix);
			}

			// Create element configuration by prefix, deduplicating by elementName.
			let elementInformation = elementsForPrefix.find(
				(element) => element.localName === elementSummary.localName
			);
			if (!elementInformation) {
				// Map each element to a new object to have it decoupled from the input source.
				elementInformation = {
					elementSummaries: [],
					localName: elementSummary.localName,
					namespacePrefix: elementPrefix,
					namespaceUri: elementNamespace,
					schemaDefinitionCount: 0,
					schemaPackageNames: new Set(),
				};
				elementsForPrefix.push(elementInformation);
			}
			elementInformation.schemaDefinitionCount++;
			elementInformation.schemaPackageNames.add(schemaPackageName);
			elementInformation.elementSummaries.push(elementSummary);
		});
	});

	// Generate list of schema experience packages.
	const schemaExperiencePackages = [];
	for (const [
		schemaPackageName,
		elements,
	] of elementsWithEmptyPrefixBySchema) {
		const sxPackageName =
			createSchemaExperiencePackageName(schemaPackageName);
		schemaExperiencePackages.push({
			sxPackageName,
			schemaPackageNames: [schemaPackageName],
			elements,
		});
	}

	for (const [prefix, elements] of elementsWithPrefixByPrefix) {
		const formattedPrefix =
			prefix === null ? 'null' : prefix === '' ? 'default' : prefix;
		const sxPackageName = createSchemaExperiencePackageName(
			`namespace-${formattedPrefix}`
		);
		const schemaPackageNames = elements.reduce((acc, element) => {
			element.schemaPackageNames.forEach((schemaPackageName) =>
				acc.add(schemaPackageName)
			);
			return acc;
		}, new Set());

		schemaExperiencePackages.push({
			sxPackageName,
			schemaPackageNames: Array.from(schemaPackageNames),
			elements:
				prefix ===
				prefixByNamespaceUri['http://www.w3.org/1998/Math/MathML']
					? [
							{
								elementSummaries: [],
								localName: '*',
								namespacePrefix:
									prefixByNamespaceUri[
										'http://www.w3.org/1998/Math/MathML'
									],
								namespaceUri:
									'http://www.w3.org/1998/Math/MathML',
								schemaDefinitionCount: 1,
								schemaPackageNames: new Set(schemaPackageNames),
							},
					  ]
					: elements,
		});
	}

	return schemaExperiencePackages;
}
