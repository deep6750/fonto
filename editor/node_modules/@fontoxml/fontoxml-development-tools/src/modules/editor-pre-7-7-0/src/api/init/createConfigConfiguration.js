import babel from '@babel/core';
import os from 'os';

import SchemaSummary from '../../../../schema/src/api/SchemaSummary.js';
import addCommentToAstNode, {
	trickRecastIntoKeepingStatementsTogether,
} from '../addCommentToAstNode.js';
import createPrettifiedCode from '../createPrettifiedCode.js';
import writeAstProgramToFile from '../writeAstProgramToFile.js';

/** @typedef {import('../../../../../Version').default} Version */

const t = babel.types;
const template = babel.template;

const buildConfigurationManagerImport = template(
	`import configurationManager from 'fontoxml-configuration/src/configurationManager';`
);

const buildCorrectSelectionAfterEnterConfiguration = template(
	`configurationManager.set('enable-experiment/correct-selection-after-enter', true);`
);

const buildNamespaceManagerImport = template(
	`import namespaceManager from 'fontoxml-dom-namespaces/src/namespaceManager';`
);

const buildConfigurationSetUniqueIdConfigurations = template(
	`configurationManager.set('unique-id-configurations', CONFIGURATION_VALUE);`
);

const buildConfigurationSetUniqueIdConfigurationsObject = template.expression(
	`{ selector: xq\`self::*\`, namespaceURI: null, localName: 'id', strategy: 'unique-for-document' }`
);
const buildConfigurationSetUniqueIdConfigurationsObjectPre7170 =
	template.expression(
		`{ selector: 'self::*', namespaceURI: null, localName: 'id', strategy: 'unique-for-document' }`
	);

const buildXqImport = template(`import xq from 'fontoxml-selectors/src/xq';`);

const buildNamespaceManagerAddNamespace = template(
	'namespaceManager.addNamespace(PREFIX, NAMESPACE_URI);'
);

const buildParagraphNodeNameForPastingConfiguration = template(
	`configurationManager.set('paragraph-node-name-for-pasting', 'PARAGRAPH_NODE_NAME');`
);

// Configuration constants.
const PARAGRAPH_COUTERPART_ELEMENT_NAME = 'p';

/**
 * @param {Version} version
 *
 * @return {ASTNode}
 */
function buildConfigurationSetUniqueIdConfigurationStatement(version) {
	return buildConfigurationSetUniqueIdConfigurations({
		CONFIGURATION_VALUE: t.arrayExpression([
			version.isPre7_17_0
				? buildConfigurationSetUniqueIdConfigurationsObjectPre7170()
				: buildConfigurationSetUniqueIdConfigurationsObject(),
		]),
	});
}

/**
 * Adds the configuration for unique id configurations.
 *
 * @param {Object}    compiledSchemaResultsByXsdPath The compiled schema for a package by xsd path.
 * @param {ASTNode[]} statements                     The statements node array to add the configuration and/or comments to.
 * @param {Version}   version                        The sdk version used to configure.
 * @param {ASTNode}   lastStatement                  The statement to add the comment to in case no new statement is created.
 *
 * @return {Promise<void>}
 */
async function addUniqueIdGenerationConfigurations(
	compiledSchemaResultsByXsdPath,
	statements,
	version,
	lastStatement
) {
	// Check if an id attribute exists in one of the schemas.
	const idAttributeExists = Object.values(
		compiledSchemaResultsByXsdPath
	).some((schemaResults) => {
		const schemaSummary = new SchemaSummary(schemaResults.schema);
		return schemaSummary.getAllAttributes().some((attr) => {
			// Only allow an attribute named id in the null namespace.
			return attr.localName === 'id' && !attr.getNamespace();
		});
	});

	// Generate configuration code.
	const configurationSetUniqueIdConfigurationStatement =
		buildConfigurationSetUniqueIdConfigurationStatement(version);
	const comments = [
		'Set to an array of objects to determine the identifying attributes for which a GUID will be',
		'generated automatically.',
		'For more information:',
		'https://documentation.fontoxml.com/latest/unique-id-configurations-94fe53ca7bfb',
		'',
		'TODO ðŸ‘‰: If identifier attributes are missing, add them.',
		'TODO ðŸ‘‰: Adjust the selector to exclude elements where identifiers are not desired.',
	];

	if (idAttributeExists) {
		// Add the configuration statement with comment.
		addCommentToAstNode(
			configurationSetUniqueIdConfigurationStatement,
			comments
		);
		statements.push(configurationSetUniqueIdConfigurationStatement);
	} else {
		// Add as trailing comment to the last statement ASTNode with code example.
		const exampleCode = await createPrettifiedCode(
			configurationSetUniqueIdConfigurationStatement
		);
		addCommentToAstNode(
			lastStatement,
			[
				...comments,
				'Example:',
				...exampleCode.split(os.EOL).filter(Boolean),
			],
			true,
			true
		);
	}
}

/**
 * Generates the config/configuration.ts/js file for the Editor.
 *
 * @param {Object}  prefixByNamespaceUri           The namespace URIs with their prefix.
 * @param {Array}   addons                         The selected addons for this editor instance.
 * @param {Object}  compiledSchemaResultsByXsdPath The compiled schema for a package by xsd path.
 * @param {Version} version                        The sdk version used to configure.
 *
 * @return {Promise<Program>}
 */
export async function generateConfigConfiguration(
	prefixByNamespaceUri,
	addons,
	compiledSchemaResultsByXsdPath,
	version
) {
	const importStatements = [];
	const statements = [];

	// Add configuration manager import and code guidance.
	const configurationManagerImportStatement =
		buildConfigurationManagerImport();
	addCommentToAstNode(configurationManagerImportStatement, [
		'This configuration file defines constants that can be used throughout the rest of your FontoXML',
		'Editor configuration. You can configure existing product options, or create custom configuration',
		'options. Values that you set here may be either a value or an asynchronous promise to a value,',
		'and can be used in other files by importing the configurationManager and using',
		'configurationManager.get().',
		'For more information:',
		'https://documentation.fontoxml.com/latest/configurationmanager-3e0d8dbacb90',
	]);
	importStatements.push(configurationManagerImportStatement);

	// Get all prefix and namespace entries, sorted naturally by prefix.
	const prefixByNamespaceUriEntries = Object.entries(
		prefixByNamespaceUri
	).sort(([_nsA, prefixA], [_nsB, prefixB]) =>
		prefixA === prefixB
			? 0
			: prefixA === null
			? 1
			: prefixB === null
			? -1
			: prefixA.localeCompare(prefixB, undefined, {
					numeric: true,
					sensitivity: 'base',
			  })
	);
	let namespaceManagerImport;
	if (prefixByNamespaceUriEntries.length) {
		namespaceManagerImport = buildNamespaceManagerImport();
		importStatements.push(namespaceManagerImport);
	}

	// Import xq for editor versions 7.17 or higher.
	let xqImportStatement;
	if (!version.isPre7_17_0) {
		xqImportStatement = buildXqImport();
		importStatements.push(xqImportStatement);
	}

	// Set an experimental flag for editor versions 8.0.x or lower.
	if (version.isPre8_1_0) {
		const correctSelectionAfterEnterConfigurationStatement =
			buildCorrectSelectionAfterEnterConfiguration();
		// Enable the 'correct selection after enter' experiment.
		addCommentToAstNode(correctSelectionAfterEnterConfigurationStatement, [
			'Enable an experiment where, when pressing enter at the edges of elements, the cursor is prevented',
			'from ending up in positions that are not reachable using the cursor keys.',
			'For more information:',
			'https://documentation.fontoxml.com/latest/enable-experiment-correct-selection-after-enter-8d2ce78e26b8',
		]);
		statements.push(correctSelectionAfterEnterConfigurationStatement);
	}

	// Configures the clipboard configuration option 'paragraph-node-name-for-pasting'.
	// Skips this configuration when the 'fontoxml-dita' add-on is enabled, since that add-on already configures this option.
	if (!addons.includes('fontoxml-dita')) {
		const comments = [
			'The node name of the element that will be created for paragraphs in pasted plain-text content.',
			'The configuration value is the paragraph counterpart element name.',
			'Additional clipboard configuration can be found in the editor-clipboard-configuration package.',
			'For more information:',
			'https://documentation.fontoxml.com/latest/configure-clipboard-behavior-bc607964d3f5',
			'https://documentation.fontoxml.com/latest/paragraph-node-name-for-pasting-94d4327c8363',
			'',
			`TODO ðŸ‘‰: Verify that "${PARAGRAPH_COUTERPART_ELEMENT_NAME}" is a sensible default text container.`,
		];

		const paragraphNodeNameForPastingConfigurationStatement =
			buildParagraphNodeNameForPastingConfiguration({
				PARAGRAPH_NODE_NAME: t.stringLiteral(
					PARAGRAPH_COUTERPART_ELEMENT_NAME
				),
			});

		const paragraphElementExists = Object.values(
			compiledSchemaResultsByXsdPath
		).some((schemaResults) => {
			const schemaSummary = new SchemaSummary(schemaResults.schema);
			return schemaSummary
				.getAllElements()
				.some(
					(element) =>
						element.localName ===
							PARAGRAPH_COUTERPART_ELEMENT_NAME &&
						!element.getNamespace()
				);
		});

		if (paragraphElementExists) {
			addCommentToAstNode(
				paragraphNodeNameForPastingConfigurationStatement,
				comments
			);
			statements.push(paragraphNodeNameForPastingConfigurationStatement);
		} else {
			const exampleCode = await createPrettifiedCode(
				paragraphNodeNameForPastingConfigurationStatement
			);
			comments.push('Example:');
			comments.push(...exampleCode.split(os.EOL).filter(Boolean));
			addCommentToAstNode(
				statements[statements.length - 1] ||
					importStatements[importStatements.length - 1],
				comments,
				true,
				true
			);
		}
	}

	// Add unique id generation configuration.
	await addUniqueIdGenerationConfigurations(
		compiledSchemaResultsByXsdPath,
		statements,
		version,
		statements[statements.length - 1] ||
			importStatements[importStatements.length - 1]
	);

	// Register all namespaces.
	let namespaceConfigurationStatement;
	if (prefixByNamespaceUriEntries.length) {
		let isFirstAddedNamespaceStatement = true;
		for (const [namespaceUri, prefix] of prefixByNamespaceUriEntries) {
			namespaceConfigurationStatement = buildNamespaceManagerAddNamespace(
				{
					PREFIX:
						prefix === null
							? t.nullLiteral()
							: t.stringLiteral(prefix),
					NAMESPACE_URI: t.stringLiteral(namespaceUri),
				}
			);

			if (isFirstAddedNamespaceStatement) {
				isFirstAddedNamespaceStatement = false;
				addCommentToAstNode(namespaceConfigurationStatement, [
					'Register namespaces with prefixes.',
					'For more information:',
					'https://documentation.fontoxml.com/latest/namespacemanager-c80956c5d6d7',
					'https://documentation.fontoxml.com/latest/namespaces-2b1bbc7b4f79',
				]);
			}

			statements.push(namespaceConfigurationStatement);
		}
	}

	trickRecastIntoKeepingStatementsTogether(
		configurationManagerImportStatement
	);
	if (namespaceManagerImport) {
		trickRecastIntoKeepingStatementsTogether(namespaceManagerImport);
	}
	if (xqImportStatement) {
		trickRecastIntoKeepingStatementsTogether(xqImportStatement);
	}
	if (namespaceConfigurationStatement) {
		trickRecastIntoKeepingStatementsTogether(
			namespaceConfigurationStatement
		);
	}

	// Generate the AST for the config/configuration.ts/js file.
	return t.program([...importStatements, ...statements]);
}

/**
 * Creates the config/configuration.ts/js file for the Editor.
 *
 * @param {string}  configConfigurationJsFilePath  The path to the configuration file.
 * @param {Object}  prefixByNamespaceUri           The namespace URIs with their prefix.
 * @param {Array}   addons                         The selected addons for this editor instance.
 * @param {Object}  compiledSchemaResultsByXsdPath The compiled schema for a package by xsd path.
 * @param {Version} version                        The sdk version used to configure.
 *
 * @return {Promise<void>}
 */
export default async function createConfigConfiguration(
	configConfigurationJsFilePath,
	prefixByNamespaceUri,
	addons,
	compiledSchemaResultsByXsdPath,
	version
) {
	const configConfigurationJsAst = await generateConfigConfiguration(
		prefixByNamespaceUri,
		addons,
		compiledSchemaResultsByXsdPath,
		version
	);
	await writeAstProgramToFile(
		configConfigurationJsFilePath,
		configConfigurationJsAst
	);
}
