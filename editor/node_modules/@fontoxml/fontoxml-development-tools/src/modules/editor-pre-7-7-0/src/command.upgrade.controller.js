import chalk from 'chalk';
import fs from 'fs-extra';
import path from 'path';
import { unzip } from 'fflate';

import Version from '../../../Version.js';
import addonsAddDependencies from './api/addonsAddDependencies.js';
import convertEditorWithOutput from '../../editor/src/commands/api/convertEditorWithOutput.js';
import createMessageTemplate from './api/createMessageTemplate.js';
import downloadEditorSDK from './api/downloadEditorSDK.js';
import getAddonLabels from './api/getAddonLabels.js';
import getAddonsFromEditorSDK from './api/getAddonsFromEditorSDK.js';
import npmInstall from './api/npmInstall.js';
import preprocessData from './api/upgrade/preprocessData.js';
import updateConfigFontoManifest from './api/upgrade/updateConfigFontoManifest.js';
import updateManifest from './api/updateManifest.js';
import validateAddons from './api/validateAddons.js';
import validateManifest from './api/validateManifest.js';
import { promptConfirm, promptEditorUpgradeFlow } from './api/enquirerPrompts.js';

export default async function editorUpgradeCommand(req, res) {
	if (req.options['remove-backup']) {
		// DEV-9386
		res.notice(
			'The --remove-backup option is deprecated. This version of FDT never makes backups.'
		);
	}

	res.caption(req.command.getLongName());

	const editorPath = req.fdt.editorRepository.path;

	let sdkVersion = req.options.version
		? new Version(req.options.version)
		: req.fdt.version.isNightly
		  ? new Version('nightly')
		  : req.fdt.version;
	if (sdkVersion.compare(req.fdt.version) !== 0) {
		req.fdt.ensureCompatibilityWithFdt(sdkVersion, 'upgrade', 'editor');
	}

	// Warn/confirm when downgrading.
	const currentVersion = req.fdt.editorRepository.sdkVersion;
	if (
		!currentVersion.isUnversioned &&
		sdkVersion.compare(currentVersion) <= -1
	) {
		if (req.options['non-interactive']) {
			res.notice(
				`WARNING: You are upgrading to a ${chalk.underline(
					'lower version'
				)} of Fonto Editor from version "${currentVersion.format()}" to "${sdkVersion.format()}".`
			);
			res.break();
		} else if (
			!(await promptConfirm(
				`You are about to upgrade to a ${chalk.underline(
					'lower version',
				)} of Fonto Editor from version "${currentVersion.format()}" to "${sdkVersion.format()}", do you want to continue?`,
			))
		) {
			res.break();
			res.notice('Aborted');
			return;
		}
	}

	// Checking Fonto Editor instance.
	let destroySpinner = res.spinner('Checking the Fonto Editor instance...');
	const currentAddons = []
		.concat(
			req.fdt.editorRepository.addonNames || [],
			req.fdt.editorRepository.legacyAddonNames || []
		)
		.filter(
			(addonName, index, allAddons) =>
				allAddons.indexOf(addonName) === index
		);
	const manifestBuffer = await fs.readFile(
		path.join(req.fdt.editorRepository.path, 'manifest.json')
	);
	validateManifest(manifestBuffer, res);
	destroySpinner();

	// Download the Fonto Editor build matching the SDK version.
	destroySpinner = res.spinner(
		`Retrieving Fonto Editor SDK version ${
			sdkVersion.isNightly ? 'nightly' : sdkVersion.format()
		}...`
	);
	const downloadedSDK = await downloadEditorSDK(sdkVersion, req, res);
	destroySpinner();

	// Determine add-ons.
	const addons = currentAddons.slice();

	// Extract and check the SDK manifest.
	destroySpinner = res.spinner('Analyzing the SDK contents...');

	let sdkAddons;
	let sdkFiles;
	let sdkManifest;

	try {
		sdkFiles = await new Promise((resolve, reject) => {
			unzip(downloadedSDK, (error, data) => {
				if (error) {
					reject(error);
					return;
				}
				resolve(data);
			});
		});

		sdkManifest = JSON.parse(Buffer.from(sdkFiles['manifest.json']));

		if (!sdkManifest || !sdkManifest.buildDate || !sdkManifest.version) {
			throw new Error();
		}

		sdkManifest.version = new Version(sdkManifest.version);

		sdkAddons = await getAddonsFromEditorSDK(sdkManifest);
		addonsAddDependencies(addons, sdkAddons);
	} catch (error) {
		throw new res.ErrorWithInnerError(
			'Something went wrong while analyzing the SDK contents.',
			error
		);
	} finally {
		destroySpinner();
	}

	// Set the sdkVersion to the actual version, for nightlies it's sets to the specific nightly version string instead of 'nightly'.
	sdkVersion = sdkManifest.version;

	// Prepare input data.
	await preprocessData(
		{ addons, manifest: manifestBuffer },
		currentVersion,
		sdkVersion,
		res
	);

	// Output add-ons.
	res.caption('Add-ons');
	const addonLabels = getAddonLabels(addons, sdkAddons);
	if (addonLabels.length) {
		res.list(addonLabels.sort());
	} else {
		res.log('No add-ons.');
	}
	res.break();

	// If the command is run interactively (default), prompt for input.
	if (!req.options['non-interactive']) {
		const options = {
			currentVersion,
			sdkVersion,
		};
		const result = await promptEditorUpgradeFlow(options);
		if (result === false) {
			// outputDataAsCommandLineArguments(data, res);
			res.break();
			res.notice('Aborted.');
			return;
		}
	}

	// Validate input and upgrade the Fonto Editor, or on error, prompt the user for input, if not non-interactive.
	async function upgradeEditorOrReviewInput() {
		let result;
		destroySpinner = res.spinner('Validating the add-ons...');
		try {
			// Validate add-ons.
			validateAddons(addons, sdkAddons, req.fdt.license);
		} catch (error) {
			destroySpinner();

			if (req.options['non-interactive']) {
				throw error;
			}

			res.break();
			res.error(error.message);
			if (error.solution) {
				res.break();
				res.notice(error.solution);
			}
			res.break();

			// Prompt user for corrected input.
			const options = {
				currentVersion,
				sdkVersion,
			};
			const promptResult = await promptEditorUpgradeFlow(options);

			// User opted to quit.
			if (promptResult === false) {
				return false;
			}

			return upgradeEditorOrReviewInput();
		}

		destroySpinner();

		return result;
	}
	const upgradeEditorResult = await upgradeEditorOrReviewInput();

	// If the editor upgrade creation failed, and the user opted to quit, do so.
	if (upgradeEditorResult === false) {
		// outputDataAsCommandLineArguments(data, res);
		res.break();
		res.notice('Aborted.');
		return;
	}

	const upgradeIsPre770Editor = sdkVersion.isPre7_7_0;
	const isUpgradeFromPre770ToNonPre770Editor =
		currentVersion.isPre7_7_0 && !upgradeIsPre770Editor;

	const sdkMessagesFiles = [];

	// Decode and extract the zipped editor upgrade.
	destroySpinner = res.spinner('Extracting the upgraded SDK...');
	try {
		const platformFolder = path.join(editorPath, 'platform');

		await fs.emptyDir(platformFolder);

		for (const filePath in sdkFiles) {
			const file = sdkFiles[filePath];
			const packageName = filePath.split('/')[0];

			if (filePath === 'manifest.json') {
				continue;
			}

			if (
				sdkAddons.find(
					(sdkAddon) => sdkAddon.package === packageName
				) &&
				!addons.includes(packageName)
			) {
				continue;
			}

			if (filePath === `${packageName}/messages.json`) {
				sdkMessagesFiles.push(JSON.parse(Buffer.from(file)));
				continue;
			}

			if (file.byteLength === 0 && /[/\\]$/.test(filePath)) {
				await fs.ensureDir(path.join(platformFolder, filePath));
			} else {
				await fs.writeFile(
					path.join(platformFolder, filePath),
					Buffer.from(file)
				);
			}
		}
	} catch (error) {
		throw new res.ErrorWithInnerError(
			'Could not extract the upgraded SDK.',
			error
		);
	} finally {
		destroySpinner();
	}

	// Create message template bundle.
	destroySpinner = res.spinner(
		'Updating the messages template file for localization...'
	);
	try {
		// Update the file.
		await createMessageTemplate(
			sdkMessagesFiles,
			path.join(editorPath, 'messages-template.json')
		);
	} catch (error) {
		throw new res.ErrorWithInnerError(
			'Could not update the messages-template.json file.',
			error
		);
	} finally {
		destroySpinner();
	}

	// Update manifest.json.
	destroySpinner = res.spinner('Updating the manifest file...');
	const manifestPath = path.join(editorPath, 'manifest.json');
	try {
		// Update the file.
		await updateManifest(manifestPath, sdkManifest, addons);
	} catch (error) {
		throw new res.ErrorWithInnerError(
			'Could not update the manifest.json file, please update "manifest.json" accordingly.',
			error
		);
	} finally {
		destroySpinner();
	}

	// Update config/fonto-manifest.json.
	destroySpinner = res.spinner('Updating the config manifest file...');
	const fontoManifestPath = path.join(
		editorPath,
		'config/fonto-manifest.json'
	);
	try {
		// Update the file.
		await updateConfigFontoManifest(fontoManifestPath, addons);
	} catch (error) {
		throw new res.ErrorWithInnerError(
			'Could not update the config/fonto-manifest.json file, please update "config/fonto-manifest.json" accordingly.',
			error
		);
	}

	// Set up code intelligence if there's a base tsconfig.json and it hasn't
	// been set up yet.
	const platformHasTsConfig = await fs.pathExists(
		path.join(editorPath, 'platform', 'tsconfig.json')
	);
	if (platformHasTsConfig) {
		// The current ModuleRegistration could be either editor or editor-pre-7-7-0.
		const editorPre770ModulePath = path.resolve(
			req.command.getModuleRegistration().getPath(),
			'..',
			'editor-pre-7-7-0',
		);
		await fs.copy(
			path.resolve(
				editorPre770ModulePath,
				'assets',
				'instanceTemplateTypeScript',
				'tsconfig.json'
			),
			path.resolve(editorPath, 'tsconfig.json'),
			{
				// Silently fail when target already exists.
				overwrite: false,
			}
		);

		// Add a package.json with a TypeScript dependency when there's none.
		await fs.copy(
			path.resolve(
				editorPre770ModulePath,
				'assets',
				'instanceTemplateTypeScript',
				'package.json'
			),
			path.resolve(editorPath, 'package.json'),
			{
				// Silently fail when target already exists.
				overwrite: false,
			}
		);
	}

	await req.fdt.license.sendTelemetry({
		product: req.command.parent.name,
		type: 'selfContained',
		runtime: 'web',
		version: sdkVersion.format(),
		currentVersion: req.fdt.editorRepository.sdkVersion.format(),
		action: req.command.name,
		addons,
	});

	destroySpinner();

	// Convert editor from pre 7.7.0 codebase to 7.7.0+ codebase.
	if (isUpgradeFromPre770ToNonPre770Editor) {
		try {
			await convertEditorWithOutput(editorPath, false, res);
		} catch (error) {
			res.error(error);
			res.notice(
				'Something went wrong while converting the pre 7.7.0 editor codebase, you can try to manually upgrade by running `fdt editor convert editor`.'
			);
			res.break();
		}
	}

	// npm install.
	if (upgradeIsPre770Editor) {
		await npmInstall(editorPath, res);
	}

	// Done.
	res.break();
	res.notice('You succesfully upgraded Fonto Editor!');
	if (platformHasTsConfig) {
		res.break();
		res.notice('For setting up code intelligence and/or TypeScript, see:');
		res.notice(
			'https://documentation.fontoxml.com/latest/typescript-f488eb98fb35'
		);
	}
}
