import chalk from 'chalk';
import fs from 'fs';
import enquirer from 'enquirer';
import path from 'path';
import wrapAnsi from 'wrap-ansi';

import addonsAddDependencies from './addonsAddDependencies.js';
import getAddonLabels from './getAddonLabels.js';
import getAddonLabelsForChanges from './getAddonLabelsForChanges.js';

/** @typedef {import('../../../../FdtLicense.js')} FdtLicense */

const DEFAULT_STDOUT_COLUMNS = 30;

async function disableCancelPrompt(input, key) {
	if (!key.ctrl || key.name !== 'escape') {
		return;
	}

	this.state.cancelled = this.state.submitted = true;

	await this.render();
	await this.close();

	if (typeof this.options.onCancel === 'function') {
		await this.options.onCancel.call(this, this.name, this.value, this);
	}

	this.emit('cancel', await this.error(input));
}

export async function promptConfirm(message) {
	try {
		const answers = await enquirer.prompt([
			{
				name: 'confirm',
				type: 'confirm',
				message: message || 'Are you sure?',
				initial: true,
				format: (value) => (value ? 'Yes' : 'No'),
			},
		]);

		return !!answers.confirm;
	} catch (error) {
		if (!error) {
			return false;
		}
		throw error;
	}
}

async function promptName({ data }) {
	const answers = await enquirer.prompt([
		{
			name: 'name',
			type: 'input',
			message: 'Fonto Editor instance name',
			initial: data.name,
			cancel: disableCancelPrompt,
			validate: (instanceName) =>
				instanceName.trim().length
					? true
					: 'No name provided. Please check your input and try again.',
			filter: (instanceName) => instanceName.trim().toLowerCase(),
		},
	]);

	data.name = answers.name;
	return data;
}

async function promptSchema({ data }) {
	const answers = await enquirer.prompt([
		{
			name: 'schema',
			type: 'input',
			message: 'Schema bundle fonto.json path',
			initial: data.schema,
			cancel: disableCancelPrompt,
			validate: (fontoJsonPath) => {
				try {
					if (fs.statSync(path.resolve(fontoJsonPath)).isDirectory()) {
						fs.statSync(path.resolve(fontoJsonPath, 'fonto.json'));
						return true;
					}
					return path.basename(fontoJsonPath) === 'fonto.json';
				} catch (_error) {
					return "Cannot find 'fonto.json' at the provided path. Please check your input and try again.";
				}
			},
		},
	]);

	data.schema = answers.schema;
	return data;
}

/**
 * @template {{ dependencies: string[], package: string }} TAddon
 * @template {{ addons: string[] }} TData
 *
 * @param {{ currentAddons?: string[], data: TData, sdkAddons: TAddon[], fdtLicense: FdtLicense }} options
 *
 * @returns {Promise<TData>}
 */
async function promptAddons({ currentAddons, data, sdkAddons, fdtLicense }) {
	const width = process.stdout?.columns
		? process.stdout?.columns - 2
		: DEFAULT_STDOUT_COLUMNS;
	const checkedAddons = sdkAddons
		.filter((sdkAddon) => data.addons.includes(sdkAddon.package))
		.map((sdkAddon) => sdkAddon.package);
	const promptAnswers = await enquirer.prompt([
		{
			name: 'addons',
			type: 'multiselect',
			message: 'Add-ons',
			emptyError: null,
			initial: checkedAddons,
			cancel: disableCancelPrompt,
			columns: width,
			// Every choice has 4 lines.
			rows: Math.max(Math.floor((process.stdout.rows - 4) / 4), 5),
			choices: sdkAddons.reduce((choices, addon) => {
				// Disabled add-ons for which there is no license.
				const disabled =
					!!addon.licenses && !fdtLicense.hasProductLicenses(addon.licenses);

				// Hide preview add-ons, if not explicitly enabled.
				if (
					addon.isPreview &&
					!data.addons.includes(addon.package) &&
					!currentAddons?.includes(addon.package)
				) {
					return choices;
				}

				let hint = `${chalk.dim(`[${addon.package}]`)}\n  ${chalk.dim(
					addon.description.length > width
						? `${addon.description.substring(0, width - 3)}...`
						: addon.description,
				)}\n`;
				if (disabled) {
					hint += `    Your license currently does not include the ${addon.package} add-on, and thus cannot be enabled.\n`;
				} else if (addon.dependencies) {
					hint += `    Depends on: ${chalk.dim(
						addon.dependencies.join(', '),
					)}\n`;
				}

				// Make sure each choice is 4 lines.
				if (!disabled && !addon.dependencies) {
					hint += '\n';
				}

				choices.push({
					name: addon.package,
					message: addon.name,
					hint,
					disabled,
				});

				return choices;
			}, []),
		},
	]);

	data.addons = addonsAddDependencies(promptAnswers.addons, sdkAddons);
	return data;
}

function lineBreakAndIndentArray(
	items,
	indentationLength,
	lineLength = process.stdout.columns || DEFAULT_STDOUT_COLUMNS,
) {
	const outputLength = lineLength - indentationLength - 1;

	const output = wrapAnsi(items.join(', '), outputLength, {
		hard: true,
		wordWrap: true,
		trim: true,
	}).replace(/\n/g, `\n${' '.repeat(Math.max(0, indentationLength))}`);

	return output;
}

async function promptInitReview(options) {
	const { data, sdkAddons, sdkVersion } = options;

	const addonLabels = getAddonLabels(data.addons, sdkAddons);

	const answers = await enquirer.prompt([
		{
			name: 'choice',
			type: 'select',
			message: 'Review your configuration',
			initial: 'create',
			cancel: disableCancelPrompt,
			choices: [
				{
					name: 'name',
					message: 'Change instance name',
					hint: `   ${chalk.green(data.name)}`,
				},
				{
					name: 'schema',
					message: 'Change fonto.json path',
					hint: ` ${chalk.green(data.schema || 'not set (required)')}`,
				},
				{
					name: 'addons',
					message: 'Change add-ons',
					hint: `         ${chalk.green(
						lineBreakAndIndentArray(addonLabels, 26) || 'no add-ons selected',
					)}`,
				},
				{ role: 'separator' },
				{
					name: 'create',
					message: 'Create Fonto Editor instance',
					hint: `(${chalk.green(
						sdkVersion.isNightly ? 'nightly' : sdkVersion.format(),
					)})`,
				},
				{
					name: 'quit',
					message: 'Quit',
				},
			],
		},
	]);

	switch (answers.choice) {
		case 'name':
			return promptName(options).then(() => promptInitReview(options));
		case 'schema':
			return promptSchema(options).then(() => promptInitReview(options));
		case 'addons':
			return promptAddons(options).then(() => promptInitReview(options));
		case 'create':
			return data;
		case 'quit': {
			const quit = await promptConfirm('Are you sure you want to quit?');
			return quit ? false : promptInitReview(options);
		}
		default:
			return promptInitReview(options);
	}
}

export async function promptEditorInitFlow(options) {
	const steps = [
		{
			name: 'name',
			prompt: promptName,
		},
		{
			name: 'schema',
			prompt: promptSchema,
		},
		{
			name: 'addons',
			prompt: promptAddons,
		},
	].filter((step) => {
		if (!options.stepsToSkip) {
			return true;
		}
		return !options.stepsToSkip.includes(step.name);
	});

	if (!options.skipAllSteps) {
		let step;
		while ((step = steps.shift()) !== undefined) {
			await step.prompt(options);
		}
	}

	const reviewResult = await promptInitReview(options);
	if (reviewResult === false) {
		return false;
	}

	return options.data;
}

async function promptUpgradeReview(options) {
	const { currentVersion, sdkVersion } = options;

	let versionDifference = 'unknown';

	try {
		versionDifference = sdkVersion.compare(currentVersion);
	} catch (_error) {
		// Do nothing.
	}

	const nightlyOrVersion = sdkVersion.isNightly
		? 'nightly'
		: sdkVersion.format();

	const answers = await enquirer.prompt([
		{
			name: 'choice',
			type: 'select',
			message: 'Review your configuration',
			initial: 'upgrade',
			cancel: disableCancelPrompt,
			choices: [
				{
					name: 'upgrade',
					message:
						versionDifference === 0
							? `Upgrade the Fonto Editor instance to the same version (${chalk.green(
									nightlyOrVersion,
							  )})`
							: versionDifference === 'unknown' || versionDifference > 0
							  ? `Upgrade the Fonto Editor instance from ${chalk.green(
										currentVersion.format(),
								  )} to ${chalk.green(nightlyOrVersion)}`
							  : `Downgrade the Fonto Editor instance from ${chalk.green(
										currentVersion.format(),
								  )} to ${chalk.green(nightlyOrVersion)}`,
				},
				{
					name: 'quit',
					message: 'Quit',
				},
			],
		},
	]);

	switch (answers.choice) {
		case 'upgrade': {
			const didConfirm = await promptConfirm(
				[
					chalk.yellow(
						'Warning: this command will attempt to modify files in the current folder.',
					),
					chalk.yellow(
						'Please close all applications using these files, make sure they are writable, and consider creating a backup before continuing.',
					),
					'Are you sure you want to continue?',
				].join('\n  '),
			);
			return didConfirm ? {} : promptUpgradeReview(options);
		}
		case 'quit': {
			const quit = await promptConfirm(
				'Are you sure you want to quit? All changes will be lost.',
			);
			return quit ? false : promptUpgradeReview(options);
		}
		default:
			return promptUpgradeReview(options);
	}
}

export async function promptEditorUpgradeFlow(options) {
	const reviewResult = await promptUpgradeReview(options);
	if (reviewResult === false) {
		return false;
	}

	return options.data;
}

async function promptChangeAddonsReview(options) {
	const { currentAddons, currentVersion, data, sdkAddons } = options;
	const addonLabels = getAddonLabelsForChanges(
		currentAddons,
		data.addons,
		sdkAddons,
	);
	const answers = await enquirer.prompt([
		{
			name: 'choice',
			type: 'select',
			message: 'Review your configuration',
			initial: 'apply',
			cancel: disableCancelPrompt,
			choices: [
				{
					name: 'addons',
					message: 'Change add-ons',
					hint: `${
						lineBreakAndIndentArray(addonLabels, 18) ||
						chalk.green('no changes')
					}`,
				},
				{ role: 'separator' },
				{
					name: 'apply',
					message: 'Apply add-on changes to the Fonto Editor instance version',
					hint: `(${chalk.green(
						currentVersion.isNightly ? 'nightly' : currentVersion.format(),
					)})`,
				},
				{
					name: 'quit',
					message: 'Quit',
				},
			],
		},
	]);

	switch (answers.choice) {
		case 'addons':
			return promptAddons(options).then(() =>
				promptChangeAddonsReview(options),
			);
		case 'apply': {
			const didConfirm = await promptConfirm(
				[
					chalk.yellow(
						'Warning: this command will attempt to modify files in the current folder.',
					),
					chalk.yellow(
						'Please close all applications using these files, make sure they are writable, and consider creating a backup before continuing.',
					),
					'Are you sure you want to continue?',
				].join('\n  '),
			);
			return didConfirm ? data : promptChangeAddonsReview(options);
		}
		case 'quit': {
			const quit = await promptConfirm(
				'Are you sure you want to quit? All changes will be lost.',
			);
			return quit ? false : promptChangeAddonsReview(options);
		}
		default:
			return promptChangeAddonsReview(options);
	}
}

export async function promptEditorChangeAddonsFlow(options) {
	if (!options.skipAllSteps) {
		await promptAddons(options);
	}

	const reviewResult = await promptChangeAddonsReview(options);
	if (reviewResult === false) {
		return false;
	}

	return options.data;
}
