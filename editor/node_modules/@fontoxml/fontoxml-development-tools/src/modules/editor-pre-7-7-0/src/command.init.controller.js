import fs from 'fs-extra';
import os from 'os';
import path from 'path';
import { unzip } from 'fflate';

import Version from '../../../Version.js';
import checkInitDestination from '../../shared/src/controller-templates/checkInitDestination.js';
import addonsAddDependencies from './api/addonsAddDependencies.js';
import createMessageTemplate from './api/createMessageTemplate.js';
import downloadEditorSDK from './api/downloadEditorSDK.js';
import getAddonsFromEditorSDK from './api/getAddonsFromEditorSDK.js';
import createConfigConfiguration from './api/init/createConfigConfiguration.js';
import createConfigFontoManifest from './api/init/createConfigFontoManifest.js';
import createSchemaExperienceResolver from './api/init/createSchemaExperienceResolver.js';
import { promptConfirm, promptEditorInitFlow } from './api/enquirerPrompts.js';
import npmInstall from './api/npmInstall.js';
import createSchemaExperiencePackages from './api/schema/createSchemaExperiencePackages.js';
import createSchemaPackages from './api/schema/createSchemaPackages.js';
import getPrefixByNamespaceUri from './api/schema/getPrefixByNamespaceUri.js';
import getSchemaFontoJson from './api/schema/getSchemaFontoJson.js';
import getVersionedSchemaCompilerBaseUrl from './api/schema/getVersionedSchemaCompilerBaseUrl.js';
import schemaCompile from './api/schema/compile.js';
import validateAddons from './api/validateAddons.js';
import zipSchemaSource from './api/schema/zipSchemaSource.js';

const SCHEMA_COMPILE_DOCUMENTATION_URL =
	'https://documentation.fontoxml.com/latest/create-a-schema-bundle-d186eeb79200';

export default async function editorInitCommand(req, res) {
	res.caption(req.command.getLongName());

	let destroySpinner;

	const editorPath = path.resolve(req.parameters.output || process.cwd());

	let sdkVersion = req.options.version
		? new Version(req.options.version)
		: req.fdt.version.isNightly
		? new Version('nightly')
		: req.fdt.version;
	if (sdkVersion.compare(req.fdt.version) !== 0) {
		req.fdt.ensureCompatibilityWithFdt(sdkVersion, 'initialize', 'editor');
	}

	// Check if the required fonto.json path has been specified when running non-interactive.
	if (req.options['non-interactive'] && !req.options['schema']) {
		throw new res.InputError('Missing schema value.');
	}

	// Download the Fonto Editor build matching the SDK version.
	destroySpinner = res.spinner(
		`Retrieving Fonto Editor SDK version ${
			sdkVersion.isNightly ? 'nightly' : sdkVersion.format()
		}...`
	);
	const downloadedSDK = await downloadEditorSDK(sdkVersion, req, res);
	destroySpinner();

	// Determine add-ons.
	let addons = req.options['add-ons'].length ? req.options['add-ons'] : [];

	// Extract and check the SDK manifest.
	destroySpinner = res.spinner('Analyzing the SDK contents...');

	let sdkAddons;
	let sdkFiles;
	let sdkManifest;

	try {
		sdkFiles = await new Promise((resolve, reject) => {
			unzip(downloadedSDK, (error, data) => {
				if (error) {
					reject(error);
					return;
				}
				resolve(data);
			});
		});

		sdkManifest = JSON.parse(Buffer.from(sdkFiles['manifest.json']));

		if (!sdkManifest || !sdkManifest.buildDate || !sdkManifest.version) {
			throw new Error();
		}

		sdkManifest.version = new Version(sdkManifest.version);

		sdkAddons = await getAddonsFromEditorSDK(sdkManifest);
		addonsAddDependencies(addons, sdkAddons);
	} catch (error) {
		throw new res.ErrorWithInnerError(
			'Something went wrong while analyzing the SDK contents.',
			error
		);
	} finally {
		destroySpinner();
	}

	// Do not initialise with TypeScript when no tsconfig.json is found.
	const platformHasTsConfig = !!sdkFiles['tsconfig.json'];
	const useTypeScript = req.options['output-javascript']
		? false
		: platformHasTsConfig;

	// Set the sdkVersion to the actual version, for nightlies it's sets to the specific nightly version string instead of 'nightly'.
	sdkVersion = sdkManifest.version;

	// Check if the destination directory conforms to spec.
	destroySpinner = res.spinner('Checking destination...');
	// The current ModuleRegistration could be either editor or editor-pre-7-7-0.
	const editorPre770ModulePath = path.resolve(
		req.command.getModuleRegistration().getPath(),
		'..',
		'editor-pre-7-7-0',
	);
	const templateDirectoryPath = path.resolve(
		editorPre770ModulePath,
		'assets',
		useTypeScript ? 'instanceTemplateTypeScript' : 'instanceTemplate',
	);
	const existingFilesAndDirectories = await checkInitDestination(
		editorPath,
		templateDirectoryPath,
		res
	);
	const preexistingPackageJson =
		existingFilesAndDirectories.includes('package.json');
	const preexistingGitIgnore =
		existingFilesAndDirectories.includes('.gitignore');
	destroySpinner();
	if (existingFilesAndDirectories.length) {
		if (req.options['non-interactive']) {
			res.notice(
				'WARNING: You are initializing Fonto Editor in a non-empty directory.'
			);
			res.break();
		} else if (
			!(await promptConfirm(
				'You are about to initialize Fonto Editor in a non-empty directory, do you want to continue?',
			))
		) {
			res.break();
			res.notice('Aborted');
			return;
		}
	}

	// Prepare input data.
	const data = {
		name: req.options.name || path.basename(editorPath),
		schema: req.options.schema || null,
		addons,
	};

	// If the command is run interactively (default), prompt for input.
	if (!req.options['non-interactive']) {
		const stepsToSkip = Object.keys(req.options).filter(
			(option) =>
				['name', 'schema', 'add-ons'].includes(option) &&
				!!req.options[option] &&
				!!req.options[option].length
		);

		const options = {
			data,
			fdtLicense: req.fdt.license,
			sdkAddons,
			sdkVersion,
			stepsToSkip,
		};
		const result = await promptEditorInitFlow(options);
		if (result === false) {
			res.break();
			res.notice('Aborted.');
			return;
		}
	}

	// Validate input and create a new Fonto Editor instance, or on error, prompt the user for input, if not non-interactive.
	let fontoJson;
	let schemaCompileResults;
	async function createEditorOrReviewInput() {
		destroySpinner = res.spinner('Validating the input...');
		try {
			// Validate add-ons.
			validateAddons(data.addons, sdkAddons, req.fdt.license);

			let schemaPath = data.schema;
			if (path.basename(schemaPath) === 'fonto.json') {
				schemaPath = path.dirname(schemaPath);
			}
			destroySpinner();

			// Compile schema to validate.
			destroySpinner = res.spinner('Compiling the schema(s)...');
			try {
				fontoJson = await getSchemaFontoJson(schemaPath);
			} catch (error) {
				const solution = error.solution
					? error.solution
					: [
							'See the documentation for help with compiling a schema:',
							SCHEMA_COMPILE_DOCUMENTATION_URL,
					  ].join(os.EOL);

				throw new res.ErrorWithSolution(error.message, solution, error);
			}
			const compressedSchema = await zipSchemaSource(schemaPath, res);
			let schemaCompilerBaseUrl = req.options['schema-compiler-base-url'];
			if (schemaCompilerBaseUrl) {
				res.notice(
					`Using schema compiler backend at "${schemaCompilerBaseUrl}".`
				);
			} else {
				schemaCompilerBaseUrl = await getVersionedSchemaCompilerBaseUrl(
					req.fdt.license,
					sdkVersion
				);
			}
			schemaCompileResults = await schemaCompile(
				schemaCompilerBaseUrl,
				compressedSchema,
				res
			);

			if (schemaCompileResults.error) {
				res.caption('Schema compilation errors');
				res.error(schemaCompileResults.error.message);
				if (schemaCompileResults.error.details) {
					res.list(schemaCompileResults.error.details, '-');
				}
				res.break();
				throw new Error('The schema(s) failed to compiled.');
			}

			if (schemaCompileResults.warningsByXsdPath) {
				res.caption('Warning(s) while compiling the schema(s)');
				res.indent();
				Object.keys(schemaCompileResults.warningsByXsdPath).forEach(
					(xsdPath) => {
						res.caption(xsdPath);
						res.list(
							schemaCompileResults.warningsByXsdPath[xsdPath],
							'-'
						);
					}
				);
				res.outdent();
				res.break();
			}
		} catch (error) {
			destroySpinner();

			fontoJson = null;
			schemaCompileResults = null;

			if (req.options['non-interactive']) {
				throw error;
			}

			res.break();
			res.error(error.message);
			if (error.solution) {
				res.break();
				res.notice(error.solution);
			}
			res.break();

			// Prompt user for corrected input.
			const options = {
				data,
				fdtLicense: req.fdt.license,
				sdkAddons,
				sdkVersion,
				skipAllSteps: true,
			};
			const promptResult = await promptEditorInitFlow(options);

			// User opted to quit.
			if (promptResult === false) {
				return false;
			}

			return createEditorOrReviewInput();
		}

		destroySpinner();

		return true;
	}
	const createEditorResult = await createEditorOrReviewInput();
	addons = data.addons;

	// If the editor creation failed, and the user opted to quit, do so.
	if (createEditorResult === false) {
		res.break();
		res.notice('Aborted.');
		return;
	}

	// Copy the Fonto Editor instance template.
	destroySpinner = res.spinner('Setting up a new Fonto Editor instance...');
	try {
		await fs.copy(templateDirectoryPath, editorPath, {
			filter: (src, _dest) => {
				const filename = path.basename(src);
				if (preexistingPackageJson && filename === 'package.json') {
					return false;
				}
				if (preexistingGitIgnore && filename === '.gitignore') {
					return false;
				}
				return filename !== '.gitkeep';
			},
		});
	} catch (error) {
		throw new res.ErrorWithInnerError(
			'Could not copy the files from the Fonto Editor instance template.',
			error
		);
	} finally {
		destroySpinner();
	}

	// Create schema packages.
	destroySpinner = res.spinner(
		'Creating package(s) for the compiled schema(s)...'
	);
	try {
		await createSchemaPackages(
			editorPath,
			fontoJson.rootSchemas,
			schemaCompileResults,
			useTypeScript
		);
	} catch (error) {
		throw new res.ErrorWithInnerError(
			'Could not create the package(s) for the compiled schema(s).',
			error
		);
	} finally {
		destroySpinner();
	}

	// Building schema namespace configuration.
	destroySpinner = res.spinner(
		'Building configuration for namespaces and prefixes...'
	);
	let prefixByNamespaceUri;
	try {
		prefixByNamespaceUri = getPrefixByNamespaceUri(schemaCompileResults);
	} catch (error) {
		throw new res.ErrorWithInnerError(
			'Could not the build configuration for schema namespaces and prefixes.',
			error
		);
	} finally {
		destroySpinner();
	}

	// Create schema experience packages.
	destroySpinner = res.spinner(
		'Creating package(s) for the schema experience(s)...'
	);
	let editorPackages;
	try {
		editorPackages = await createSchemaExperiencePackages(
			editorPath,
			fontoJson.rootSchemas,
			schemaCompileResults,
			prefixByNamespaceUri,
			addons,
			sdkVersion,
			useTypeScript
		);
	} catch (error) {
		throw new res.ErrorWithInnerError(
			'Could not create the package(s) for the schema experience(s).',
			error
		);
	} finally {
		destroySpinner();
	}

	// Create config/fonto-manifest.json.
	destroySpinner = res.spinner('Creating the config manifest file...');
	const fontoManifestPath = path.join(
		editorPath,
		'config',
		'fonto-manifest.json'
	);
	try {
		await createConfigFontoManifest(
			fontoManifestPath,
			addons,
			editorPackages
		);
	} catch (error) {
		throw new res.ErrorWithInnerError(
			'Could not create the config/fonto-manifest.json file.',
			error
		);
	} finally {
		destroySpinner();
	}

	// Creating config/configuration.ts/js.
	destroySpinner = res.spinner('Creating the config configuration file...');
	const configConfigurationPath = path.join(
		editorPath,
		'config',
		`configuration${useTypeScript ? '.ts' : '.js'}`
	);
	try {
		await createConfigConfiguration(
			configConfigurationPath,
			prefixByNamespaceUri,
			addons,
			schemaCompileResults,
			sdkVersion
		);
	} catch (error) {
		throw new res.ErrorWithInnerError(
			`Could not create the config/configuration${
				useTypeScript ? '.ts' : '.js'
			} file.`,
			error
		);
	} finally {
		destroySpinner();
	}

	// Creating config/schemaExperienceResolver.ts/js.
	destroySpinner = res.spinner(
		'Creating the config schema experience resolver file...'
	);
	const schemaExperienceResolverPath = path.join(
		editorPath,
		'config',
		`schemaExperienceResolver${useTypeScript ? '.ts' : '.js'}`
	);
	try {
		await createSchemaExperienceResolver(
			schemaExperienceResolverPath,
			fontoJson.rootSchemas
		);
	} catch (error) {
		throw new res.ErrorWithInnerError(
			`Could not create the config/schemaExperienceResolver${
				useTypeScript ? '.ts' : '.js'
			} file.`,
			error
		);
	} finally {
		destroySpinner();
	}

	const sdkMessagesFiles = [];

	// Decode and extract the zipped editor.
	destroySpinner = res.spinner('Extracting the SDK...');
	try {
		const platformFolder = path.join(editorPath, 'platform');

		await fs.emptyDir(platformFolder);

		for (const filePath in sdkFiles) {
			const file = sdkFiles[filePath];
			const packageName = filePath.split('/')[0];

			if (filePath === 'manifest.json') {
				continue;
			}

			if (
				sdkAddons.find(
					(sdkAddon) => sdkAddon.package === packageName
				) &&
				!addons.includes(packageName)
			) {
				continue;
			}

			if (filePath === `${packageName}/messages.json`) {
				sdkMessagesFiles.push(JSON.parse(Buffer.from(file)));
				continue;
			}

			if (file.byteLength === 0 && /[/\\]$/.test(filePath)) {
				await fs.ensureDir(path.join(platformFolder, filePath));
			} else {
				await fs.writeFile(
					path.join(platformFolder, filePath),
					Buffer.from(file)
				);
			}
		}
	} catch (error) {
		throw new res.ErrorWithInnerError('Could not extract the SDK.', error);
	} finally {
		destroySpinner();
	}

	// Create message template bundle.
	destroySpinner = res.spinner(
		'Creating the messages template file for localization...'
	);
	try {
		// Create the file.
		await createMessageTemplate(
			sdkMessagesFiles,
			path.join(editorPath, 'messages-template.json')
		);
	} catch (error) {
		throw new res.ErrorWithInnerError(
			'Could not create the messages-template.json file.',
			error
		);
	} finally {
		destroySpinner();
	}

	// Create manifest.json.
	destroySpinner = res.spinner('Creating the manifest file...');
	const manifestPath = path.join(editorPath, 'manifest.json');
	try {
		// Create the file.
		await fs.writeJson(
			manifestPath,
			{
				addonNames: addons || [],
				name: data.name,
				sdkBuildDate: sdkManifest.buildDate,
				sdkVersion: sdkManifest.version.format(),
			},
			{ spaces: '\t' }
		);
	} catch (error) {
		throw new res.ErrorWithInnerError(
			'Could not create the manifest.json file.',
			error
		);
	}

	await req.fdt.license.sendTelemetry({
		product: req.command.parent.name,
		type: 'selfContained',
		runtime: 'web',
		version: sdkVersion.format(),
		action: req.command.name,
		addons,
	});

	destroySpinner();

	// Install NPM depencencies when there's a package.json.
	await npmInstall(editorPath, res);

	// Done.
	res.break();
	res.notice('You succesfully created a new instance of Fonto Editor!');
	res.break();
	res.notice(
		"You're almost there. There are some things that require your attention:"
	);
	res.break();
	res.notice(
		"Please search for the `// TODO` comments we've left behind and take the appropriate actions."
	);
	const templateIncludesPackageJson = await fs.pathExists(
		path.join(templateDirectoryPath, 'package.json')
	);
	if (templateIncludesPackageJson && preexistingPackageJson) {
		const packageJsonData = await fs.readJson(
			path.join(templateDirectoryPath, 'package.json')
		);
		if (packageJsonData.dependencies) {
			const dependencies = Object.entries(
				packageJsonData.dependencies
			).map(([packageName, version]) => `${packageName}@${version}`);
			res.break();
			res.notice(
				`Install required dependencies by running "npm install --save-exact ${dependencies.join(
					' '
				)}".`
			);
		}
		if (packageJsonData.devDependencies) {
			const devDependencies = Object.entries(
				packageJsonData.devDependencies
			).map(([packageName, version]) => `${packageName}@${version}`);

			res.break();
			res.notice(
				`Install required development dependencies by running "npm install --save-dev --save-exact ${devDependencies.join(
					' '
				)}".`
			);
		}
	}
	const templateIncludesGitIgnore = await fs.pathExists(
		path.join(templateDirectoryPath, '.gitignore')
	);
	if (templateIncludesGitIgnore && preexistingGitIgnore) {
		res.break();
		res.notice(
			'We recommend to add the following files and directories to your .gitignore file or its equivalent in your preferred version control system:'
		);
		const gitIgnoreData = await fs.readFile(
			path.join(templateDirectoryPath, '.gitignore')
		);
		res.raw(gitIgnoreData);
	}
}
