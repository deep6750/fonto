import { request } from 'undici';

/** @typedef {import('../../../../Version').default} Version */

/**
 * Download a zipped Fonto Editor SDK.
 *
 * @param {Version}     sdkVersion The Fonto Editor SDK version to download. Which will download
 *                                 that exact version, or download the latest/only `nightly` if it
 *                                 is any nightly version.
 * @param {FdtRequest}  req
 * @param {FdtResponse} res
 *
 * @return {Promise<any>}
 */
export default function downloadEditorSDK(sdkVersion, req, res) {
	const nightlyOrVersion = sdkVersion.isNightly
		? 'nightly'
		: sdkVersion.format();
	const requestObj = {
		editor: {
			selfContained: {
				runtime: 'web',
				version: nightlyOrVersion,
			},
		},
	};

	return req.fdt.license
		.getDataForProducts(requestObj)
		.catch(async (error) => {
			if (error.statusCode === 404) {
				try {
					const sdkVersions =
						await req.fdt.license.getVersionsForProduct('editor');
					const latestStableVersion =
						sdkVersions.getLatestStableForVersion(req.fdt.version);
					error = new res.ErrorWithSolution(
						`Could not download the Fonto Editor SDK for version "${nightlyOrVersion}". Please check if it is a valid version.`,
						`This version of FDT is designed to work with version "${req.fdt.version.format()}", and is compatible with versions "${req.fdt.version.format(
							'minor'
						)}.x"${
							latestStableVersion
								? ` of which the latest version is "${latestStableVersion.format()}"`
								: ''
						}.`,
						error
					);
				} catch (_error) {
					error = new res.ErrorWithSolution(
						`Could not download the Fonto Editor SDK for version "${nightlyOrVersion}". Please check if it is a valid version.`,
						`This version of FDT is designed to work with version "${req.fdt.version.format()}", and is compatible with versions "${
							req.fdt.version.isUnversioned
								? req.fdt.version.format()
								: `${req.fdt.version.format('minor')}.x`
						}".`,
						error
					);
				}
			}
			throw error;
		})
		.then((productData) => {
			const downloadUri =
				productData.products['editor'].selfContained.uri;
			return request(downloadUri, {
				method: 'GET',
			});
		})
		.catch((error) => {
			throw new res.ErrorWithInnerError(
				'Something went wrong while trying to download the Fonto Editor SDK. Please rerun the command to try again.',
				error
			);
		})
		.then(async (response) => {
			switch (response.statusCode) {
				case 200:
					try {
						return Buffer.from(await response.body.arrayBuffer());
					} catch (error) {
						throw new res.ErrorWithInnerError(
							'Invalid response data from the Fonto Editor SDK server.',
							error
						);
					}
				case 401:
				case 403:
					throw new Error(
						'You are currently not allowed to download this Fonto Editor SDK, even though you might have the license for it.'
					);
				case 404:
					throw new Error(
						'The file for the requested Fonto Editor SDK could not be found.'
					);
				default:
					throw new Error(
						`Invalid response from the Fonto Editor SDK server (${response.statusCode}).`
					);
			}
		});
}
