import babel from '@babel/core';
import { Lines } from 'recast/lib/lines.js';

const t = babel.types;

const FAKE_STATEMENT_FOR_KEEPING_STATEMENTS_TOGETHER =
	'fakeStatementForKeepingStatementsTogether();';

/**
 * Inserts fake .loc information to the comment node to force Recast to print a comment on a new line.
 *
 * It forces the code flow of Recast's printTrailingComment() function in comments.js to insert a new line before the comment.
 *
 * @param {AstNode} commentNode           The comment node to force a newline before.
 * @param {boolean} [extraNewline=false]  Indicates if an extra empty new line should be added as well.
 */
function trickRecastIntoInsertingNewlineBeforeComment(
	commentNode,
	extraNewline = false
) {
	const commentLength =
		(commentNode && commentNode.value ? commentNode.value.length : 0) + 2;
	const numberOfNewlines = extraNewline ? 2 : 1;
	const commentLineNumber = numberOfNewlines + 1;
	commentNode.loc = {
		start: { line: commentLineNumber, column: 0 },
		end: { line: commentLineNumber, column: commentLength },
		lines: new Lines([
			...Array(numberOfNewlines).fill({
				line: '',
				indent: 0,
				locked: false,
				sliceStart: 0,
				sliceEnd: 0,
			}),
			{
				line: `//${commentNode.value}`,
				indent: 0,
				locked: false,
				sliceStart: 0,
				sliceEnd: commentLength,
			},
		]),
	};
}

/**
 * Inserts fake .loc information to the comment node to force Recast to keep statements together
 * instead of inserting a new line in beteween.
 *
 * WARNING: Do not add any additional comments to the node after calling this function.
 *
 * @param {AstNode} node
 */
export function trickRecastIntoKeepingStatementsTogether(node) {
	const numberOfLeadingCommentLines = (node.leadingComments || []).length;
	const numberOfTrailingCommentLines = (node.trailingComments || []).length;
	const nodeLineNumber = numberOfLeadingCommentLines + 1;
	node.loc = {
		start: { line: nodeLineNumber, column: 0 },
		end: {
			line: nodeLineNumber,
			column: FAKE_STATEMENT_FOR_KEEPING_STATEMENTS_TOGETHER.length,
		},
		lines: new Lines([
			// Any leading comment lines.
			...Array(numberOfLeadingCommentLines).fill({
				line: '',
				indent: 0,
				locked: false,
				sliceStart: 0,
				sliceEnd: 0,
			}),
			// Fake statement for the specified node.
			{
				line: FAKE_STATEMENT_FOR_KEEPING_STATEMENTS_TOGETHER,
				indent: 0,
				locked: false,
				sliceStart: 0,
				sliceEnd: FAKE_STATEMENT_FOR_KEEPING_STATEMENTS_TOGETHER.length,
			},
			// Any trailing comment lines.
			...Array(numberOfTrailingCommentLines).fill({
				line: '',
				indent: 0,
				locked: false,
				sliceStart: 0,
				sliceEnd: 0,
			}),
			// Fake sibbling statement without empty line between them.
			{
				line: FAKE_STATEMENT_FOR_KEEPING_STATEMENTS_TOGETHER,
				indent: 0,
				locked: false,
				sliceStart: 0,
				sliceEnd: FAKE_STATEMENT_FOR_KEEPING_STATEMENTS_TOGETHER.length,
			},
		]),
	};
}

/**
 * Adds a leading or trailing comment(s) to the given AST node.
 *
 * @param {AstNode}         astNode                 The AST node to add the comment to.
 * @param {string|string[]} content                 The comment text contents, or an array of them. Will be prefixed with a space when it does not start with one.
 * @param {string}          [trailingComment=false] Indicates if the comment should be trailing instead of leading, defaults to false.
 * @param {string}          [extraNewline=false]    Indicates if the trailing comment should have an extra newline before it, this has no effect on leading comments.
 */
export default function addCommentToAstNode(
	astNode,
	content,
	trailingComment = false,
	extraNewline = false
) {
	// Guard against adding comments after already having called
	// trickRecastIntoKeepingStatementsTogether on the node.
	if (
		astNode.loc &&
		astNode.loc.lines &&
		astNode.loc.lines.infos &&
		astNode.loc.lines.infos.some(
			(info) =>
				info.line === FAKE_STATEMENT_FOR_KEEPING_STATEMENTS_TOGETHER
		)
	) {
		throw new Error(
			`Trying to add comment to a node on which trickRecastIntoKeepingStatementsTogether was already done, which can cause crashes.`
		);
	}

	if (Array.isArray(content)) {
		(trailingComment ? content : content.slice().reverse()).forEach(
			(line, index) => {
				addCommentToAstNode(
					astNode,
					line,
					trailingComment,
					extraNewline && index === 0
				);
			}
		);
		return;
	}

	// Always start with a trailing whitespace (which sits in between the `//` and the actual comment).
	content = ` ${content}`;

	// Add the comment(s) to the AST node.
	t.addComment(
		astNode,
		trailingComment ? 'trailing' : 'leading',
		content,
		true
	);

	const leadingComments = astNode.leadingComments || [];
	const trailingComments = astNode.trailingComments || [];

	// Enrich comment for the Recast plugin.
	const commentsContainer = trailingComment
		? trailingComments
		: leadingComments;
	const addedComment =
		commentsContainer[trailingComment ? commentsContainer.length - 1 : 0];
	addedComment.leading = !trailingComment;
	addedComment.trailing = !!trailingComment;
	if (trailingComment) {
		trickRecastIntoInsertingNewlineBeforeComment(
			addedComment,
			extraNewline
		);
	}

	// Update the comments for the Recast plugin, which does comment handling slightly different than vanilla babel.
	astNode.comments = [...leadingComments, ...trailingComments];
}
