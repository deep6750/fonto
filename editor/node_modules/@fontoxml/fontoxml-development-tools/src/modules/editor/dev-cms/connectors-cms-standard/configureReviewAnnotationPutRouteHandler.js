import EARLY_RETURN_SYMBOL from './review-annotations/EarlyReturnSymbol.js';
import httpStatusCodeHelpers from './review-annotations/httpStatusCodeHelpers.js';
import mapAnnotationResult from './review-annotations/mapAnnotationResult.js';
import { STATUS_OK } from './review-annotations/Result.js';

export default function configureReviewAnnotationPutRouteHandler(
	annotationDatabase,
	debugConfiguration
) {
	return (req, res) => {
		const {
			context: { editSessionToken },
			annotations,
		} = req.body;

		// TODO: ensure correct/valid queryOrBody.context? is this done automatically by other middleware?
		if (!annotations || annotations.length === 0) {
			// TODO: validate every feedback item?
			res.status(400).send(
				'Missing at least one item in "annotations" in the request.'
			);
			return;
		}

		debugConfiguration
			.getTimeoutConfigForRoute(
				req.cms,
				editSessionToken,
				'/review/annotation',
				'PUT'
			)
			.then((timeoutSet) => {
				if (timeoutSet) {
					return Promise.reject(EARLY_RETURN_SYMBOL);
				}

				return debugConfiguration.isDebuggingEnabled(
					req.cms,
					editSessionToken
				);
			})
			.then((isDebuggingEnabled) => {
				const currentSession = req.getFontoSession(editSessionToken);

				if (!isDebuggingEnabled) {
					return annotationDatabase
						.editAnnotations(req.cms, currentSession, annotations)
						.then((editAnnotationResult) =>
							editAnnotationResult.map((item) => {
								// Do not include replies in the responses since those are managed in separate Reply endpoints.
								if (item.status === STATUS_OK) {
									// Do not include replies in the responses since those are managed in separate Reply endpoints.
									delete item.annotation.replies;
								}
								return mapAnnotationResult(item);
							})
						)
						.then((annotationEditResults) => {
							res.set(
								'content-type',
								'application/json; charset=utf-8'
							).json({
								annotations: annotationEditResults,
							});
						});
				}

				for (let i = 0, length = annotations.length; i < length; i++) {
					const annotation = annotations[i];

					const foundHttpStatusCode =
						httpStatusCodeHelpers.getDebugHttpStatusCode(
							annotation.metadata.comment,
							[400, 500]
						);
					if (foundHttpStatusCode && !foundHttpStatusCode.onDelete) {
						httpStatusCodeHelpers.sendDebugHttpResponse(
							res,
							foundHttpStatusCode
						);
						return Promise.reject(EARLY_RETURN_SYMBOL);
					}
				}

				return annotations
					.reduce((promise, annotation) => {
						let foundHttpStatusCode;
						if (isDebuggingEnabled) {
							foundHttpStatusCode =
								httpStatusCodeHelpers.getDebugHttpStatusCode(
									annotation.metadata.comment,
									[403, 404, 412]
								);
						}

						if (
							!isDebuggingEnabled ||
							!foundHttpStatusCode ||
							foundHttpStatusCode.onDelete
						) {
							return promise.then((annotationEditResults) => {
								return annotationDatabase
									.editAnnotations(req.cms, currentSession, [
										annotation,
									])
									.then((editAnnotationResult) => {
										// Do not include replies in the responses since those are managed in separate Reply endpoints.
										if (
											editAnnotationResult.status ===
											STATUS_OK
										) {
											// Do not include replies in the responses since those are managed in separate Reply endpoints.
											delete editAnnotationResult
												.annotation.replies;
										}
										annotationEditResults.push(
											mapAnnotationResult(
												editAnnotationResult
											)
										);
										return annotationEditResults;
									});
							});
						}

						if (foundHttpStatusCode.statusCode === 403) {
							return promise.then((annotationEditResults) => {
								annotationEditResults.push({
									annotation: { id: annotation.id },
									status: foundHttpStatusCode.statusCode,
								});
								return annotationEditResults;
							});
						}

						if (foundHttpStatusCode.statusCode === 404) {
							return promise.then((annotationEditResults) => {
								annotationEditResults.push({
									annotation: { id: annotation.id },
									status: foundHttpStatusCode.statusCode,
								});

								return annotationDatabase
									.deleteAnnotations(
										req.cms,
										currentSession,
										[annotation]
									)
									.then(() => annotationEditResults);
							});
						}

						if (foundHttpStatusCode.statusCode === 412) {
							annotation.metadata.comment += '-simulated-change';

							return promise.then((annotationEditResults) => {
								annotationEditResults.push({
									annotation: { id: annotation.id },
									status: foundHttpStatusCode.statusCode,
								});

								return annotationDatabase
									.editAnnotations(req.cms, currentSession, [
										annotation,
									])
									.then(() => annotationEditResults);
							});
						}
					}, Promise.resolve([]))
					.then((annotationEditResults) => {
						res.set(
							'content-type',
							'application/json; charset=utf-8'
						).json({
							annotations: annotationEditResults,
						});
					});
			})
			.catch((error) => {
				if (error !== EARLY_RETURN_SYMBOL) {
					console.log('');
					console.error(error);
					res.status(500).send(error);
				}
			});
	};
}
