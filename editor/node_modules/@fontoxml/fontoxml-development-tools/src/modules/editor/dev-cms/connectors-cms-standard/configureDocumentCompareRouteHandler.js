import correlationIdRepository from './correlationIdRepository.js';

function configureDocumentRevisionGetRouteHandler() {
	return (req, res) => {
		const {
			documentAId,
			documentARevisionId,
			documentBId,
			documentBRevisionId,
		} = req.query;
		if (
			!documentBRevisionId ||
			!documentBId ||
			!documentARevisionId ||
			!documentAId
		) {
			res.status(400).end();
		}

		// Because these requests do not originate from the editor, but from an other server, we
		// have no edit session token.  We do, however, have an correlationId which we may resolve
		// to the editSessionToken used by the corresponding call to the proxy
		const editSessionToken =
			correlationIdRepository.getEditSessionTokenForRequest(req);
		req.cms.loadHistory(
			documentAId,
			editSessionToken,
			(historyErrorA, revisionsA) => {
				req.cms.loadHistory(
					documentBId,
					editSessionToken,
					(historyErrorB, revisionsB) => {
						req.cms.loadRevision(
							documentAId,
							documentARevisionId,
							editSessionToken,
							(revisionErrorA, contentA) => {
								req.cms.loadRevision(
									documentBId,
									documentBRevisionId,
									editSessionToken,
									(revisionErrorB, contentB) => {
										const revisionMetadataA =
											revisionsA &&
											revisionsA.find(
												(revision) =>
													revision.id ===
													documentARevisionId
											);
										const revisionMetadataB =
											revisionsB &&
											revisionsB.find(
												(revision) =>
													revision.id ===
													documentBRevisionId
											);
										if (
											revisionErrorA ||
											historyErrorA ||
											revisionErrorB ||
											historyErrorB ||
											!revisionMetadataA ||
											!revisionMetadataB
										) {
											// We did not find something
											res.status(404).end();
											return;
										}

										res.status(200)
											.set(
												'content-type',
												'application/json; charset=utf-8'
											)
											.json({
												documentARevision: {
													content: contentA,
													author: revisionMetadataA.author,
													lastModifiedTimestamp:
														revisionMetadataA.lastModifiedTimestamp,
												},
												documentBRevision: {
													content: contentB,
													author: revisionMetadataB.author,
													lastModifiedTimestamp:
														revisionMetadataB.lastModifiedTimestamp,
												},
											});
									}
								);
							}
						);
					}
				);
			}
		);
	};
}

export default configureDocumentRevisionGetRouteHandler;
