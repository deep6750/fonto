/** @typedef {import('./stores/DevelopmentCms')} DevelopmentCms */

/**
 * @typedef DocumentToLoad
 *
 * @property {string}  documentId
 * @property {boolean} [includeAdditionalDocuments]
 */

/**
 * @typedef Lock
 *
 * @property {boolean} isLockAcquired
 * @property {boolean} isLockAvailable
 */

/**
 * @typedef DocumentContext
 *
 * @property {{ [key: string]: unknown }} [documentMetadata]
 * @property {boolean}                    [isLockAcquired]
 */

/**
 * @typedef Document
 *
 * @property {string}                     documentId
 * @property {string}                     revisionId
 * @property {string}                     content
 * @property {Lock}                       lock
 * @property {{ [key: string]: unknown }} metadata
 * @property {DocumentContext}            documentContext
 */

/**
 * @typedef DocumentErrorResult
 *
 * @property {string} documentId
 * @property {number} status
 */

/**
 * @typedef DocumentResult
 *
 * @property {string}   documentId
 * @property {200}      status
 * @property {Document} body
 */

/**
 * @param {string} documentId
 * @param {string} revisionId
 * @param {string} content
 * @param {Lock} lock
 *
 * @returns {DocumentResult}
 */
function createDocumentResult(documentId, revisionId, content, lock) {
	return {
		documentId,
		status: 200,
		body: {
			documentId,
			revisionId,
			content,
			lock: {
				isLockAcquired: lock.isLockAcquired,
				isLockAvailable: lock.isLockAvailable,
				reason: !lock.isLockAvailable ? lock.lockReason : undefined,
			},
			metadata: {},
			documentContext: {
				documentMetadata: {},
				isLockAcquired: lock.isLockAcquired,
			},
		},
	};
}

function configureDocumentGetPostRouteHandler(config) {
	/**
	 * @param {DocumentToLoad} documentToLoad
	 * @param {string}         editSessionToken
	 * @param {DevelopmentCms} cms
	 *
	 * @returns {Promise<DocumentResult | DocumentErrorResult>}
	 */
	async function loadDocument(documentToLoad, editSessionToken, cms) {
		const documentId = documentToLoad.documentId;
		try {
			const content = await new Promise((resolve, reject) => {
				cms.load(documentId, editSessionToken, (error, content) => {
					if (error) {
						reject(error);
						return;
					}
					resolve(content);
				});
			});
			const revisionId = await new Promise((resolve, reject) => {
				cms.getLatestRevisionId(
					documentId,
					editSessionToken,
					(error, revisionId) => {
						if (error) {
							reject(error);
							return;
						}
						resolve(revisionId);
					},
				);
			});

			/** @type {Lock} */
			const documentLoadLock = {
				...config.documentLoadLock,
				...config.documentLoadLockOverrides[documentId],
			};
			return createDocumentResult(
				documentId,
				revisionId,
				content,
				documentLoadLock,
			);
		} catch (error) {
			return {
				documentId,
				status: error.status === 404 ? 404 : 500,
			};
		}
	}

	return async (req, res) => {
		const editSessionToken = req.body?.context?.editSessionToken;

		// Collect all explicitly requested documents to load
		/** @type {DocumentToLoad[]} */
		const documentsToLoad = [];
		const documentIds = new Set();
		for (const documentToLoad of req.body.documents) {
			if (
				typeof config.documentLoadBatchResultsLimit === 'number' &&
				documentsToLoad.length >= config.documentLoadBatchResultsLimit
			) {
				break;
			}
			if (documentIds.has(documentToLoad.documentId)) {
				continue;
			}
			documentsToLoad.push(documentToLoad);
			documentIds.add(documentToLoad.documentId);
		}

		// Collect all additional documents.
		const documentIdsWithAdditionalDocuments = new Set();
		const addAdditionalDocumentsForDocument = (documentId) => {
			if (!config.additionalDocuments?.[documentId]) {
				return;
			}
			for (const additionalDocumentId of config.additionalDocuments[
				documentId
			]) {
				if (!documentIds.has(additionalDocumentId)) {
					// Add the document if it is not yet added.
					documentsToLoad.push({ documentId: additionalDocumentId });
					documentIds.add(additionalDocumentId);
				}
				if (!documentIdsWithAdditionalDocuments.has(additionalDocumentId)) {
					// Recurse the additional document, if not already done so.
					addAdditionalDocumentsForDocument(additionalDocumentId);
					documentIdsWithAdditionalDocuments.add(additionalDocumentId);
				}
			}
		};
		for (const documentToLoad of documentsToLoad) {
			if (!documentToLoad.includeAdditionalDocuments) {
				continue;
			}
			addAdditionalDocumentsForDocument(documentToLoad.documentId);
		}

		/** @type {(DocumentResult | DocumentErrorResult)[]} */
		let results;
		try {
			results = await Promise.all(
				documentsToLoad.map((documentToLoad) =>
					loadDocument(documentToLoad, editSessionToken, req.cms),
				),
			);
		} catch (error) {
			res.status(500).send(error);
			return;
		}

		res
			.status(200)
			.set('content-type', 'application/json; charset=utf-8')
			.json({ results });
	};
}

export default configureDocumentGetPostRouteHandler;
