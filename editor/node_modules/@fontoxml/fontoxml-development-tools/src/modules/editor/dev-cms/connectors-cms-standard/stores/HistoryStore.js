import path from 'path';
import { v4 as uuid } from 'uuid';

import getFileHash from '../getFileHash.js';
import unmergeableRevisionList from './unmergeableRevisionList.js';

function saveHistoryDocument(
	saveToStore,
	documentId,
	revisions,
	editSessionToken,
	callback
) {
	// Abuse document IDs to store the history files
	const historyDocumentId = path.join('.history', documentId, 'history.json');
	const json = JSON.stringify(revisions, null, '\t');
	saveToStore(historyDocumentId, json, editSessionToken, callback);
}

export default class HistoryStore {
	constructor(cms) {
		this._cms = cms;
	}

	/**
	 * @typedef   {Object}  Revision
	 * @property  {string}  id
	 * @property  {Object}  author
	 * @property  {string}  lastModifiedTimestamp
	 * @property  {string}  _editSessionToken
	 */

	/**
	 * Retrieves the identifier of the latest revision.
	 *
	 * @param {DocumentId} documentId
	 * @param {EditSessionToken} editSessionToken
	 * @param {function([Error], string)} callback
	 */
	getLatestRevisionId(documentId, editSessionToken, callback) {
		this.loadHistory(
			documentId,
			editSessionToken,
			function (error, revisions) {
				if (error) {
					callback(error);
					return;
				}

				const latestRevision = revisions[0];
				callback(null, latestRevision.id);
			}
		);
	}

	/**
	 * @param  {DocumentId}                        documentId
	 * @param  {EditSessionToken}                  editSessionToken
	 * @param  {function([Error], Revision[])}  callback
	 */
	loadHistory(documentId, editSessionToken, callback) {
		// Abuse document IDs to store the history files
		const historyDocumentId = path.join(
			'.history',
			documentId,
			'history.json'
		);
		if (this._cms.existsSync(historyDocumentId, editSessionToken)) {
			this._cms.load(
				historyDocumentId,
				editSessionToken,
				(error, json) => {
					if (error) {
						callback(error);
						return;
					}

					let revisions;
					try {
						revisions = JSON.parse(json);
					} catch (error) {
						callback(error);
						return;
					}

					// Retrieve the file to determine whether it has changed on disk,
					//  if so, create a new revision on the fly and use that as latest.
					this._cms.load(
						documentId,
						editSessionToken,
						(error, content) => {
							if (error) {
								callback(error);
								return;
							}

							const hashInHistory = revisions[0].hash;
							const currentContentHash = getFileHash(content);

							if (hashInHistory === currentContentHash) {
								callback(null, revisions);
								return;
							}

							const session = {
								editSessionToken: uuid(),
								user: {
									displayName: 'Unknown',
									id: uuid(),
								},
							};

							const revisionId = uuid();
							revisions.unshift({
								id: revisionId,
								hash: currentContentHash,
								author: session.user,
								lastModifiedTimestamp: new Date().toISOString(),
								// Non-standard, used to combine saves per session
								_editSessionToken: session.editSessionToken,
							});

							const revisionDocumentId = path.join(
								'.history',
								documentId,
								revisionId
							);
							this._cms.saveToStore(
								revisionDocumentId,
								content,
								session.editSessionToken,
								(error) => {
									if (error) {
										callback(error);
										return;
									}

									saveHistoryDocument(
										this._cms.saveToStore.bind(this._cms),
										documentId,
										revisions,
										session.editSessionToken,
										(error, _documentId) => {
											if (error) {
												callback(error);
												return;
											}

											// Retrieve the changed, up to date history document and return that.
											this._cms.load(
												historyDocumentId,
												editSessionToken,
												(error, json) => {
													if (error) {
														callback(error);
														return;
													}

													let revisions;
													try {
														revisions =
															JSON.parse(json);
													} catch (error) {
														callback(error);
														return;
													}
													callback(null, revisions);
												}
											);
										}
									);
								}
							);
						}
					);
				}
			);
			return;
		}

		// No history for this document found, create one on the fly with only the initial revision
		this._cms.load(
			documentId,
			editSessionToken,
			(error, initialRevisionContent) => {
				if (error) {
					callback(error);
					return;
				}
				const initialSession = {
					user: {
						displayName: 'Unknown',
						id: uuid(),
					},
					editSessionToken,
				};
				this.createNew(
					documentId,
					initialRevisionContent,
					initialSession,
					callback
				);
			}
		);
	}

	loadRevision(documentId, revisionId, editSessionToken, callback) {
		const revisionDocumentId = path.join(
			'.history',
			documentId,
			revisionId
		);
		this._cms.load(revisionDocumentId, editSessionToken, callback);
	}

	createNew(documentId, content, currentSession, callback) {
		const initialRevisionId = uuid();
		const initialRevisionDocumentId = path.join(
			'.history',
			documentId,
			initialRevisionId
		);
		this._cms.saveToStore(
			initialRevisionDocumentId,
			content,
			currentSession.editSessionToken,
			(error) => {
				if (error) {
					callback(error);
					return;
				}

				const revisions = [
					{
						id: initialRevisionId,
						hash: getFileHash(content),
						author: currentSession.user,
						lastModifiedTimestamp: new Date().toISOString(),
						// Non-standard, used to combine saves per session
						_editSessionToken: currentSession.editSessionToken,
					},
				];

				// Force save to memory store, or revision ids between loadHistory call of editor and document history service
				// will never match.
				saveHistoryDocument(
					this._cms.saveToStore.bind(this._cms),
					documentId,
					revisions,
					currentSession.editSessionToken,
					(error) => {
						if (error) {
							callback(error);
							return;
						}

						callback(null, revisions);
					}
				);
			}
		);
	}

	save(documentId, content, currentSession, callback) {
		this.loadHistory(
			documentId,
			currentSession.editSessionToken,
			(error, revisions) => {
				if (error) {
					callback(error);
					return;
				}

				// "Update" latest revision if this is the same session, unless it's in the unmergeable revision list.
				const previousRevision = revisions[0];
				if (
					previousRevision &&
					!unmergeableRevisionList.has(previousRevision.id) &&
					previousRevision._editSessionToken ===
						currentSession.editSessionToken
				) {
					this._cms.removeSync(
						path.join('.history', documentId, previousRevision.id)
					);
					revisions.shift();
				}

				const revisionId = uuid();
				revisions.unshift({
					id: revisionId,
					hash: getFileHash(content),
					author: currentSession.user,
					lastModifiedTimestamp: new Date().toISOString(),
					// Non-standard, used to combine saves per session
					_editSessionToken: currentSession.editSessionToken,
				});

				const revisionDocumentId = path.join(
					'.history',
					documentId,
					revisionId
				);
				this._cms.saveToStore(
					revisionDocumentId,
					content,
					currentSession.editSessionToken,
					(error) => {
						if (error) {
							callback(error);
							return;
						}

						saveHistoryDocument(
							this._cms.saveToStore.bind(this._cms),
							documentId,
							revisions,
							currentSession.editSessionToken,
							callback
						);
					}
				);
			}
		);
	}
}
