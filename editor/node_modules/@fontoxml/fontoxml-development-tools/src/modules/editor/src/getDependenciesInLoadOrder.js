import fs from 'fs-extra';
import path from 'path';

export function getPackageManifest(packagePath) {
	const fontoManifestPath = path.join(packagePath, 'fonto-manifest.json');
	if (fs.existsSync(fontoManifestPath)) {
		return fs.readJsonSync(fontoManifestPath);
	}

	return {};
}

function addPackageInfo(packagePath, packageName, packageInfoByPackageName) {
	if (!packagePath) {
		// console.log('packageRoots', packageRoots);
		// console.log('packageName', packageName);
		// console.log('packageInfoByPackageName', packageInfoByPackageName);
		throw new Error(`Package "${packageName}" not found.`);
	}

	let manifest = {};
	let packageInfo;
	try {
		manifest = getPackageManifest(packagePath);
	} catch (error) {
		throw error;
	} finally {
		// Always add the package info, even when we fail.
		packageInfo = {
			dependencies: manifest.dependencies || {},
			importAliases: manifest.importAliases || [],
			name: packageName,
			path: packagePath,
			role: manifest.role,
		};

		packageInfoByPackageName[packageName] = packageInfo;
	}
}

export function addPackageDependencies(
	packageRoots,
	dependencies,
	packageInfoByPackageName
) {
	for (const dependencyName in dependencies) {
		// The source / version specified in the value of the property is only for documentation purposes and is
		// therefore ignored here. See fontoxml-package-manager for a tool to check the consistency of these.
		// eslint-disable-next-line no-use-before-define
		getDependenciesSync(
			packageRoots,
			dependencyName,
			packageInfoByPackageName
		);
	}
}

/**
 * Gather information for a given package and its dependencies from multiple roots
 *
 * @param  {string[]}  packageRoots
 * @param  {string}    packageName
 * @param  {Object}    packageInfoByPackageName  Populated with package info for any package encountered
 */
function getDependenciesSync(
	packageRoots,
	packageName,
	packageInfoByPackageName
) {
	// Check cache
	if (packageInfoByPackageName[packageName]) {
		return;
	}

	// Check package roots
	let packagePath = null;
	for (let i = 0, l = packageRoots.length; i < l; ++i) {
		const candidatePath = path.join(packageRoots[i], packageName);
		if (fs.existsSync(candidatePath)) {
			packagePath = candidatePath;
			break;
		}

		// Try next root
	}

	addPackageInfo(packagePath, packageName, packageInfoByPackageName);

	const packageInfo = packageInfoByPackageName[packageName];
	addPackageDependencies(
		packageRoots,
		packageInfo.dependencies,
		packageInfoByPackageName
	);
}

function findCycles(allPackageNames, packageInfoByPackageName) {
	const stack = [];
	const indexByPackageName = Object.create(null);
	const lowlinkByPackageName = Object.create(null);
	let index = 0;

	function findScc(packageName) {
		indexByPackageName[packageName] = index;
		lowlinkByPackageName[packageName] = index;
		++index;
		stack.push(packageName);

		const dependencies = packageInfoByPackageName[packageName].dependencies;
		if (dependencies) {
			Object.keys(dependencies).forEach((dependencyName) => {
				if (indexByPackageName[dependencyName] === undefined) {
					findScc(dependencyName);
					lowlinkByPackageName[packageName] = Math.min(
						lowlinkByPackageName[packageName],
						lowlinkByPackageName[dependencyName]
					);
				} else if (stack.indexOf(dependencyName) >= 0) {
					// Same SCC
					lowlinkByPackageName[packageName] = Math.min(
						lowlinkByPackageName[packageName],
						indexByPackageName[dependencyName]
					);
				}
			});
		}

		if (
			lowlinkByPackageName[packageName] ===
			indexByPackageName[packageName]
		) {
			const scc = [];
			let packageInCycle;
			do {
				packageInCycle = stack.pop();
				scc.push(packageInCycle);
			} while (packageInCycle !== packageName);

			if (scc.length > 1) {
				// eslint-disable-next-line no-console
				console.log('Cycle:', scc);
			}
		}
	}

	allPackageNames.forEach(function (packageName) {
		if (indexByPackageName[packageName] === undefined) {
			findScc(packageName);
		}
	});
}

function addDependenciesForRoles(packageInfoByPackageName) {
	const allPackageNames = Object.keys(packageInfoByPackageName);
	const addonPackageNames = allPackageNames.filter(
		(packageName) => packageInfoByPackageName[packageName].role === 'add-on'
	);
	allPackageNames.forEach((packageName) => {
		const packageInfo = packageInfoByPackageName[packageName];
		switch (packageInfo.role) {
			case 'internal':
				// All dependencies are explicit
				break;

			case 'add-on':
				// Always depends on the base platform
				if (packageInfoByPackageName['fontoxml-platform-base']) {
					packageInfo.dependencies['fontoxml-platform-base'] =
						packageInfo.dependencies['fontoxml-platform-base'] ||
						'*';
				}
				break;

			case undefined:
				// Always depends on the base platform and all add-ons
				if (packageInfoByPackageName['fontoxml-platform-base']) {
					packageInfo.dependencies['fontoxml-platform-base'] =
						packageInfo.dependencies['fontoxml-platform-base'] ||
						'*';
				}
				addonPackageNames.forEach((addonPackageName) => {
					packageInfo.dependencies[addonPackageName] =
						packageInfo.dependencies[addonPackageName] || '*';
				});
				break;

			default:
				throw new Error(
					`Unknown role "${packageInfo.role}" for package "${packageName}"`
				);
		}
	});
}

export function orderPackages(packageInfoByPackageName) {
	// Topologically sort the list such that each package is loaded after all packages it depends on
	const allPackageNames = Object.keys(packageInfoByPackageName);
	const packageNamesWithNoUnfulfilledDependencies = [];
	const unfulfilledDependencyCountByPackageName = Object.create(null);
	const dependantsByPackageName = Object.create(null);

	// Invert the dependency relations to get dependants
	allPackageNames.forEach((packageName) => {
		const packageInfo = packageInfoByPackageName[packageName];
		const dependencyNames = Object.keys(packageInfo.dependencies || {});

		const numDependencies = dependencyNames.length;
		if (numDependencies) {
			// We need to load these first
			unfulfilledDependencyCountByPackageName[packageName] =
				numDependencies;

			dependencyNames.forEach((dependencyName) => {
				if (dependencyName === packageName) {
					throw new Error(
						`Package "${packageName}" depends on itself!`
					);
				}
				let dependants = dependantsByPackageName[dependencyName];
				if (!dependants) {
					dependants = dependantsByPackageName[dependencyName] = [];
				}
				dependants.push(packageName);
			});
		} else {
			// Package has no unfulfilled dependencies and can be loaded immediately
			packageNamesWithNoUnfulfilledDependencies.push(packageName);
		}
	});

	const packageNamesInLoadOrder = [];

	function fulfillDependency(dependantName) {
		const numRemainingDependencies =
			--unfulfilledDependencyCountByPackageName[dependantName];
		if (!numRemainingDependencies) {
			packageNamesWithNoUnfulfilledDependencies.push(dependantName);
		}
	}

	while (packageNamesWithNoUnfulfilledDependencies.length) {
		const packageNameWithNoUnfulfilledDependencies =
			packageNamesWithNoUnfulfilledDependencies.shift();
		packageNamesInLoadOrder.push(packageNameWithNoUnfulfilledDependencies);

		// Update dependency counts
		const dependants =
			dependantsByPackageName[packageNameWithNoUnfulfilledDependencies];
		if (dependants) {
			dependants.forEach(fulfillDependency);
		}
	}

	if (packageNamesInLoadOrder.length !== allPackageNames.length) {
		// Output debug information
		allPackageNames
			.filter(
				(packageName) =>
					unfulfilledDependencyCountByPackageName[packageName]
			)
			.sort()
			.forEach((packageName) => {
				const unresolvedDependencyNames = Object.keys(
					packageInfoByPackageName[packageName].dependencies
				).filter(
					(unresolvedDependencyName) =>
						unfulfilledDependencyCountByPackageName[
							unresolvedDependencyName
						] > 0
				);

				// eslint-disable-next-line no-console
				console.log(
					packageName,
					'still needs',
					`\n\t${unresolvedDependencyNames.join('\n\t')}`
				);
			});

		findCycles(allPackageNames, packageInfoByPackageName);

		throw new Error(
			'Could not determine package load order due to a circular dependency.'
		);
	}

	return packageNamesInLoadOrder.map(
		(packageName) => packageInfoByPackageName[packageName]
	);
}

export default function getDependenciesInLoadOrder(
	packageRoots,
	initialPackagePath,
	initialPackageName
) {
	// Starting with the initialPackage, gather the full dependency list
	const packageInfoByPackageName = Object.create(null);
	try {
		// Add the initial package.
		addPackageInfo(
			initialPackagePath,
			initialPackageName,
			packageInfoByPackageName
		);
		const initialPackageInfo = packageInfoByPackageName[initialPackageName];
		addPackageDependencies(
			packageRoots,
			initialPackageInfo.dependencies,
			packageInfoByPackageName
		);

		addDependenciesForRoles(packageInfoByPackageName);

		// Now topologically sort these.
		return orderPackages(packageInfoByPackageName);
	} catch (error) {
		error.packageInfos = Object.keys(packageInfoByPackageName).map(
			(packageName) => packageInfoByPackageName[packageName]
		);
		throw error;
	}
}
