import path from 'path';

import webpack from 'webpack';

import getAppConfig from '../getAppConfig.js';
import getAppManifest from '../getAppManifest.js';
import getWebpackConfig from '../getWebpackConfig.js';

function runWebpackBuild(webpackConfig) {
	return new Promise((resolve, reject) => {
		webpack(webpackConfig, (error, stats) => {
			if (error) {
				reject(error);
				return;
			}

			const { errors } = stats.toJson({ all: false, errors: true });
			if (errors.length) {
				const buildError = new Error(
					`Build failed due to ${errors.length} compilation errors.`
				);
				buildError.errors = errors;
				buildError.stats = stats;
				reject(buildError);
				return;
			}

			resolve(stats);
		});
	});
}

export default async function editorBuildCommand(req, res) {
	res.caption(req.command.getLongName());
	res.break();

	const editorPath = req.fdt.editorRepository.path;
	const appConfig = await getAppConfig(editorPath, req.options);
	const appManifest = await getAppManifest(editorPath);

	const mangle = !req.options['no-mangle'];

	res.property('Mangle', mangle ? 'Enabled' : 'Disabled');
	res.break();

	const webpackConfig = getWebpackConfig(appConfig, appManifest, {
		editorModulePath: req.command.getModuleRegistration().getPath(),
		fdtResponse: res,
		inDevelopmentMode: false,
		mangle,
	});

	try {
		const stats = await runWebpackBuild(webpackConfig);
		console.warn(stats.toString(webpackConfig.stats));
	} catch (error) {
		if (error.stats) {
			console.warn(error.stats.toString(webpackConfig.stats));
		}

		throw error;
	}
}
