module.exports = function isAmdDefineCallExpression({ types: t }, path) {
	// Check if path is indeed a CallExpression.
	/* istanbul ignore if */
	if (!t.isCallExpression(path)) {
		return false;
	}

	// Check if the called function is an Identifier named 'define'.
	//
	// Correct:
	//            define();
	// path       ^^^^^^^^^           (CallExpression)
	// callee     ^^^^^^              (Identifier)
	//
	// Incorrect:
	//            something.define();
	// path       ^^^^^^^^^^^^^^^^^^^ (CallExpression)
	// callee     ^^^^^^^^^^^^^^^^    (MemberExpression)
	//  .object   ^^^^^^^^^           (Identifier)
	//  .property           ^^^^^^    (Identifier)
	if (!path.get('callee').isIdentifier({ name: 'define' })) {
		// Not a call to 'define'.
		return false;
	}

	// Check if there is no local binding in the current Program named 'define'.
	//
	// Correct:
	//           define();
	//  path     ^^^^^^^^^              (CallExpression)
	//
	// Incorrect:
	//           function define () {};
	//  binding0          ^^^^^^        (Identifier)
	//           define();
	//  path     ^^^^^^^^^              (CallExpression)
	if (path.scope.hasBinding('define')) {
		// References a local 'define', not the AMD one.
		return false;
	}

	// Fonto AMD modules all inline the factory function in the define call.
	// This avoids processing webpack UMDs; which call define with a reference to the factory (3rd arg).
	//
	// Correct 1:
	//           define(arg0, arg1);
	// path      ^^^^^^^^^^^^^^^^^^^       (CallExpression)
	// arguments        ^^^^^^^^^^         (arguments.length === 2)
	//
	// Correct 2:
	//           define(arg0);
	// arguments        ^^^^               (arguments.length === 1)
	//
	// Incorrect 1:
	//           define(   );
	// arguments        ^^^                (!arguments || arguments.length === 0)
	//
	// Incorrect 2:
	//           define(arg0, arg1, arg2);
	// arguments        ^^^^^^^^^^^^^^^^   (arguments.length > 2)
	const args = path.node.arguments;
	if (!args || args.length === 0 || args.length > 2) {
		return false;
	}

	// Check the dependencies and/or factory function.
	//
	// Correct 1:
	//      define([], function () {});
	// path ^^^^^^^^^^^^^^^^^^^^^^^^^^^   (CallExpression)
	// arg0        ^^                     (ArrayExpression)
	// arg1            ^^^^^^^^^^^^^^     (FunctionExpression)
	//
	// Correct 2:
	//      define(function () {});
	// path ^^^^^^^^^^^^^^^^^^^^^^^       (CallExpression)
	// arg0        ^^^^^^^^^^^^^^         (FunctionExpression)
	//
	// Incorrect 1:
	//      defined(arg1, 'nonFunction');
	// arg0         ^^^^                  (Expression)
	// arg1               ^^^^^^^^^^^^^   (StringLiteral)
	//
	// Incorrect 2:
	//      defined([]);
	// arg0         ^^                    (ArrayExpression)
	return args.length === 1
		? t.isFunctionExpression(args[0])
		: t.isArrayExpression(args[0]) && t.isFunctionExpression(args[1]);
};
