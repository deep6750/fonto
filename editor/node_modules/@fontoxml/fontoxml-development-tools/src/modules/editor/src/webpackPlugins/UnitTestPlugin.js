/** @typedef {import('webpack').Compiler} Compiler */

import {
	addPackageDependencies,
	getPackageManifest,
	orderPackages,
} from '../getDependenciesInLoadOrder.js';

/**
 * This plugin fakes a proper dependency tree for unit tests.
 */
export default class UnitTestPlugin {
	constructor(options) {
		this.options = options;
	}

	/**
	 * @param {Compiler} compiler
	 */
	apply(compiler) {
		compiler.hooks.thisCompilation.tap(
			UnitTestPlugin.name,
			(compilation) => {
				try {
					const packageRootFolders = this.options.packageRootFolders;
					const rootPackageName = this.options.rootPackageName;
					const rootPackagePath = this.options.rootPackagePath;

					if (!compilation.packagesInfoInLoadOrder) {
						compilation.errors.push(
							new Error(
								`Could not get package load order information. Make sure the package exists, and ${UnitTestPlugin.name} runs after the dependencies in load order plugin.`
							)
						);
						return;
					}

					// Map packagesInfoInLoadOrder back to
					// packageInfoByPackageName.
					const packageInfoByPackageName =
						compilation.packagesInfoInLoadOrder.reduce(
							(acc, packageInfo) => {
								acc[packageInfo.name] = packageInfo;
								return acc;
							},
							Object.create(null)
						);

					// Add a virtual package for the tests, as devDependencies
					// may be circular if seen as dependencies of the package
					// itself.
					const manifest = getPackageManifest(rootPackagePath);
					const virtualTestPackageName = `${rootPackageName}-virtual-test-package`;
					const initialPackageInfo = {
						name: virtualTestPackageName,
						role: manifest.role,
						dependencies: {
							[rootPackageName]: '*',
							...(manifest.devDependencies || {}),
						},
					};
					packageInfoByPackageName[virtualTestPackageName] =
						initialPackageInfo;

					// Add additional (dev) dependencies.
					addPackageDependencies(
						packageRootFolders,
						initialPackageInfo.dependencies,
						packageInfoByPackageName
					);

					// Now topologically sort everything again, and filter out
					// the virtual test package.
					compilation.packagesInfoInLoadOrder = orderPackages(
						packageInfoByPackageName
					).filter(
						(packageInfo) =>
							packageInfo.name !== virtualTestPackageName
					);

					compilation.packagesInfoInLoadOrderError = null;

					// Set the package to unit test on the compilation for use
					// in the generated loader.
					compilation.unitTestPackageInfo =
						packageInfoByPackageName[rootPackageName];
				} catch (error) {
					// Do not directly push the error to compilation errors, but
					// let consumers handle errors themselves.
					compilation.packagesInfoInLoadOrder = null;
					compilation.packagesInfoInLoadOrderError = error;
					compilation.unitTestPackageInfo = null;
				}
			}
		);

		compiler.hooks.done.tap(UnitTestPlugin.name, (stats) => {
			if (
				stats.compilation.errors &&
				stats.compilation.errors.length &&
				this.options.inCiMode
			) {
				// Make sure to exit on webpack compilation errors when run in CI mode.
				stats.compilation.errors.forEach(console.error.bind(console));
				process.exit(1);
			}
		});
	}
}
