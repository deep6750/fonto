import os from 'os';
import webpack from 'webpack';

const BUILD_MESSAGE_DEBOUNCE_IN_MS = 100;

function getEndTimestamp(stats) {
	return new Date(
		stats && stats.endTime ? stats.endTime : Date.now()
	).toLocaleTimeString();
}

/**
 * This plugin wraps webpack's output to ensure only the import stuff gets
 * outputted to the command line.
 */
export default class FdtOutputPlugin {
	constructor(options) {
		this.res = options.res;
		this.inDevelopmentMode = !!options.inDevelopmentMode;

		this.hasClearLine =
			typeof this.res.config.stdout.clearLine === 'function';

		this.resetState();
	}

	/**
	 * @param {Error} warning
	 */
	warn(warning) {
		this.warnings.push(warning);
	}

	resetState() {
		this.previousBuildMessageTimestamp = 0;
		this.previousProgressIsBuild = false;
		this.previousRoundedPercentage = null;
		this.warnings = [];
	}

	/**
	 * @param {number}    percentage
	 * @param {string}    message
	 * @param {...string} args
	 */
	progressHandler(percentage, _message, ..._args) {
		if (percentage >= 0.99) {
			return;
		}

		if (this.hasClearLine || !this.previousProgressIsBuild) {
			const roundedPercentage = Math.floor(percentage * 100);
			const buildMessageTimestamp = Date.now();

			// Relax outputting of progress based on previous state.
			if (
				!this.previousProgressIsBuild ||
				(roundedPercentage > this.previousRoundedPercentage &&
					buildMessageTimestamp >
						this.previousBuildMessageTimestamp +
							BUILD_MESSAGE_DEBOUNCE_IN_MS)
			) {
				this.previousBuildMessageTimestamp = buildMessageTimestamp;
				this.previousProgressIsBuild = true;
				this.previousRoundedPercentage = roundedPercentage;

				this.res.needsClearing = true;

				this.res.log(
					this.hasClearLine
						? `Building... ${roundedPercentage}%`
						: `Building...`,
					true
				);
			}
		}
	}

	/**
	 * @param {webpack.Stats} stats
	 */
	doneHandler(stats) {
		this.previousProgressIsBuild = false;
		const endTimestamp = getEndTimestamp(stats);
		const statusPrefix = stats
			? `Build done at ${endTimestamp} in ${
					stats.endTime - stats.startTime
			  }ms`
			: `Build done at ${endTimestamp}`;

		if (
			stats &&
			(stats.hasErrors() || stats.hasWarnings() || this.warnings.length)
		) {
			this.res.needsClearing = true;
			this.res.clearIfNeeded();

			const errorsAndWarnings = stats.toString({
				all: false,
				colors: true,
				errors: true,
				moduleTrace: true,
				warnings: true,
			});
			if (errorsAndWarnings) {
				this.res.raw(errorsAndWarnings);
				this.res.raw(os.EOL);
			}
			if (this.warnings.length) {
				for (const warning of this.warnings) {
					this.res.notice(warning.toString());
					this.res.raw(os.EOL);
				}
			}

			this.res[stats.hasErrors() ? 'error' : 'notice'](
				stats.hasErrors() && stats.hasWarnings()
					? `${statusPrefix}, with errors and warnings.`
					: stats.hasErrors()
					? `${statusPrefix}, with errors.`
					: `${statusPrefix}, with warnings.`,
				false
			);
			this.res.break();

			this.res.needsClearing = false;
			if (this.inDevelopmentMode) {
				this.res.log('Waiting for new changes...', this.hasClearLine);
			}
		} else {
			this.res.needsClearing = true;
			if (this.inDevelopmentMode) {
				this.res.success(
					`${statusPrefix}, waiting for new changes...`,
					this.hasClearLine
				);
			} else {
				this.res.success(
					`${statusPrefix}.
				`,
					false
				);
			}
		}
	}

	failedHandler(error) {
		this.previousProgressIsBuild = false;
		this.res.needsClearing = true;
		const endTimestamp = getEndTimestamp();
		this.res.error(
			`Failed at ${endTimestamp} with error: ${
				error && error.message ? error.message : error
			}`,
			this.hasClearLine
		);
	}

	/**
	 * @param {webpack.Compiler} compiler
	 */
	apply(compiler) {
		// Listen to compile hook before the webpack ProgressPlugin, to reset state.
		compiler.hooks.compile.tap(FdtOutputPlugin.name, () => {
			this.resetState();
		});

		// Use ProgressPlugin to handle most hooks.
		new webpack.ProgressPlugin({
			handler: this.progressHandler.bind(this),
		}).apply(compiler);

		// Listen to done hook and call handler WITH stats, which ProgressPlugin does not do.
		compiler.hooks.done.tap(FdtOutputPlugin.name, (stats) => {
			this.doneHandler(stats);
		});

		// Listen to failed hook and call handler, which ProgressPlugin does not do.
		compiler.hooks.failed.tap(FdtOutputPlugin.name, (error) => {
			this.failedHandler(error);
		});
	}
}
