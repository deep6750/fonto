function combineComments(sourceNodes, type) {
	const comments = [];

	sourceNodes.forEach((sourceNode) => {
		if (!sourceNode || !sourceNode[type]) {
			return;
		}

		sourceNode[type].forEach((comment) => {
			if (!comments.includes(comment)) {
				comments.push(comment);
			}
		});
	});

	return comments;
}

function removeComments(sourceNodes) {
	sourceNodes.forEach((sourceNode) => {
		if (!sourceNode) {
			return;
		}
		if (sourceNode.leadingComments) {
			sourceNode.leadingComments = [];
		}
		if (sourceNode.trailingComments) {
			sourceNode.trailingComments = [];
		}
		if (sourceNode.innerComments) {
			sourceNode.innerComments = [];
		}
		if (sourceNode.comments) {
			sourceNode.comments = [];
		}
	});
}

function changeCommentType(comment, type) {
	switch (type) {
		case 'leading':
			comment.leading = true;
			comment.trailing = false;
			break;
		case 'trailing':
			comment.leading = false;
			comment.trailing = true;
			break;
		/* istanbul ignore next */
		default:
			throw new Error(`Cannot convert to comment type "${type}".`);
	}
}

function moveCommentsAsIs({ types: t }, destinationNode, ...sourceNodes) {
	let isSplitDestination = false;
	if (Array.isArray(destinationNode)) {
		/* istanbul ignore if */
		if (destinationNode.length !== 2) {
			throw new Error(
				'Destination node should be a node or an array with two nodes.'
			);
		}

		isSplitDestination = true;
	}

	const leadingComments = combineComments(sourceNodes, 'leadingComments');
	const trailingComments = combineComments(
		sourceNodes.slice().reverse(),
		'trailingComments'
	);
	const innerComments = combineComments(sourceNodes, 'innerComments');
	const comments = combineComments(sourceNodes, 'comments');

	const leadingDestination = isSplitDestination
		? destinationNode[0]
		: destinationNode;
	const trailingDestination = isSplitDestination
		? destinationNode[1]
		: destinationNode;

	// Add comments to the destination.
	t.addComments(leadingDestination, 'leading', leadingComments);
	t.addComments(trailingDestination, 'trailing', trailingComments);
	t.addComments(leadingDestination, 'inner', innerComments);

	leadingDestination.comments = [].concat(
		comments.filter((comment) => {
			return comment.leading || (!comment.leading && !comment.trailing);
		}),
		leadingDestination.comments || []
	);
	trailingDestination.comments = [].concat(
		trailingDestination.comments || [],
		comments
			.slice()
			.reverse()
			.filter((comment) => {
				return comment.trailing && !comment.leading;
			})
	);

	// Remove the comments from the sources.
	removeComments(sourceNodes);
}

function moveCommentsAsLeading({ types: t }, destinationNode, ...sourceNodes) {
	const leadingComments = [
		...combineComments(sourceNodes, 'leadingComments'),
		...combineComments(sourceNodes.slice().reverse(), 'trailingComments'),
	];
	const innerComments = combineComments(sourceNodes, 'innerComments');
	let comments = combineComments(sourceNodes, 'comments');
	comments = [].concat(
		comments.filter((comment) => comment.leading && !comment.trailing),
		comments.filter((comment) => !comment.leading && !comment.trailing),
		comments
			.slice()
			.reverse()
			.filter((comment) => comment.trailing && !comment.leading)
	);

	// Change all non inner comments to leading.
	leadingComments.forEach((comment) => changeCommentType(comment, 'leading'));
	comments.forEach((comment) => changeCommentType(comment, 'leading'));

	// Add comments to the destination.
	t.addComments(destinationNode, 'leading', leadingComments);
	t.addComments(destinationNode, 'inner', innerComments);
	destinationNode.comments = [].concat(
		comments,
		destinationNode.comments || []
	);
}

function moveCommentsAsTrailing({ types: t }, destinationNode, ...sourceNodes) {
	const trailingComments = [
		...combineComments(sourceNodes, 'leadingComments'),
		...combineComments(sourceNodes.slice().reverse(), 'trailingComments'),
	];
	const innerComments = combineComments(sourceNodes, 'innerComments');
	let comments = combineComments(sourceNodes, 'comments');
	comments = [].concat(
		comments.filter((comment) => comment.leading && !comment.trailing),
		comments.filter((comment) => !comment.leading && !comment.trailing),
		comments
			.slice()
			.reverse()
			.filter((comment) => comment.trailing && !comment.leading)
	);

	// Change all non inner comments to trailing.
	trailingComments.forEach((comment) =>
		changeCommentType(comment, 'trailing')
	);
	comments.forEach((comment) => changeCommentType(comment, 'trailing'));

	// Add comments to the destination.
	t.addComments(destinationNode, 'trailing', trailingComments);
	t.addComments(destinationNode, 'inner', innerComments);
	destinationNode.comments = [].concat(
		comments,
		destinationNode.comments || []
	);
}

module.exports = {
	asIs: (babel, destinationNode, ...sourceNodes) => {
		moveCommentsAsIs(babel, destinationNode, ...sourceNodes);

		// Remove the comments from the sources.
		removeComments(sourceNodes);
	},

	asLeading: (babel, destinationNode, ...sourceNodes) => {
		moveCommentsAsLeading(babel, destinationNode, ...sourceNodes);

		// Remove the comments from the sources.
		removeComments(sourceNodes);
	},

	asTrailing: (babel, destinationNode, ...sourceNodes) => {
		moveCommentsAsTrailing(babel, destinationNode, ...sourceNodes);

		// Remove the comments from the sources.
		removeComments(sourceNodes);
	},
};
