import fs from 'fs-extra';
import path from 'path';

export default async function updateEditorPackageJson(
	outputDir,
	warningsByFilename
) {
	const packageJsonFilePath = path.join(outputDir, 'package.json');

	try {
		await fs.access(packageJsonFilePath, fs.constants.F_OK);
	} catch (_error) {
		// Skip package.json update when there is no package.json file.
		return;
	}

	try {
		const packageJson = await fs.readJson(packageJsonFilePath);

		if (packageJson.devDependencies) {
			delete packageJson.devDependencies['fontoxml-build'];
			delete packageJson.devDependencies['fontoxml-dev-server'];
		}

		if (packageJson.scripts) {
			const defaultScripts = {
				build: 'node ./node_modules/fontoxml-build/bin/fontoxml-build',
				'build-server':
					'node ./node_modules/fontoxml-dev-server/bin/fontoxml-dev-server --dist',
				server: 'node ./node_modules/fontoxml-dev-server/bin/fontoxml-dev-server',
			};

			Object.keys(defaultScripts).forEach((script) => {
				if (packageJson.scripts[script] === defaultScripts[script]) {
					delete packageJson.scripts[script];
				} else {
					warningsByFilename.add(
						packageJsonFilePath,
						new Error(
							`${packageJsonFilePath}: There is a custom implementation for the \`npm run ${script}\` command, a manual fix may be required.`
						)
					);
				}
			});
		}

		await fs.writeJson(packageJsonFilePath, packageJson, { spaces: '  ' });
	} catch (error) {
		error.message = `${packageJsonFilePath}: ${error.message}`;
		warningsByFilename.add(packageJsonFilePath, error);
	}
}
