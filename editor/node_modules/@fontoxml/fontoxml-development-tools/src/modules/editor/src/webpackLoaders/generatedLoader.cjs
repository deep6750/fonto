const fastGlob = require('fast-glob');
const fs = require('fs-extra');
const path = require('path');

function getPatternsForSpecialFileType(type) {
	switch (type) {
		case 'configureSxModule':
			return ['src/configureSxModule.@(js|ts)', 'src/*.xqm'];
		case 'install':
			return ['src/operations?(-*).json', 'src/install.@(js|ts)'];
		case 'messages':
			return ['src/messages.*.json'];
		case 'setDefaultConfiguration':
			return ['src/setDefaultConfiguration.@(js|ts)'];
		case 'styles':
			return ['src/styles.css'];
		case 'unitTestConfiguration':
			return ['test/configuration.@(js|ts)'];
		case 'unitTestSmokeTest':
			return ['src/*.@(js|jsx|ts|tsx)', '!src/*.d.ts'];
		case 'unitTestSpecs':
			return ['test/**/*.tests.@(js|ts)'];
		case 'unitTestConfigurationManager':
			return [];
		default:
			throw new Error(`Unsupported special file type "${type}".`);
	}
}

/**
 * Converts input in snake case (such-as-this, or_like_this) to camel case (suchAsThis, orLikeThis).
 *
 * @param   {string}  input
 * @param   {string}  [separator]  The snake case separator (defaults to - (a dash)).
 *
 * @return  {string}
 */
function fromSnakeCaseToCamelCase(input, separator) {
	separator = separator || '-';

	// Matches segments starting with the given separator, followed by 1 character.
	return input.toLowerCase().replace(
		new RegExp(`${separator}(.)`, 'g'),
		// Replaces matches from the regExp with the upper cased character after the separator.
		(_matchingSegment, firstCaptureGroup) => firstCaptureGroup.toUpperCase()
	);
}

async function getImportsForPackages(
	packagesInfo,
	patterns,
	disallowedExtensions
) {
	return await Promise.all(
		packagesInfo.map(async (packageInfo) => {
			const posixFilepaths = await fastGlob(patterns, {
				cwd: packageInfo.path,
			});

			if (!posixFilepaths.length) {
				return false;
			}

			return posixFilepaths.sort().map((posixFilePath) => {
				const importPath = path.posix.join(
					packageInfo.name,
					posixFilePath
				);
				const postfix = path.posix
					.basename(importPath, path.posix.extname(importPath))
					.replace(/[^\w\d]/g, '_');
				const importIdentifier = fromSnakeCaseToCamelCase(
					`${packageInfo.name}-${postfix}`
				);
				return {
					identifier: importIdentifier,
					name: packageInfo.name,
					path: importPath,
				};
			});
		})
	).then((results) => {
		return results.reduce((flattenedResults, resultSet) => {
			if (resultSet) {
				resultSet.forEach((result) => {
					const parsedResultPath = path.posix.parse(result.path);
					if (disallowedExtensions.includes(parsedResultPath.ext)) {
						result.path = path.posix.join(
							parsedResultPath.dir,
							parsedResultPath.name
						);
					}
					flattenedResults.push(result);
				});
			}
			return flattenedResults;
		}, []);
	});
}

async function webpackAddDependencies(
	loaderContext,
	options,
	packageInfos = []
) {
	await Promise.all(
		packageInfos.map(async (packageInfo) => {
			const packagePath = path.normalize(packageInfo.path);

			if (
				packagePath ===
				path.join(options.platformFolder, packageInfo.name)
			) {
				return;
			}

			if (packageInfo.name === 'config') {
				loaderContext.addContextDependency(packagePath);
			} else {
				const srcFolderPath = path.join(packagePath, 'src');
				const hasSrcFolder = await fs.pathExists(srcFolderPath);

				if (hasSrcFolder) {
					loaderContext.addContextDependency(srcFolderPath);
				} else {
					loaderContext.addMissingDependency(srcFolderPath);
				}
			}

			const fontoManifestPath = path.join(
				packagePath,
				'fonto-manifest.json'
			);
			const hasManifest = await fs.pathExists(fontoManifestPath);

			if (hasManifest) {
				loaderContext.addDependency(fontoManifestPath);
			} else {
				loaderContext.addMissingDependency(fontoManifestPath);
			}
		})
	);
}

async function handleDependencyOrder({
	loaderContext,
	inputMap,
	options,
	type,
	callback,
}) {
	loaderContext.cacheable(true);

	const patterns = getPatternsForSpecialFileType(type);

	if (
		loaderContext._compilation.packagesInfoInLoadOrderError ||
		!loaderContext._compilation.packagesInfoInLoadOrder
	) {
		const error =
			loaderContext._compilation.packagesInfoInLoadOrderError ||
			new Error('Could not get package load order information.');
		await webpackAddDependencies(
			loaderContext,
			options,
			error.packageInfos
		);
		return callback(error);
	}

	const packagesInfoInLoadOrder =
		loaderContext._compilation.packagesInfoInLoadOrder;

	await webpackAddDependencies(
		loaderContext,
		options,
		packagesInfoInLoadOrder
	);

	const statements = await getImportsForPackages(
		packagesInfoInLoadOrder,
		patterns,
		options.disallowedExtensions
	);

	let code;
	if (type === 'configureSxModule') {
		const statementsByName = statements.reduce(
			(statementsByName, statement) => {
				statementsByName[statement.name] =
					statementsByName[statement.name] || [];
				statementsByName[statement.name].push(statement);
				return statementsByName;
			},
			Object.create(null)
		);

		code = `import sxManager from 'fontoxml-modular-schema-experience/src/sxManager';\n`;
		code += `import registerXQueryModule from 'fontoxml-selectors/src/registerXQueryModule';`;
		code += `\n\n${statements
			.map((statement) => {
				return `import ${statement.identifier} from '${statement.path}';`;
			})
			.join('\n')}`;
		code += `\n\n${packagesInfoInLoadOrder
			.map((packageInfo) => {
				const dependencies = Object.keys(packageInfo.dependencies)
					.map((dependency) => `'${dependency}'`)
					.join(', ');
				const addModule = `sxManager.addModule('${packageInfo.name}', [${dependencies}])`;

				const statements = statementsByName[packageInfo.name] || [];
				let hasConfigureSxModule = false;
				const statementsOutput = statements
					.sort((statementA, statementB) => {
						// Make sure .xqm files are registered first.
						if (
							statementA.path.endsWith('.xqm') &&
							statementB.path.endsWith('.xqm')
						) {
							return 0;
						}
						if (statementA.path.endsWith('.xqm')) {
							return -1;
						}
						if (statementB.path.endsWith('.xqm')) {
							return 1;
						}
						return 0;
					})
					.map((statement) => {
						if (statement && statement.path.endsWith('.xqm')) {
							return `registerXQueryModule(${statement.identifier});`;
						}

						hasConfigureSxModule = true;
						return `${statement.identifier}(${addModule});`;
					});

				if (!hasConfigureSxModule) {
					statementsOutput.push(`${addModule};`);
				}

				return statementsOutput.join('\n');
			})
			.join('\n')}`;
	} else if (type === 'install') {
		code = `import operationsManager from 'fontoxml-operations/src/operationsManager';`;
		code += `\n\n${statements
			.map(
				(statement) =>
					`import ${statement.identifier} from '${statement.path}';`
			)
			.join('\n')}`;
		code += `\n\n${statements
			.map((statement) => {
				if (path.extname(statement.path) === '.json') {
					return `operationsManager.addOperations(${statement.identifier});`;
				}
				return `${statement.identifier}();`;
			})
			.join('\n')}`;
	} else if (type === 'messages') {
		code = `import localizationManager from 'fontoxml-localization/src/localizationManager';`;
		code += `\n\n${statements
			.map(
				(statement) =>
					`import ${statement.identifier} from '${statement.path}';`
			)
			.join('\n')}`;
		code += `\n\n${statements
			.map((statement) => {
				const locale = path.basename(statement.path).split('.')[1];
				return `localizationManager.addMessages('${locale}', ${statement.identifier});`;
			})
			.join('\n')}`;
	} else if (type === 'setDefaultConfiguration') {
		code = statements
			.map(
				(statement) =>
					`import ${statement.identifier} from '${statement.path}';`
			)
			.join('\n');
		code += `\n\n${statements
			.map((statement) => `${statement.identifier}();`)
			.join('\n')}`;
	} else if (type === 'styles') {
		code = statements
			.map((statement) => `import '${statement.path}';`)
			.join('\n');
	}

	code = code.trim();
	code = code.length ? `${code}\n` : code;
	return callback(null, code, inputMap);
}

async function handleUnitTest({
	loaderContext,
	inputMap,
	options,
	type,
	callback,
}) {
	loaderContext.cacheable(true);

	const patterns = getPatternsForSpecialFileType(type);

	const unitTestPackageInfo = loaderContext._compilation.unitTestPackageInfo;
	if (
		loaderContext._compilation.packagesInfoInLoadOrderError ||
		!unitTestPackageInfo
	) {
		const error =
			loaderContext._compilation.packagesInfoInLoadOrderError ||
			new Error('Unit test package could not be found.');
		return callback(error);
	}

	const statements = await getImportsForPackages(
		[unitTestPackageInfo],
		patterns,
		options.disallowedExtensions
	);

	let code;
	if (type === 'unitTestSmokeTest') {
		if (!statements.length) {
			code =
				'describe("Test runner: load public files", () => { it("exists (but it has no public src files)", () => {}); });';
		} else {
			code = `
			describe('Test runner: load public files', () => {
				it('exists', () => {});

				${statements
					.map((statement) => {
						const filename = path.posix.join(
							...statement.path.split('/').slice(2)
						);
						return `
							it('${filename} can be loaded', () => {
								try {
									require('${statement.path}');
								} catch (error) {
									chai.assert.fail(
										'File could not be loaded',
										'File should be able to be loaded',
										'Unable to load "${filename}": ' + error
									);
								}
							}).timeout(5000);
						`;
					})
					.join('\n')}
			});
			`;
		}
	} else if (type === 'unitTestSpecs') {
		if (!statements.length) {
			code =
				'describe("Test runner: load test files", () => { it("exists (but it has no test spec files)", () => {}); });';
		} else {
			code = `
				const testSpecsRequireErrors = [];
				${statements
					.map((statement) => {
						const filename = path.posix.join(
							...statement.path.split('/').slice(2)
						);
						return `
							try {
								require('${statement.path}');
							} catch (error) {
								testSpecsRequireErrors.push({ key: '${filename}', error });
							}
						`;
					})
					.join('\n')}
				if (testSpecsRequireErrors.length) {
					describe('Test runner: load test files', function() {
						testSpecsRequireErrors.forEach(keyWithError => {
							it(keyWithError.key + ' can be loaded', () => {
								chai.assert.fail(
									'File could not be loaded',
									'File should be able to be loaded',
									'Unable to load test "' + keyWithError.key + '": ' + keyWithError.error
								);
							});
						});
					});
				}
			`;
		}
	} else if (type === 'unitTestConfiguration') {
		code = statements
			.map((statement) => `import '${statement.path}';`)
			.join('\n');
	} else if (type === 'unitTestConfigurationManager') {
		// packagesInfoInLoadOrder is filtered for the unit test types, so get them all again.
		const allPackagesInfoInLoadOrder =
			loaderContext._compilation.packagesInfoInLoadOrder;

		// Check if we depend on the fontoxml-configuration package.
		const dependsOnFontoxmlConfigurationPackage =
			allPackagesInfoInLoadOrder.find(
				(packageInfo) => packageInfo.name === 'fontoxml-configuration'
			);

		const useConfigurationManager = !!dependsOnFontoxmlConfigurationPackage;
		code = useConfigurationManager
			? `export { default } from 'fontoxml-configuration/src/configurationManager';`
			: `export default null;`;
	}

	code = code.trim();
	code = code.length ? `${code}\n` : code;
	return callback(null, code, inputMap);
}

async function handleVersionInfo({
	loaderContext,
	inputMap,
	options,
	callback,
}) {
	loaderContext.cacheable(false);

	const appManifest = options.appManifest;
	const versionInfo = {
		sdkVersion: appManifest.sdkVersion
			? appManifest.sdkVersion.format()
			: null,
		sdkBuildDate: appManifest.sdkBuildDate || null,
		appBuildDate: new Date().toISOString(),
	};

	const code = `export default ${JSON.stringify(versionInfo)};\n`;

	return callback(null, code, inputMap);
}

async function handleDebugBuild({
	_loaderContext,
	inputMap,
	options,
	callback,
}) {
	const code = `export default ${JSON.stringify(options.isDebugBuild)};\n`;

	return callback(null, code, inputMap);
}

module.exports = async function generatedLoader(input, inputMap) {
	const resourceQuery = new URLSearchParams(this.resourceQuery.slice(1));
	const type = resourceQuery.get('type');
	const callback = this.async();

	const handlerOptions = {
		loaderContext: this,
		input,
		inputMap,
		options: this.getOptions(),
		type,
		callback,
	};

	switch (type) {
		case 'configureSxModule':
		case 'install':
		case 'messages':
		case 'setDefaultConfiguration':
		case 'styles':
			return handleDependencyOrder(handlerOptions);
		case 'unitTestConfiguration':
		case 'unitTestSmokeTest':
		case 'unitTestSpecs':
		case 'unitTestConfigurationManager':
			return handleUnitTest(handlerOptions);
		case 'versionInfo':
			return handleVersionInfo(handlerOptions);
		case 'debugBuild':
			return handleDebugBuild(handlerOptions);
		default:
			throw new Error(
				`Unsupported generated type "${resourceQuery.type}".`
			);
	}
};
