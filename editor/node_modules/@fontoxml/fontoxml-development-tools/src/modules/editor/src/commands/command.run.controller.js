import compression from 'compression';
import express from 'express';
import webpack from 'webpack';
import middleware from 'webpack-dev-middleware';

import setupDevCms from '../../dev-cms/setupDevCms.js';
import getAppConfig from '../getAppConfig.js';
import getAppManifest from '../getAppManifest.js';
import getWebpackConfig from '../getWebpackConfig.js';
import getWebpackDevMiddlewareConfig from '../getWebpackDevMiddlewareConfig.js';

async function runDistServer(appConfig, res) {
	try {
		const server = express();
		server.use(compression());
		server.use(await setupDevCms(appConfig));

		await new Promise((resolve, reject) => {
			server.listen(appConfig.port, (error) => {
				if (error) {
					reject(error);
					return;
				}
				resolve();
			});
		});
	} catch (error) {
		res.destroyAllSpinners();
		res.break();
		res.error('An error occurred while starting the development server.');
		throw error;
	}
}

async function runWebpackDevServer(webpackConfig, appConfig, res) {
	try {
		const server = express();
		server.use(compression());
		server.use(await setupDevCms(appConfig));

		// Server has not actually started, but for the sake of output, it is done.
		res.destroyAllSpinners();
		res.break();

		// Manually closing the compiler is optional when using webpack in watching
		// mode until the user ends the process.
		// See: https://webpack.js.org/migrate/5/#cleanup-the-build-code
		server.use(
			middleware(
				webpack(webpackConfig),
				getWebpackDevMiddlewareConfig(appConfig)
			)
		);

		await new Promise((resolve, reject) => {
			server.listen(appConfig.port, '0.0.0.0', (error) => {
				if (error) {
					reject(error);
					return;
				}
				server.on('close', () => {
					resolve();
				});
			});
		});
	} catch (error) {
		res.destroyAllSpinners();
		res.break();
		res.error('An error occurred while starting the development server.');
		throw error;
	}
}

export default async function editorRunCommand(req, res) {
	res.caption(req.command.getLongName());

	const editorPath = req.fdt.editorRepository.path;
	const appConfig = await getAppConfig(editorPath, req.options);
	const appManifest = await getAppManifest(editorPath);

	// Output most app config values.
	const optionsOutput = Object.assign(
		// Scope config.
		appConfig.scope
			? {
					Documents: appConfig.scope.documentIds
						? appConfig.scope.documentIds.join(', ')
						: 'The scope does not contain any documentIds',
			  }
			: {},
		// Server config.
		{
			URL: `http://localhost:${appConfig.port}`,
			'Cache-Control': appConfig.cacheControlDisabled
				? 'Disabled'
				: `${appConfig.cacheControlMaxAge / 1000}s`,
			Delay: `${appConfig.delay}ms`,
			'Body parser limit': appConfig.bodyParserLimit,
		},
		// Save config.
		{
			'Save mode': `${appConfig.saveMode}${
				appConfig.alwaysRegenerateSessionToken
					? '\nWith "always regenerate session token" enabled'
					: ''
			}${
				appConfig.saveMode.endsWith('-memory')
					? `\nMemory store TTL ${`${
							appConfig.memoryStoreTtl / 1000
					  }s`}`
					: ''
			}`,
		},
		// Lock config, excluding lockReason.
		{
			'Load lock': `${
				appConfig.documentLoadLock.isLockAcquired
					? 'acquired'
					: 'not acquired'
			}\n${
				appConfig.documentLoadLock.isLockAvailable
					? 'available'
					: 'not available'
			}${
				appConfig.documentLoadLock.releaseLocksOnStateRequest
					? '\nReleasing locks on state requests'
					: ''
			}`,
		},
		// Proxy config.
		appConfig.proxy
			? {
					Proxies: Object.keys(appConfig.proxy)
						.map((proxy) => {
							return `${proxy} [${appConfig.proxy[proxy]}]`;
						})
						.join('\n'),
			  }
			: {}
	);

	res.properties(optionsOutput);
	res.break();

	if (appConfig.dist) {
		const destroySpinner = res.spinner(
			`Starting development server in dist mode${
				appConfig.distAuth ? ' with authentication' : ''
			}...`
		);

		await runDistServer(appConfig, res);

		destroySpinner();

		res.break();
		res.success('Development server is running.');

		return;
	}

	const webpackConfig = getWebpackConfig(appConfig, appManifest, {
		editorModulePath: req.command.getModuleRegistration().getPath(),
		fdtResponse: res,
		inDevelopmentMode: true,
		outputFolder: 'dev',
	});

	res.spinner('Starting development server...');

	await runWebpackDevServer(webpackConfig, appConfig, res);
}
