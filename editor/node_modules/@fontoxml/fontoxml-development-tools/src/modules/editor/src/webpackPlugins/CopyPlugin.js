/** @typedef {import('webpack').Compiler} Compiler */

import fastGlob from 'fast-glob';
import fs from 'fs-extra';
import path from 'path';
import webpack from 'webpack';

import normalisePath from '../helpers/normalisePath.js';

/**
 * This plugin add assets to the compilation which do not exist in the
 * dependency tree ('assets' folders of packages).
 */
export default class CopyPlugin {
	constructor(options) {
		this.options = options;
	}

	/**
	 * @param {Compiler} compiler
	 */
	apply(compiler) {
		const emittedAssets = new Map();

		let packageInfos;

		compiler.hooks.thisCompilation.tap(CopyPlugin.name, (compilation) => {
			compilation.hooks.additionalAssets.tapPromise(
				CopyPlugin.name,
				async () => {
					if (
						compilation.packagesInfoInLoadOrderError ||
						!compilation.packagesInfoInLoadOrder
					) {
						const error =
							compilation.packagesInfoInLoadOrderError ||
							new Error(
								'Could not get package load order information.'
							);
						packageInfos = error.packageInfos || [];
						compilation.errors.push(error);
						return;
					}

					const templatesPath = normalisePath(
						path.resolve(this.options.bootstrapFolder, 'templates')
					);
					const assetInfoByTargetPath = new Map();

					// TODO: It's not stricly necessary to process these assets
					// every (re)compile.
					// TODO: Consider placing these assets somewhere where
					// they're unlikely to cause conflicts.
					(
						await fastGlob(
							[
								`${fastGlob.escapePath(
									templatesPath
								)}/assets/**/*`,
							],
							{
								absolute: true,
								stats: true,
							}
						)
					).forEach((globResult) => {
						assetInfoByTargetPath.set(
							normalisePath(
								path.relative(templatesPath, globResult.path)
							),
							{
								path: globResult.path,
								stats: globResult.stats,
							}
						);
					});

					if (this.options.unitTest) {
						const testAssetsPath = this.options.contextFolder;
						(
							await fastGlob(
								[
									`${fastGlob.escapePath(
										testAssetsPath
									)}test/assets/**/*`,
								],
								{
									absolute: true,
									stats: true,
								}
							)
						).forEach((globResult) => {
							const targetPath = normalisePath(
								path.relative(
									path.join(
										this.options.contextFolder,
										'test'
									),
									globResult.path
								)
							);
							assetInfoByTargetPath.set(targetPath, {
								path: globResult.path,
								stats: globResult.stats,
							});
						});
					}

					packageInfos = compilation.packagesInfoInLoadOrder;

					(
						await Promise.all(
							packageInfos.map(async (packageInfo) => {
								const glob =
									fastGlob.escapePath(
										normalisePath(packageInfo.path)
									) +
									(packageInfo.name === 'config'
										? '/assets/**/*'
										: '/src/assets/**/*');

								return await fastGlob([glob], {
									absolute: true,
									stats: true,
								});
							})
						)
					).reduce((map, globResults) => {
						globResults.forEach((globResult) => {
							const relativePath = normalisePath(
								path.relative(
									this.options.contextFolder,
									globResult.path
								)
							);
							const pathParts = relativePath.split(
								path.posix.sep
							);
							const isRootPackage =
								relativePath.startsWith('config') ||
								(this.options.unitTest &&
									relativePath.startsWith('src/'));
							const targetPath = path.posix.join(
								...pathParts.slice(isRootPackage ? 1 : 3)
							);

							map.set(targetPath, {
								path: globResult.path,
								stats: globResult.stats,
							});
						});

						return map;
					}, assetInfoByTargetPath);

					await Promise.all(
						[...emittedAssets.keys()].map(async (targetPath) => {
							if (!assetInfoByTargetPath.has(targetPath)) {
								const assetOutputPath = path.join(
									compilation.getPath(compiler.outputPath),
									targetPath
								);

								await new Promise((resolve, reject) =>
									compiler.outputFileSystem.unlink(
										assetOutputPath,
										(error) =>
											error ? reject(error) : resolve()
									)
								);

								emittedAssets.delete(targetPath);
							}
						})
					);

					await Promise.all(
						[...assetInfoByTargetPath.keys()].map(
							async (targetPath) => {
								const assetInfo =
									assetInfoByTargetPath.get(targetPath);

								if (
									emittedAssets.has(targetPath) &&
									emittedAssets.get(targetPath).path ===
										assetInfo.path &&
									emittedAssets.get(targetPath).stats
										.mtimeMs === assetInfo.stats.mtimeMs
								) {
									return;
								}

								emittedAssets.set(targetPath, assetInfo);

								const content = await fs.readFile(
									assetInfo.path
								);

								compilation.emitAsset(
									targetPath,
									new webpack.sources.RawSource(content)
								);
							}
						)
					);
				}
			);
		});

		compiler.hooks.afterEmit.tapPromise(
			CopyPlugin.name,
			async (compilation) => {
				await Promise.all(
					packageInfos.map(async (packageInfo) => {
						const packagePath = path.normalize(packageInfo.path);

						if (
							packagePath ===
							path.join(
								this.options.platformFolder,
								packageInfo.name
							)
						) {
							return;
						}

						if (packageInfo.name === 'config') {
							compilation.contextDependencies.add(packagePath);
						} else {
							const srcFolderPath = path.join(packagePath, 'src');
							const hasSrcFolder = await fs.pathExists(
								srcFolderPath
							);

							if (hasSrcFolder) {
								compilation.contextDependencies.add(
									srcFolderPath
								);
							} else {
								compilation.missingDependencies.add(
									srcFolderPath
								);
							}
						}

						const fontoManifestPath = path.join(
							packagePath,
							'fonto-manifest.json'
						);
						const hasManifest = await fs.pathExists(
							fontoManifestPath
						);

						if (hasManifest) {
							compilation.fileDependencies.add(fontoManifestPath);
						} else {
							compilation.missingDependencies.add(
								fontoManifestPath
							);
						}
					})
				);
			}
		);
	}
}
