/** @typedef {import('webpack').Compiler} Compiler */

import { importAliases as legacyImportAliases } from '../config.js';

/**
 * This plugin resolves special import aliases to their actual location on disk,
 * e.g. 'fds/components' to 'fontoxml-vendors/src/fds/components'.
 */
export default class ResolveImportAliasPlugin {
	inDevelopmentMode;

	constructor(options) {
		this.inDevelopmentMode = options.inDevelopmentMode || false;
	}

	_addImportAlias(importAliases, importAlias) {
		importAliases.set(
			importAlias.alias,
			(this.inDevelopmentMode && importAlias.devImport) ||
				importAlias.import
		);
	}

	/**
	 * @param {Compiler} compiler
	 */
	apply(compiler) {
		const importAliases = new Map();

		// On each compilation, gather all import aliases as early as possible
		// and store them so they can be used in the resolver plugin below.
		compiler.hooks.thisCompilation.tap(
			ResolveImportAliasPlugin.name,
			(compilation) => {
				// Start with a clean slate for each compilation.
				importAliases.clear();

				// Add hardcoded import aliases for backward compatibility.
				legacyImportAliases.forEach((importAlias) =>
					this._addImportAlias(importAliases, importAlias)
				);

				if (
					compilation.packagesInfoInLoadOrderError ||
					!compilation.packagesInfoInLoadOrder
				) {
					compilation.errors.push(
						compilation.packagesInfoInLoadOrderError ||
							new Error(
								'ResolveImportAliasPlugin: could not retrieve package load order information.'
							)
					);
					return;
				}

				// Extract import aliases from package manifest files in
				// dependency order.
				compilation.packagesInfoInLoadOrder.forEach((packagesInfo) => {
					if (!Array.isArray(packagesInfo.importAliases)) {
						compilation.errors.push(
							new Error(
								`ResolveImportAliasPlugin: skipped "${packagesInfo.name}"; "importAliases" should be an array.`
							)
						);
						return;
					}

					packagesInfo.importAliases.forEach((importAlias) => {
						if (
							typeof importAlias.alias !== 'string' ||
							typeof importAlias.import !== 'string'
						) {
							compilation.errors.push(
								new Error(
									`ResolveImportAliasPlugin: invalid alias in "${packagesInfo.name}"; use the following format: { "alias": "my-alias", "import": "package/src/file" }.`
								)
							);
							return;
						}

						this._addImportAlias(importAliases, importAlias);
					});
				});
			}
		);

		compiler.resolverFactory.hooks.resolver
			.for('normal')
			.tap(ResolveImportAliasPlugin.name, (resolver) => {
				const target = resolver.ensureHook('resolve');
				resolver.getHook('resolve').tapAsync(
					// Loosely based on Webpack's own alias resolve plugin.
					// See: https://github.com/webpack/enhanced-resolve/blob/main/lib/AliasPlugin.js
					ResolveImportAliasPlugin.name,
					(request, resolveContext, callback) => {
						const innerRequest = request.request || request.path;

						if (!innerRequest) {
							return callback();
						}

						if (!importAliases.has(innerRequest)) {
							return callback();
						}

						const updatedRequest = {
							...request,
							fullySpecified: false,
							request: importAliases.get(innerRequest),
						};

						return resolver.doResolve(
							target,
							updatedRequest,
							`aliased '${innerRequest}' to '${updatedRequest.request}'`,
							resolveContext,
							(err, result) => {
								if (err) {
									return callback(err);
								}

								// Don't allow other aliasing or raw request.
								if (result === undefined) {
									return callback(undefined, null);
								}

								callback(undefined, result);
							}
						);
					}
				);
			});
	}
}
