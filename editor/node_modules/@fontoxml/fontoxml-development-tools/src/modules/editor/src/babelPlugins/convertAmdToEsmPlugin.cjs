const getClosestNodeWithOffset = require('../astHelpers/getClosestNodeWithOffset.cjs');
const getDescendantNodes = require('../astHelpers/getDescendantNodes.cjs');
const hasMultipleReturnStatements = require('../astHelpers/hasMultipleReturnStatements.cjs');
const isAmdDefineCallExpression = require('../astHelpers/isAmdDefineCallExpression.cjs');
const isAmdFactoryReturnStatement = require('../astHelpers/isAmdFactoryReturnStatement.cjs');
const isInteropDefaultExpressionStatement = require('../astHelpers/isInteropDefaultExpressionStatement.cjs');
const moveComments = require('../astHelpers/moveComments.cjs');

module.exports = (babel, options, _cwd) => {
	const { types: t } = babel;

	function getImportSpecifiers(
		filePath,
		importSource,
		importIdentifier,
		factoryFunctionBodyPath
	) {
		const source = importSource.value;

		// Not a .jsx  import so import as DefaultSpecifier.
		if (!source.endsWith('.jsx.js') && !source.endsWith('.jsx')) {
			return [t.importDefaultSpecifier(importIdentifier)];
		}

		// Collect all MemberExpressions where importIdentifier is the object.
		const importMemberUsages = [];
		const identifierNames = [];
		const assignmentPaths = [];
		factoryFunctionBodyPath.traverse({
			AssignmentExpression(path) {
				if (!isInteropDefaultExpressionStatement(path)) {
					return;
				}

				const identifierPath = path.get('left');
				/* istanbul ignore if */
				if (!identifierPath) {
					return;
				}

				const identifierBinding = identifierPath.scope.getBinding(
					identifierPath.node.name
				);
				if (
					!identifierBinding ||
					identifierBinding.identifier !== importIdentifier
				) {
					return;
				}

				assignmentPaths.push(path);
			},

			Identifier(path) {
				// Collect all Identifiers so we can check if the potential generated default
				// import specifier is not unique.
				identifierNames.push(path.node.name);

				if (path.parentPath.isMemberExpression()) {
					return;
				}

				const identifierBinding = path.scope.getBinding(path.node.name);
				if (
					!identifierBinding ||
					identifierBinding.identifier !== importIdentifier
				) {
					return;
				}

				// Warn when not a MemberExpression of the import identifier.
				options.warningsByFilename.add(
					filePath,
					path.buildCodeFrameError(
						'Non-default or named usage of an import specifier, a manual fix may be required.'
					)
				);
			},

			MemberExpression(path) {
				const objectPath = path.get('object');
				if (!objectPath || !objectPath.isIdentifier()) {
					return;
				}

				const objectBinding = path.scope.getBinding(
					objectPath.node.name
				);
				if (
					!objectBinding ||
					!importIdentifier ||
					(objectBinding.identifier !== importIdentifier &&
						!assignmentPaths.some(
							(assignedIdentifierPath) =>
								assignedIdentifierPath.get('left').node ===
								importIdentifier
						))
				) {
					return;
				}

				const propertyPath = path.get('property');
				if (
					!propertyPath ||
					(!propertyPath.isIdentifier() &&
						!propertyPath.isStringLiteral())
				) {
					// Warn when not accessing using and Identifier or StringLiteral.
					options.warningsByFilename.add(
						filePath,
						propertyPath.buildCodeFrameError(
							'Default or named imports are dynamically accessed, a manual fix may be required.'
						)
					);
					return;
				}

				const propertyName = propertyPath.isIdentifier()
					? propertyPath.node.name
					: propertyPath.node.value;

				importMemberUsages.push({
					isDefault: propertyName === 'default',
					isNamed: propertyName !== 'default',
					path,
					propertyName,
				});
			},
		});

		// Remove the interop default AssignmentExpression when the identifier is the importIdentifier.
		assignmentPaths.forEach((assignmentPath) => {
			/* istanbul ignore else */
			if (assignmentPath.parentPath.isExpressionStatement()) {
				assignmentPath = assignmentPath.parentPath;
			}

			const closestNodeWithOffset =
				getClosestNodeWithOffset(assignmentPath);
			const descendantNodes = getDescendantNodes(assignmentPath);
			if (closestNodeWithOffset.offset === 0) {
				moveComments.asIs(
					babel,
					assignmentPath.parentPath.node,
					...descendantNodes
				);
			} else if (closestNodeWithOffset.offset > 0) {
				moveComments.asLeading(
					babel,
					closestNodeWithOffset.node,
					...descendantNodes
				);
			} else {
				moveComments.asTrailing(
					babel,
					closestNodeWithOffset.node,
					...descendantNodes
				);
			}

			assignmentPath.remove();
		});

		// No MemberExpression found on import Identifier so import as DefaultSpecifier.
		if (!importMemberUsages.length) {
			return [t.importDefaultSpecifier(importIdentifier)];
		}

		const needDefaultImport = importMemberUsages.some(
			(importMemberUsage) => importMemberUsage.isDefault
		);
		const needNamespaceImport = importMemberUsages.some(
			(importMemberUsage) => importMemberUsage.isNamed
		);

		if (needDefaultImport && needNamespaceImport) {
			// We use both default imports and named imports so import with two specifiers.
			// The default specifier will be generated. All MemberExpressions accessing the default
			// export will be replaced with the generated Identifier only.
			const preferredDefaultImportIdentifierName = `${importIdentifier.name}Default`;
			const defaultImportIdentifier = identifierNames.includes(
				preferredDefaultImportIdentifierName
			)
				? factoryFunctionBodyPath.scope.generateUidIdentifier(
						`${importIdentifier.name}Default`
				  )
				: t.identifier(preferredDefaultImportIdentifierName);
			importMemberUsages.forEach((importMemberUsage) => {
				const objectPath = importMemberUsage.path.get('object');
				/* istanbul ignore if */
				if (!objectPath || !objectPath.node) {
					throw new Error(
						'Unexpectedly missing MemberExpression object.'
					);
				}

				if (importMemberUsage.isDefault) {
					const newNode = t.identifier(defaultImportIdentifier.name);
					moveComments.asIs(
						babel,
						newNode,
						importMemberUsage.path.node
					);
					moveComments.asLeading(
						babel,
						newNode,
						importMemberUsage.path.get('object').node,
						importMemberUsage.path.get('property').node
					);
					importMemberUsage.path.replaceWith(newNode);
				}
			});
			return [
				t.importDefaultSpecifier(defaultImportIdentifier),
				t.importNamespaceSpecifier(importIdentifier),
			];
		}
		if (needDefaultImport) {
			// We only access the default export so import as such, and replace the MemberExpressions
			// with it's object Identifier only.
			importMemberUsages.forEach((importMemberUsage) => {
				const objectPath = importMemberUsage.path.get('object');
				/* istanbul ignore if */
				if (!objectPath || !objectPath.node) {
					throw new Error(
						'Unexpectedly missing MemberExpression object.'
					);
				}

				moveComments.asIs(
					babel,
					objectPath.node,
					importMemberUsage.path.node
				);
				moveComments.asTrailing(
					babel,
					objectPath.node,
					importMemberUsage.path.get('property').node
				);
				importMemberUsage.path.replaceWith(objectPath.node);
			});

			return [t.importDefaultSpecifier(importIdentifier)];
		}

		// We only access named exports so import those as such using the existing identifier.
		return [t.importNamespaceSpecifier(importIdentifier)];
	}

	function buildImportDeclarationAndFixSpecifiers(
		filePath,
		identifier,
		importPath,
		factoryFunctionNodePath
	) {
		let importSpecifiers;

		if (!identifier) {
			// Unnamed specifier.
			//
			//             import   'importPath';
			// declaration ^^^^^^^^^^^^^^^^^^^^^^ (ImportDeclaration)
			// specifiers         ^               (None)
			// source               ^^^^^^^^^^^^  (StringLiteral)
			importSpecifiers = [];
		} else if (
			options.namedExportModuleNames &&
			options.namedExportModuleNames.includes(importPath.value)
		) {
			// Some libraries use named exports, so we should import them as such.
			//
			//             import * as identifier from 'importPath';
			// declaration ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (ImportDeclaration)
			// specifier0         ^^^^^^^^^^^^^^^                    (ImportNamespaceSpecifier)
			// source                                  ^^^^^^^^^^^^  (StringLiteral)
			importSpecifiers = [t.importNamespaceSpecifier(identifier)];
		} else {
			// Default specifier.
			//
			//             import identifier from 'importPath';
			// declaration ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (ImportDeclaration)
			// specifier0         ^^^^^^^^^^                    (ImportDefaultSpecifier)
			// source                             ^^^^^^^^^^^^  (StringLiteral)
			importSpecifiers = getImportSpecifiers(
				filePath,
				importPath,
				identifier,
				factoryFunctionNodePath.get('body')
			);
		}

		// The new import declaration with zero or one import specifier.
		const importDeclaration = t.importDeclaration(
			importSpecifiers,
			importPath
		);

		moveComments.asIs(babel, importDeclaration, identifier, importPath);

		return importDeclaration;
	}

	return {
		visitor: {
			CallExpression(path) {
				// Check if the CallExpression is an AMD define call.
				if (!isAmdDefineCallExpression(babel, path)) {
					return;
				}

				// Support define(function() {}) calls, ideally we don't have those in the code base.
				// The convention we use is: define([], function() {}).
				//
				// Correct:
				//             define([], function () {});
				// path        ^^^^^^^^^^^^^^^^^^^^^^^^^^^ (CallExpression)
				// importPaths        ^^                   (ArrayExpression)
				// factoryFunc            ^^^^^^^^^^^^^^   (FunctionExpression)
				const factoryFunctionArgs = path.node.arguments;
				const factoryFunctionArgIndex =
					factoryFunctionArgs.length === 2 ? 1 : 0;
				const importPaths =
					factoryFunctionArgIndex > 0
						? factoryFunctionArgs[0].elements
						: [];
				const factoryFunction =
					factoryFunctionArgs[factoryFunctionArgIndex];
				const factoryFunctionNodePath = path.get(
					`arguments.${factoryFunctionArgIndex}`
				);

				// Make sure every import path is a static string.
				//
				// Correct:
				//             define(['./1', './2'], function () {});
				// path        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^     (CallExpression)
				// importPath0         ^^^^^                               (StringLiteral)
				// importPath1                ^^^^^                        (StringLiteral)
				//
				// Incorrect:
				//             define([something, false], function () {});
				// importPath0         ^^^^^^^^^                           (Identifier)
				// importPath1                    ^^^^^                    (BooleanLiteral)
				if (
					!importPaths.every((importPath) =>
						t.isStringLiteral(importPath)
					)
				) {
					// Warn when not converting from AMD to ESM due to imports not being a StringLiteral.
					options.warningsByFilename.add(
						this.file.opts.filename,
						path.buildCodeFrameError(
							'Conversion failed because of a non-string literal import source, a manual fix is required.'
						)
					);
					return;
				}

				// Map every importPath to a new ImportDeclarations.
				//
				//            define([
				//                './1'      ---,
				//            ], function (     |---> import import1 from './1';
				//                import1    ---'
				//            ) {});
				// source         ^^^^^                                   ^^^^^  (StringLiteral)
				// identifier     ^^^^^^^                    ^^^^^^^             (Identifier -> ImportDefaultSpecifier)
				// TODO: Example for import without identifier, and named import.
				let importDeclarations;
				try {
					importDeclarations = importPaths.map(
						(importPath, index) => {
							const identifier = factoryFunction.params[index];
							return buildImportDeclarationAndFixSpecifiers(
								this.file.opts.filename,
								identifier,
								importPath,
								factoryFunctionNodePath
							);
						}
					);
				} catch (_error) /* istanbul ignore next */ {
					// Warn when not converting from AMD to ESM due to issues with getting import declarations.
					options.warningsByFilename.add(
						this.file.opts.filename,
						path.buildCodeFrameError(
							'Conversion failed due to not being able to create import declarations, a manual fix is required.'
						)
					);
					return;
				}

				// Check for multiple return statements. If found, wrap the factoryFunctionBody in an IIFE.
				let factoryFunctionBody =
					factoryFunctionNodePath.node.body.body;
				if (
					hasMultipleReturnStatements(babel, factoryFunctionNodePath)
				) {
					// Create an IIFE that gets converted to an `export default` in the `ReturnStatement` visitor.
					//
					// Input:
					//             define(['./1'], function (i1) { if (i1) { return true; } return false; });
					// path        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (CallExpression)
					// factoryFunc                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   (FunctionExpression)
					// funcBody                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   (BlockStatement)
					// factoryFunctionBody                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^     (Array<Statement>)
					//
					// Output:
					//             define(['./1'], function (i1) { return (function() { if (i1) { return true; } return false; })(); });
					// path        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (CallExpression)
					// factoryFunc                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   (FunctionExpression)
					// funcBody                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   (BlockStatement)
					// factoryFunctionBody                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^     (Array<Statement>)
					factoryFunctionBody = [
						t.returnStatement(
							t.callExpression(
								t.functionExpression(
									null,
									[],
									t.blockStatement(
										factoryFunctionNodePath.node.body.body
									)
								),
								[]
							)
						),
					];
				}

				// Replace the AMD define CallExpression with all ImportDeclarations followed by
				// all Statements in the AMD factory FunctionExpression body.
				//
				// Input:
				//             define(['./1'], function (i1) { return i1.something; });
				// path        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (CallExpression)
				// factoryFunc                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   (FunctionExpression)
				// funcBody                                  ^^^^^^^^^^^^^^^^^^^^^^^^   (BlockStatement)
				//
				// Output:
				//       import i1 from './1';
				// path0 ^^^^^^^^^^^^^^^^^^^^^                                          (Import Declaration)
				//       return i1.something;
				// path1 ^^^^^^^^^^^^^^^^^^^^                                           (Return Statement)
				//
				// Note that the importPaths (ArrayExpression), factoryFunction (FunctionExpression),
				// and factoryFunction's body (BlockStatement) are removed.
				// Also note that the ReturnStatement is not valid on the root (Program) level; This
				// is fixed in the ReturnStatement visitor of this plugin.
				const replacements =
					importDeclarations.concat(factoryFunctionBody);
				/* istanbul ignore next */
				const parentExpressionStatement =
					path.parentPath.isExpressionStatement()
						? path.parentPath.node
						: null;
				const programPath = path.findParent((path) => path.isProgram());

				moveComments.asLeading(
					babel,
					programPath.node,
					path.node.callee
				);
				moveComments.asIs(
					babel,
					replacements[replacements.length - 1]
						? [
								programPath.node,
								replacements[replacements.length - 1],
						  ]
						: programPath.node,
					// ExpressionStatement which wraps the defined CallExpression.
					parentExpressionStatement,
					// Define CallExpression.
					path.node,
					// Factory function body block.
					factoryFunctionNodePath.node.body,
					// 'use strict';
					...(factoryFunctionNodePath.node.body.directives || [])
				);
				// Define import sources array.
				if (factoryFunctionArgIndex > 0) {
					if (importDeclarations[0]) {
						moveComments.asIs(
							babel,
							[
								importDeclarations[0],
								importDeclarations[
									importDeclarations.length - 1
								],
							],
							factoryFunctionArgs[0]
						);
					} else {
						moveComments.asLeading(
							babel,
							replacements[0] || programPath.node,
							factoryFunctionArgs[0]
						);
					}
				}
				// Factory function and it's identifier.
				if (factoryFunctionBody[0]) {
					moveComments.asLeading(
						babel,
						factoryFunctionBody[0],
						factoryFunction.id
					);
					moveComments.asIs(
						babel,
						factoryFunctionBody[0],
						factoryFunction
					);
				} else {
					moveComments.asTrailing(
						babel,
						importDeclarations[importDeclarations.length - 1] ||
							programPath.node,
						factoryFunction,
						factoryFunction.id
					);
				}

				path.replaceWithMultiple(replacements);

				// Try to register bindings from import specifiers, because that might be broken.
				// See https://github.com/babel/babel/issues/8358
				// TODO: Should we add other bindings?
				// See https://github.com/babel/babel/blob/master/packages/babel-traverse/src/scope/index.js#L461
				importDeclarations.forEach((importDeclaration, index) => {
					const importDeclarationPath = programPath.get(
						`body.${index}`
					);
					/* istanbul ignore if */
					if (importDeclarationPath.node !== importDeclaration) {
						return;
					}

					programPath.scope.registerDeclaration(
						importDeclarationPath
					);
				});
			},

			ReturnStatement(path) {
				if (!isAmdFactoryReturnStatement(path, true)) {
					return;
				}

				let returnArgument = path.node.argument;

				// In case og an empty return statement, export undefined.
				// These shouldn't exist, but it's good to be safe.
				//
				// Input:
				//                return  ;
				// path           ^^^^^^^^^         (ReturnStatement)
				// returnArgument        ^          (None)
				//
				// Output:
				//                return undefined;
				// path           ^^^^^^^^^^^^^^^^^ (ReturnStatement)
				// returnArgument        ^^^^^^^^^  (Identifier, with named 'undefined')
				if (!returnArgument) {
					returnArgument = t.identifier('undefined');
				}

				// Results in () wrapped around e.g. the install function expression.
				// Change the node type to a function declaration to fix this.
				//
				// NOTE: returnType and typeParameters are ignored in conversion because we don't
				// expect them in existing code.
				// https://babeljs.io/docs/en/babel-types#functionexpression
				// https://babeljs.io/docs/en/babel-types#functiondeclaration
				// https://github.com/webpack/webpack/pull/6889
				if (t.isFunctionExpression(returnArgument)) {
					const oldReturnArgument = returnArgument;
					returnArgument = t.functionDeclaration(
						returnArgument.id,
						returnArgument.params,
						returnArgument.body,
						returnArgument.generator,
						returnArgument.async
					);
					moveComments.asIs(babel, returnArgument, oldReturnArgument);
				}

				// Replace ReturnStatement with ExportDefaultDeclaration.
				//
				// Input:
				//      return 'something';
				// path ^^^^^^^^^^^^^^^^^^^                (ReturnStatement)
				// arg         ^^^^^^^^^^^                 (StringLiteral)
				//
				// Output:
				//             export default 'something';
				// path        ^^^^^^^^^^^^^^^^^^^^^^^^^^^ (ExportDefaultDeclaration)
				// declaration                ^^^^^^^^^^^  (StringLiteral)
				const exportDeclaration =
					t.exportDefaultDeclaration(returnArgument);
				moveComments.asIs(babel, exportDeclaration, path.node);
				path.replaceWith(exportDeclaration);
			},
		},
	};
};
