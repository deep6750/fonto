import path from 'path';

import normalisePath from '../helpers/normalisePath.js';

/** @typedef {import('enhanced-resolve').Resolver} Resolver */

const firstPathSegmentRegExp = /^.+?\//;

/**
 * Converts the given path to something that approximates its import identifier.
 *
 * @param {string} targetPath
 * @returns {string}
 */
function getApproximateImportIdentifierForPath(targetPath) {
	const parsedTargetPath = path.parse(targetPath);

	targetPath = normalisePath(
		path.join(parsedTargetPath.dir, parsedTargetPath.name)
	);

	return targetPath.replace(firstPathSegmentRegExp, '');
}

class DeepImportWarning extends Error {
	/**
	 * @param {string} message
	 * @param {string} file
	 */
	constructor(message, file) {
		super(message);

		this.file = file;
	}

	toString() {
		return this.file
			? `WARNING in ${this.file}:\n${this.message}`
			: `WARNING: ${this.message}`;
	}
}

/**
 * This plugin generates a warning for imports to platform/ or platform-linked/ from from config/,
 * packages/ or packages-shared/ that do not point to something in a package's 'src' folder.
 */
export default class CheckDeepImportsResolvePlugin {
	constructor(options = {}) {
		this.options = options;
	}

	/**
	 * @param {Resolver} resolver
	 */
	apply(resolver) {
		resolver
			.getHook('resolved')
			.tapAsync(
				CheckDeepImportsResolvePlugin.name,
				(request, _resolveContext, callback) => {
					// Can only check if there's an issuer and a resolved path.
					// Issuer: path to the file from which the import originates.
					// Path: path to the file to which the import resolves.
					if (
						!request.context ||
						!request.context.issuer ||
						!request.path
					) {
						return callback();
					}

					if (
						// Only check imports to code (i.e. .js, .ts, .jsx, .tsx).
						// The .xqm and .svg files are transformed by a loader which do a deep
						// import to XQueryModule and SVGModule respectively, for which no warning
						// is needed.
						this.options.extensions.includes(
							path.posix.extname(request.context.issuer)
						) &&
						// Only check certain issuers (i.e. packages/, packages-shared/, config/).
						this.options.issuerRegExps.some((regExp) =>
							regExp.test(request.context.issuer)
						) &&
						// Does the import target an undesired path?
						this.options.importPathRegExps.some((regExp) =>
							regExp.test(request.path)
						) &&
						// But does not match an excluded regexp.
						!this.options.importPathExcludeRegExps.some((regExp) =>
							regExp.test(request.path)
						)
					) {
						// Make the absolute paths easier to read.
						const relativePath = path.relative(
							this.options.contextFolder,
							request.path
						);
						const relativeIssuer = path.relative(
							this.options.contextFolder,
							request.context.issuer
						);

						// We don't have access to the import identifier matching the resolved path
						// at this point, so approximate it for the warning message. Should be about
						// right most of the time, but we can't say for sure.
						const importIdentifier =
							getApproximateImportIdentifierForPath(relativePath);

						// Pass the warning to the output plugin so it can properly output it after
						// the compilation finishes.
						const warning = new DeepImportWarning(
							`Import "${importIdentifier}" is not supported and might cause problems in future versions.`,
							relativeIssuer
						);
						if (this.options.fdtOutputPlugin) {
							this.options.fdtOutputPlugin.warn(warning);
						} else {
							console.warn(`\n${warning.toString()}`);
						}
					}

					// We do not need to mutate the request, so call the callback without arguments.
					return callback();
				}
			);
	}
}
