export default (moduleRegistration, _app) => {
	async function moduleController(req, res) {
		const rawOutput = !!req.options.raw;

		let destroySpinner;
		if (!rawOutput) {
			res.caption(req.command.getLongName());
			destroySpinner = res.spinner('Retrieving all Fonto versions...');
		}

		const versionData = await req.fdt.license.getVersionsForProduct(
			'editor'
		);

		if (destroySpinner) {
			destroySpinner();
		}

		const sdkVersions = req.options.all
			? versionData.getAll()
			: versionData.getAllStable();

		if (!rawOutput) {
			res.caption('Fonto versions');

			const potentialPostFixes = new Map();
			potentialPostFixes.set('fdt', req.fdt.version);
			if (req.fdt.editorRepository.path) {
				potentialPostFixes.set(
					'editor',
					req.fdt.editorRepository.sdkVersion
				);
			}
			if (req.fdt.backendAppRepository.path) {
				potentialPostFixes.set(
					req.fdt.backendAppRepository.productId || 'backend-app',
					req.fdt.backendAppRepository.sdkVersion
				);
			}

			res.list(
				sdkVersions.map((version) => {
					const postFixes = [];
					for (const [postFix, sdkVersion] of potentialPostFixes) {
						if (sdkVersion && sdkVersion.compare(version) === 0) {
							postFixes.push(postFix);
						}
					}
					return `${version.format()}${
						postFixes.length ? ` (${postFixes.join(', ')})` : ''
					}`;
				}),
				'-'
			);
		} else {
			res.raw(sdkVersions.map((version) => version.format()).join('\n'));
		}
	}

	moduleRegistration
		.registerCommand('versions', moduleController)
		.setDescription('Output all available Fonto (SDK) versions.')
		.addOption('raw', undefined, 'Make the command output easier to parse.')
		.addHiddenOption(
			'all',
			undefined,
			'Include nightly and prerelease versions.'
		)
		.setRawOutput((req) => !!req.options.raw);
};
