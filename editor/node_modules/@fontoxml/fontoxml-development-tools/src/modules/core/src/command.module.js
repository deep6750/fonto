import path from 'path';

export default (moduleRegistration, app) => {
	async function moduleController(req, res) {
		res.caption(req.command.getLongName());

		if (req.options.list) {
			if (req.options.verbose) {
				app.modules.forEach((appModule) => {
					if (appModule.hidden) {
						return;
					}
					const info = appModule.getInfo();
					res.caption(info.name);
					delete info.name;
					res.indent();
					res.properties(info);
					res.outdent();
				});
			} else {
				res.list(
					app.modules
						.filter((appModule) => !appModule.hidden)
						.map((appModule) => appModule.getInfo().name),
					'-'
				);
			}

			return;
		}

		if (![].concat(req.options.add, req.options.remove).length) {
			res.debug('No modules to add or remove.');
			return;
		}

		if (req.options.remove.length) {
			res.debug(`Try disabling ${req.options.remove.length} modules`);
		}

		req.options.remove.forEach((option) => {
			const modulePath = path.resolve(process.cwd(), option);
			const modIndex = app.modules.findIndex(
				(appModule) => appModule.getInfo().path === modulePath
			);

			if (modIndex === -1) {
				return res.property(
					'skipped',
					`${modulePath} was not loaded`,
					null,
					'notice'
				);
			}

			const mod = app.modules[modIndex];
			const modInfo = mod.getInfo();

			res.property('disable', `${modInfo.name} (${modInfo.version})`);

			app.modules.splice(modIndex, 1);

			const configIndex = app.config.modules.findIndex(
				(modPath) =>
					path.resolve(app.config.getLocation(), modPath) ===
					modInfo.path
			);

			if (configIndex !== -1) {
				app.config.modules.splice(configIndex, 1);
			}
		});

		if (req.options.add.length) {
			res.debug(`Try enabling ${req.options.add.length} modules`);
		}

		for (const option of req.options.add) {
			const modulePath = path.resolve(process.cwd(), option);

			const existingModAtPath = app.modules.find(
				(mod) => mod.getInfo().path === modulePath
			);
			if (existingModAtPath) {
				res.property(
					'skipped',
					`The module at "${modulePath}" was already added.`
				);
				return;
			}

			try {
				const mod = await app.silentEnableModule(modulePath);

				if (!mod) {
					res.property(
						'skipped',
						`Could not add module at "${modulePath}", might be a duplicate.`,
						null,
						'notice'
					);
				} else {
					app.config.modules.push(modulePath);

					const modInfo = mod.getInfo();
					res.property(
						'enabled',
						`${modInfo.name} (${modInfo.version})`
					);
				}
			} catch (e) {
				res.property('skipped', e.stack, null, 'notice');
			}
		}

		res.break();

		return !req.options.dry
			? app.config.save().then((configLocation) => {
					res.success(`Saved ${path.basename(configLocation)}`);
					res.debug(
						`Type "${
							moduleRegistration.getAppInfo().name
						} who" to find your current running configuration.`
					);
			  })
			: res.notice('Not saving configuration file');
	}

	moduleRegistration
		.registerHiddenCommand('module', moduleController)
		.setDescription("Tool's module management.")

		.addOption(
			new moduleRegistration.MultiOption('add')
				.setDescription('Add a module.')
				.setDefault([], true)
				.setShort('a')
		)
		.addOption(
			new moduleRegistration.MultiOption('remove')
				.setDescription('Remove a module.')
				.setDefault([], true)
				.setShort('r')
		)
		.addOption(
			'dry',
			'D',
			'Simulated run, do not save the new module configuration.'
		)

		.addOption('list', 'l', 'List all enabled modules.')
		.addOption('verbose', 'v', 'Use verbose output when listing modules.')

		.addExample(
			`${
				moduleRegistration.getAppInfo().name
			} module --add ./anywhere/my-fdt-module`,
			'Add a module to the tool and store it in the configuration file.'
		)
		.addExample(
			`${
				moduleRegistration.getAppInfo().name
			} module --remove ./anywhere/my-fdt-module`,
			'Remove a module from the tool and store it in the configuration file.'
		)
		.addExample(
			`${moduleRegistration.getAppInfo().name} module --list --verbose`,
			'Remove a module from the tool and store it in the configuration file.'
		);
};
