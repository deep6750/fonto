import os from 'os';
import path from 'path';

import commandFDT from './src/command.fdt.js';
import commandLicenseValidate from './src/command.license.validate.js';
import commandModule from './src/command.module.js';
import commandVersion from './src/command.version.js';
import commandVersions from './src/command.versions.js';
import commandWho from './src/command.who.js';
import precontrollerDebug from './src/precontroller.debug.js';
import precontrollerHelp from './src/precontroller.help.js';

export default (moduleRegistration, app, options) => {
	moduleRegistration.registerContextInformer((_request, response) => {
		response.properties({
			Hostname: os.hostname(),
			Node: `Version ${process.version} running on ${process.platform} ${process.arch}.`,
			FDT: `Version ${app.version.format()}${
				app.isLocalVersion ? ' (local clone)' : ''
			}.`,
			Install: path.resolve(app.binPath, '..'),
			Config: app.config
				.getStatus()
				.map((loc) => loc.path + (loc.exists ? '' : ' (missing)'))
				.join(os.EOL),
		});
	});

	moduleRegistration.registerContextInformer((_request, response) => {
		response.caption('Modules');

		const visibleModules = app.modules.filter(
			(appModule) => !appModule.hidden
		);

		if (!visibleModules.length) {
			response.debug('No external modules loaded.');
			return;
		}

		visibleModules.forEach((visibleModule) => {
			const info = visibleModule.getInfo();
			response.log(info.name);
			delete info.name;
			response.indent();
			response.properties(info);
			response.outdent();
		});
	});

	precontrollerDebug(moduleRegistration, app, options);
	precontrollerHelp(moduleRegistration, app, options);
	commandFDT(moduleRegistration, app, options);
	commandModule(moduleRegistration, app, options);
	commandVersion(moduleRegistration, app, options);
	commandVersions(moduleRegistration, app, options);
	commandWho(moduleRegistration, app, options);

	// Only add Fonto related logic when configured to do so.
	if (!options.skipAddModules) {
		moduleRegistration.registerContextInformer((request, response) => {
			response.caption('Fonto');

			const editorRepository =
				request && request.fdt && request.fdt.editorRepository;

			if (
				editorRepository &&
				(editorRepository.name ||
					editorRepository.sdkVersion ||
					editorRepository.path)
			) {
				const formattedSdkVersion = editorRepository.sdkVersion
					? editorRepository.sdkVersion.format()
					: undefined;
				response.properties({
					Application: editorRepository.name,
					'SDK version': formattedSdkVersion,
					Path: editorRepository.path,
					...(editorRepository.hasPlatformLinked
						? { 'Linked platform': true }
						: null),
				});
			} else {
				response.log(
					"You're not running from inside a Fonto Editor repository."
				);
			}

			if (editorRepository && editorRepository.config) {
				const editorConfig = editorRepository.config;
				const configOutput = {};

				// Known config properties with formatters
				if (editorConfig.scope) {
					configOutput.scope = JSON.stringify(editorConfig.scope);
				}
				if (editorConfig.proxy) {
					configOutput.proxy = JSON.stringify(editorConfig.proxy);
				}
				configOutput['fdt modules'] =
					editorConfig.developmentToolsModules
						? editorConfig.developmentToolsModules.join(', ')
						: 'none';

				// Other config
				const otherConfigKeys = Object.keys(editorConfig).filter(
					(key) =>
						['scope', 'proxy', 'developmentToolsModules'].indexOf(
							key
						) === -1
				);
				otherConfigKeys.forEach((key) => {
					configOutput[key] = JSON.stringify(editorConfig[key]);
				});

				if (editorRepository.configSource) {
					response.caption(
						`Fonto config (${path.basename(
							editorRepository.configSource
						)})`
					);
				} else {
					response.caption('Fonto config');
				}
				response.properties(configOutput);
			}
		});

		moduleRegistration.registerContextInformer((request, response) => {
			response.caption(`Fonto backend app`);

			const backendAppRepository =
				request && request.fdt && request.fdt.backendAppRepository;

			if (!backendAppRepository || !backendAppRepository.path) {
				response.log(
					"You're not running from inside a Fonto backend app repository."
				);
				return;
			}

			const formattedSdkVersion = backendAppRepository.sdkVersion
				? backendAppRepository.sdkVersion.format()
				: undefined;
			response.properties({
				Product: backendAppRepository.productId,
				'SDK version': formattedSdkVersion,
				Path: backendAppRepository.path,
			});

			if (backendAppRepository.config) {
				if (backendAppRepository.configSource) {
					response.caption(
						`Fonto backend app config (${path.basename(
							backendAppRepository.configSource
						)})`
					);
				} else {
					response.caption('Fonto backend app config');
				}
				response.properties(backendAppRepository.config);
			}
		});

		const licenseCommand = moduleRegistration
			.registerCommand('license')
			.setDescription('License management.')
			.setAsHelpCommand();

		commandLicenseValidate(moduleRegistration, licenseCommand);
	}
};
