import fs from 'fs-extra';
import path from 'path';

import babel from '@babel/core';
import babelPresetEnv from '@babel/preset-env';
import babelPresetReact from '@babel/preset-react';
import babelPresetTypescript from '@babel/preset-typescript';

import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const t = babel.types;

/**
 * Try to parse format `export default [ 'namespace:location:1', 'namespace:location:n', ];`.
 *
 * @param {babel.types.File} fileAst
 *
 * @returns {string[]}
 */
function tryGetFromExportDefault(fileAst) {
	t.assertFile(fileAst);
	t.assertProgram(fileAst.program);
	const exportDefaultDeclaration = fileAst.program.body.find((statement) =>
		t.isExportDefaultDeclaration(statement),
	);
	t.assertExportDefaultDeclaration(exportDefaultDeclaration);
	t.assertArrayExpression(exportDefaultDeclaration.declaration);
	exportDefaultDeclaration.declaration.elements.every((declaration) =>
		t.assertStringLiteral(declaration),
	);
	return exportDefaultDeclaration.declaration.elements.map(
		(element) => element.value,
	);
}

/**
 * Try to parse format:
 * ```
 * define([], function () {
 * 	'use strict';
 * 	return ['urn:packages.xsd', 'packages.dtd'];
 * });
 * ```
 *
 * @param {babel.types.File} fileAst
 *
 * @returns {string[]}
 */
function tryGetFromDefine(fileAst) {
	t.assertFile(fileAst);
	t.assertProgram(fileAst.program);
	const defineExpressionStatement = fileAst.program.body.find(
		(statement) =>
			t.isExpressionStatement(statement) &&
			t.isCallExpression(statement.expression) &&
			t.isIdentifier(statement.expression.callee) &&
			statement.expression.callee.name === 'define' &&
			statement.expression.arguments?.length >= 2 &&
			t.isArrayExpression(statement.expression.arguments[0]) &&
			t.isFunctionExpression(statement.expression.arguments[1]) &&
			t.isBlockStatement(statement.expression.arguments[1].body) &&
			statement.expression.arguments[1].body.body.some((bodyStatement) =>
				t.isReturnStatement(bodyStatement),
			),
	);
	t.assertExpressionStatement(defineExpressionStatement);
	const returnStatement =
		defineExpressionStatement.expression.arguments[1].body.body.find(
			(bodyStatement) =>
				t.isReturnStatement(bodyStatement) &&
				t.isArrayExpression(bodyStatement.argument) &&
				bodyStatement.argument.elements.every((element) =>
					t.isStringLiteral(element),
				),
		);
	t.assertReturnStatement(returnStatement);
	return returnStatement.argument.elements.map((element) => element.value);
}

const TRY_GET_LOCATIONS = [tryGetFromExportDefault, tryGetFromDefine];

/**
 * Returns all schema locations from the SCHEMA_LOCATION file from a shell package.
 *
 * @throws Note that this throws in case of an unsupported syntax.
 *
 * @param  {string} schemaLocationsPath
 *
 * @return  {string[]}
 */
export default function getSchemaLocationsFromSource(schemaLocationsPath) {
	const source = fs.readFileSync(schemaLocationsPath, 'utf8');
	// @TODO: Share Babel settings with the settings used for Fonto Editor builds.
	const ast = babel.parseSync(source, {
		babelrc: false,
		browserslistConfigFile: false,
		configFile: false,
		// Resolve only from FDT, not any other location.
		cwd: __dirname,
		filename: schemaLocationsPath,
		presets: [
			[
				babelPresetEnv,
				{
					bugfixes: true,
					ignoreBrowserslistConfig: true,
					loose: true,
					targets: { esmodules: true },
				},
			],
			[
				babelPresetReact,
				{
					runtime: 'automatic',
				},
			],
			[
				babelPresetTypescript,
				{
					allowDeclareFields: true,
					onlyRemoveTypeImports: true,
				},
			],
		],
		targets: { esmodules: true },
	});

	let lastError;
	for (const tryGet of TRY_GET_LOCATIONS) {
		try {
			return tryGet(ast);
		} catch (error) {
			lastError = error;
		}
	}

	throw (
		lastError ||
		new Error(`Could not get locations from source "${schemaLocationsPath}".`)
	);
}
